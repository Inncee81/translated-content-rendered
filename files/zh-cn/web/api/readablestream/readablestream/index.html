---
title: ReadableStream.ReadableStream()
slug: Web/API/ReadableStream/ReadableStream
translation_of: Web/API/ReadableStream/ReadableStream
---
<div><div class="draft notecard">
    <p><strong>草案</strong><br>
    本页尚未完工.</p>

</div><div class="experimental indicator-warning notecard">
    <p><strong>这是一个实验中的功能</strong><br>此功能某些浏览器尚在开发中，请参考<a href="#Browser_compatibility">浏览器兼容性表格</a>以得到在不同浏览器中适合使用的前缀。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。</p>
</div><section class="Quick_links" id="Quick_Links"><ol><li><strong><a href="/zh-CN/docs/Web/API/Streams_API">Streams API</a></strong></li><li><strong><a href="/zh-CN/docs/Web/API/ReadableStream"><code>ReadableStream</code></a></strong></li><li class="toggle"><details open><summary>Constructor</summary><ol><li><em><code>ReadableStream()</code></em></li></ol></details></li><li class="toggle"><details open><summary>属性</summary><ol><li><a href="/zh-CN/docs/Web/API/ReadableStream/locked"><code>locked</code></a> <a href="/zh-CN/docs/Web/API/ReadableStream/locked$translate" style="opacity: 0.5;">[我来译!]</a></li></ol></details></li><li class="toggle"><details open><summary>方法</summary><ol><li><a href="/zh-CN/docs/Web/API/ReadableStream/cancel"><code>cancel()</code></a> <a href="/zh-CN/docs/Web/API/ReadableStream/cancel$translate" style="opacity: 0.5;">[我来译!]</a></li><li><a href="/zh-CN/docs/Web/API/ReadableStream/getReader"><code>getReader()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/ReadableStream/pipeThrough"><code>pipeThrough()</code></a> <a href="/zh-CN/docs/Web/API/ReadableStream/pipeThrough$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/ReadableStream/pipeTo"><code>pipeTo()</code></a> <a href="/zh-CN/docs/Web/API/ReadableStream/pipeTo$translate" style="opacity: 0.5;">[我来译!]</a></li><li><a href="/zh-CN/docs/Web/API/ReadableStream/tee"><code>tee()</code></a> <a href="/zh-CN/docs/Web/API/ReadableStream/tee$translate" style="opacity: 0.5;">[我来译!]</a></li></ol></details></li><li class="toggle"><details open><summary>Related pages for Streams</summary><ol><li><a href="/zh-CN/docs/Web/API/Body/body"><code>Body.body</code></a></li><li><a href="/zh-CN/docs/Web/API/ByteLengthQueuingStrategy"><code>ByteLengthQueuingStrategy</code></a></li><li><a href="/zh-CN/docs/Web/API/CountQueuingStrategy"><code>CountQueuingStrategy</code></a></li><li><a href="/zh-CN/docs/Web/API/ReadableByteStreamController"><code>ReadableByteStreamController</code></a></li><li><a href="/zh-CN/docs/Web/API/ReadableStreamBYOBReader"><code>ReadableStreamBYOBReader</code></a></li><li><a href="/zh-CN/docs/Web/API/ReadableStreamBYOBRequest"><code>ReadableStreamBYOBRequest</code></a></li><li><a href="/zh-CN/docs/Web/API/ReadableStreamDefaultController"><code>ReadableStreamDefaultController</code></a></li><li><a href="/zh-CN/docs/Web/API/ReadableStreamDefaultReader"><code>ReadableStreamDefaultReader</code></a></li><li><a href="/zh-CN/docs/Web/API/WindowOrWorkerGlobalScope/fetch"><code>WindowOrWorkerGlobalScope.fetch()</code></a></li><li><a href="/zh-CN/docs/Web/API/WritableStream"><code>WritableStream</code></a></li><li><a href="/zh-CN/docs/Web/API/WritableStreamDefaultController"><code>WritableStreamDefaultController</code></a></li><li><a href="/zh-CN/docs/Web/API/WritableStreamDefaultWriter"><code>WritableStreamDefaultWriter</code></a></li></ol></details></li></ol></section></div>

<p class="summary"><strong><code>ReadableStream()</code></strong> 构造器创建并返回包含处理函数的可读流实例.</p>

<h2 id="语法">语法</h2>

<pre class="syntaxbox notranslate">var readableStream = new ReadableStream(<em>underlyingSource</em>[, queueingStrategy]);</pre>

<h3 id="参数">参数</h3>

<dl>
 <dt>underlyingSource</dt>
 <dd>一个包含定义了构造流行为方法和属性的对象.<code>underlyingSource</code> 包括:
 <dl>
  <dt>start(controller)</dt>
  <dd>这是一个当对象被构造时立刻调用的方法.此方法的内容由开发人员定义，并应着眼于访问流,并执行其他任何必需的设置流功能.如果这个过程是异步完成的，它可以返回一个promise，表明成功或失败.传递给这个方法的<code>controller</code>是一个<a href="/zh-CN/docs/Web/API/ReadableStreamDefaultController"><code>ReadableStreamDefaultController</code></a>或<a href="/zh-CN/docs/Web/API/ReadableByteStreamController"><code>ReadableByteStreamController</code></a>,具体取决于<code>type</code>属性的值。开发人员可以使用此方法在设立期间控制流.</dd>
  <dt>pull(controller) <span class="optional optionalInline notecard inline">可选</span></dt>
  <dd>这个方法，也是由开发人员定义的，当流的内部队列不满时，会重复调用这个方法，直到队列补满。如果<code>pull()</code>返回一个promise，那么它将不会再被调用，直到promise完成;如果promise失败，该流将会出现错误.传递给此方法的<code>controller</code>参数是<a href="/zh-CN/docs/Web/API/ReadableStreamDefaultController"><code>ReadableStreamDefaultController</code></a>或<a href="/zh-CN/docs/Web/API/ReadableByteStreamController"><code>ReadableByteStreamController</code></a>,具体取决于<code>type</code>属性的值。由于更多的块被获取,这个方法可以被开发人员用来控制流.</dd>
  <dt>cancel(reason) <span class="optional optionalInline notecard inline">可选</span></dt>
  <dd>如果应用程序表示该流将被取消（例如,调用了<a href="/zh-CN/docs/Web/API/ReadableStream/cancel"><code>ReadableStream.cancel()</code></a>，则将调用此方法，该方法也由开发人员定义。 该方法应该做任何必要的事情来释放对流的访问。 如果这个过程是异步的，它可以返回一个promise,表明成功或失败.原因参数包含一个<a href="/zh-CN/docs/Web/API/DOMString"><code>DOMString</code></a>,它描述了流被取消的原因.</dd>
  <dt>type <span class="optional optionalInline notecard inline">可选</span></dt>
  <dd>该属性控制正在处理的可读类型的流。如果它包含一个设置为<code>bytes</code>的值，则传递的控制器对象将是一个<a href="/zh-CN/docs/Web/API/ReadableByteStreamController"><code>ReadableByteStreamController</code></a>，能够处理BYOB（带您自己的缓冲区）/字节流。如果未包含，则传递的控制器将为<a href="/zh-CN/docs/Web/API/ReadableStreamDefaultController"><code>ReadableStreamDefaultController</code></a>。</dd>
  <dt>autoAllocateChunkSize <span class="optional optionalInline notecard inline">可选</span></dt>
  <dd>对于字节流，开发人员可以使用正整数值设置<code>autoAllocateChunkSize</code> 以打开流的自动分配功能。启用此功能后，流实现将自动分配一个具有给定整数大小的<a href="/zh-CN/docs/Web/API/ArrayBuffer"><code>ArrayBuffer</code></a>，并调用底层源代码，就好像消费者正在使用BYOB阅读器一样。</dd>
 </dl>
 </dd>
 <dt>queueingStrategy <span class="optional optionalInline notecard inline">可选</span></dt>
 <dd>一个可选择定义流的排队策略的对象。这需要两个参数：
 <dl>
  <dt>highWaterMark</dt>
  <dd>非负整数 - 这定义了在应用背压之前可以包含在内部队列中的块的总数。</dd>
  <dt>size(chunk)</dt>
  <dd>包含参数<code>chunk</code> 的方法 - 这表示每个块使用的大小（以字节为单位）.</dd>
 </dl>

 <div class="note notecard">
 <p><strong>Note</strong>: You could define your own custom <code>queueingStrategy</code>, or use an instance of <a href="/zh-CN/docs/Web/API/ByteLengthQueueingStrategy"><code>ByteLengthQueueingStrategy</code></a> or <a href="/zh-CN/docs/Web/API/CountQueueingStrategy"><code>CountQueueingStrategy</code></a> for this object value. If no <code>queueingStrategy</code> is supplied, the default used is the same as a <code>CountQueuingStrategy</code> with a high water mark of 1.</p>
 </div>
 </dd>
</dl>

<h3 id="返回值">返回值</h3>

<p><a href="/zh-CN/docs/Web/API/ReadableStream"><code>ReadableStream</code></a>对象的实例.</p>

<h3 id="错误">错误</h3>

<dl>
 <dt>RangeError</dt>
 <dd>提供的值既不是<code>bytes</code>也不是<code>undefined</code>.</dd>
</dl>

<h2 id="例子">例子</h2>

<p>In the following simple example, a custom <code>ReadableStream</code> is created using a constructor (see our <a href="https://mdn.github.io/dom-examples/streams/simple-random-stream/">Simple random stream example</a> for the full code). The <code>start()</code> function generates a random string of text every second and enqueues it into the stream. A <code>cancel()</code> fuction is also provided to stop the generation if <a href="/zh-CN/docs/Web/API/ReadableStream/cancel"><code>ReadableStream.cancel()</code></a> is called for any reason.</p>

<p>When a button is pressed, the generation is stopped, the stream is closed using <a href="/zh-CN/docs/Web/API/ReadableStreamDefaultController/close"><code>ReadableStreamDefaultController.close()</code></a>, and another function is run, which reads the data back out of the stream.</p>

<pre class="brush: js notranslate">const stream = new ReadableStream({
  start(controller) {
    interval = setInterval(() =&gt; {
      let string = randomChars();

      // Add the string to the stream
      controller.enqueue(string);

      // show it on the screen
      let listItem = document.createElement(&apos;li&apos;);
      listItem.textContent = string;
      list1.appendChild(listItem);
    }, 1000);

    button.addEventListener(&apos;click&apos;, function() {
      clearInterval(interval);
      fetchStream();
      controller.close();
    })
  },
  pull(controller) {
    // We don&apos;t really need a pull in this example
  },
  cancel() {
    // This is called if the reader cancels,
    // so we should stop generating strings
    clearInterval(interval);
  }
});</pre>

<h2 id="Specifications">Specifications</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Specification</th>
   <th scope="col">Status</th>
   <th scope="col">Comment</th>
  </tr>
  <tr>
   <td><a class="external" href="https://streams.spec.whatwg.org/#rs-constructor" hreflang="en" lang="en">Streams<br><small lang="zh-CN">ReadableStream()</small></a></td>
   <td><span class="spec-Living">Living Standard</span></td>
   <td>Initial definition.</td>
  </tr>
 </tbody>
</table>

<h2 id="Browser_compatibility">Browser compatibility</h2>

<div class="hidden">
<p>The compatibility table on this page is generated from structured data. If you&apos;d like to contribute to the data, please check out <a href="https://github.com/mdn/browser-compat-data">https://github.com/mdn/browser-compat-data</a> and send us a pull request.</p>
</div>

<div class="bc-data" id="bcd:api.ReadableStream.ReadableStream"></div>

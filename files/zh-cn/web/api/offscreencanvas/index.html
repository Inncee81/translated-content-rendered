---
title: OffscreenCanvas
slug: Web/API/OffscreenCanvas
tags:
  - API
  - Canvas
  - Experimental
  - Interface
  - Reference
translation_of: Web/API/OffscreenCanvas
---
<div><section class="Quick_links" id="Quick_Links"><ol><li><strong><a href="/zh-CN/docs/Web/API/Canvas_API">Canvas API</a></strong></li><li><strong><a href="/zh-CN/docs/Web/API/OffscreenCanvas"><code>OffscreenCanvas</code></a></strong></li><li class="toggle"><details open><summary>Constructor</summary><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/OffscreenCanvas/OffscreenCanvas"><code>OffscreenCanvas()</code></a></li></ol></details></li><li class="toggle"><details open><summary>属性</summary><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/OffscreenCanvas/height"><code>height</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/OffscreenCanvas/width"><code>width</code></a> <a href="/zh-CN/docs/Web/API/OffscreenCanvas/width$translate" style="opacity: 0.5;">[我来译!]</a></li></ol></details></li><li class="toggle"><details open><summary>方法</summary><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/OffscreenCanvas/toBlob"><code>convertToBlob()</code></a> <a href="/zh-CN/docs/Web/API/OffscreenCanvas/toBlob$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/OffscreenCanvas/OffscreenCanvas.convertToBlob()"><code>convertToBlob()</code></a> <a href="/zh-CN/docs/Web/API/OffscreenCanvas/OffscreenCanvas.convertToBlob()$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/OffscreenCanvas/convertToBlob"><code>convertToBlob()</code></a> <a href="/zh-CN/docs/Web/API/OffscreenCanvas/convertToBlob$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/OffscreenCanvas/getContext"><code>getContext()</code></a> <a href="/zh-CN/docs/Web/API/OffscreenCanvas/getContext$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/OffscreenCanvas/transferToImageBitmap"><code>transferToImageBitmap()</code></a></li></ol></details></li><li class="toggle"><details open><summary>继承</summary><ol><li><a href="/zh-CN/docs/Web/API/EventTarget"><code>EventTarget</code></a></li></ol></details></li><li class="toggle"><details open><summary>Related pages for Canvas API</summary><ol><li><a href="/zh-CN/docs/Web/API/Canvas"><code>Canvas</code></a></li><li><a href="/zh-CN/docs/Web/API/CanvasGradient"><code>CanvasGradient</code></a></li><li><a href="/zh-CN/docs/Web/API/CanvasImageSource"><code>CanvasImageSource</code></a></li><li><a href="/zh-CN/docs/Web/API/CanvasPattern"><code>CanvasPattern</code></a></li><li><a href="/zh-CN/docs/Web/API/CanvasRenderingContext2D"><code>CanvasRenderingContext2D</code></a></li><li><a href="/zh-CN/docs/Web/API/HTMLCanvasElement"><code>HTMLCanvasElement</code></a></li><li><a href="/zh-CN/docs/Web/API/ImageBitmap"><code>ImageBitmap</code></a></li><li><a href="/zh-CN/docs/Web/API/ImageBitmapFactories"><code>ImageBitmapFactories</code></a></li><li><a href="/zh-CN/docs/Web/API/ImageBitmapRenderingContext"><code>ImageBitmapRenderingContext</code></a></li><li><a href="/zh-CN/docs/Web/API/ImageData"><code>ImageData</code></a></li><li><a href="/zh-CN/docs/Web/API/Path2D"><code>Path2D</code></a></li><li><a href="/zh-CN/docs/Web/API/RenderingContext"><code>RenderingContext</code></a></li><li><a href="/zh-CN/docs/Web/API/TextMetrics"><code>TextMetrics</code></a></li></ol></details></li></ol></section> <div class="experimental indicator-warning notecard">
    <p><strong>这是一个实验中的功能</strong><br>此功能某些浏览器尚在开发中，请参考<a href="#Browser_compatibility">浏览器兼容性表格</a>以得到在不同浏览器中适合使用的前缀。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。</p>
</div></div>

<p><strong><code>OffscreenCanvas提供了一个可以脱离屏幕渲染的canvas对象。它在窗口环境和<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API">web worker</a>环境均有效。</code></strong></p>

<h2 id="构造函数">构造函数</h2>

<dl>
 <dt><a href="/zh-CN/docs/Web/API/OffscreenCanvas/OffscreenCanvas"><code>OffscreenCanvas()</code></a></dt>
 <dd><code>OffscreenCanvas构造函数。创建一个新的</code><code>OffscreenCanvas对象。</code></dd>
</dl>

<h2 id="属性">属性</h2>

<dl>
 <dt><a href="/zh-CN/docs/Web/API/OffscreenCanvas/height"><code>OffscreenCanvas.height</code></a></dt>
 <dd>offscreen canvas对象的高度。</dd>
 <dt><a href="/zh-CN/docs/Web/API/OffscreenCanvas/width"><code>OffscreenCanvas.width</code></a></dt>
 <dd>offscreen canvas对象的宽度。</dd>
</dl>

<h2 id="方法">方法</h2>

<dl>
 <dt><a href="/zh-CN/docs/Web/API/OffscreenCanvas/getContext"><code>OffscreenCanvas.getContext()</code></a></dt>
 <dd>为offscreen canvas对象返回一个渲染画布。</dd>
</dl>

<dl>
 <dt><a href="/zh-CN/docs/Web/API/OffscreenCanvas/toBlob"><code>OffscreenCanvas.toBlob()</code></a></dt>
 <dd>创建一个代表canvas中的图像的<a href="/zh-CN/docs/Web/API/Blob"><code>Blob</code></a>对象。</dd>
</dl>

<dl>
 <dt><a href="/zh-CN/docs/Web/API/OffscreenCanvas/transferToImageBitmap"><code>OffscreenCanvas.transferToImageBitmap()</code></a></dt>
 <dd>从<code>OffscreenCanvas最近渲染的图像</code>创建一个 <a href="/zh-CN/docs/Web/API/ImageBitmap"><code>ImageBitmap</code></a> 对象。</dd>
</dl>

<h2 id="例子">例子</h2>

<h3 id="同步显示OffscreenCanvas中的帧">同步显示<code>OffscreenCanvas中的帧</code></h3>

<p>一种方式是使用<code>OffscreenCanvas</code> API，也就是用已经包含<code>OffscreenCanvas</code>对象的<a href="/zh-CN/docs/Web/API/RenderingContext"><code>RenderingContext</code></a> 来生成新的帧。 每次一个新的帧在画布中完成渲染，<a href="/zh-CN/docs/Web/API/OffscreenCanvas/transferToImageBitmap"><code>transferToImageBitmap()</code></a> 方法都会被调用来保存最近渲染的图像。该方法返回一个<a href="/zh-CN/docs/Web/API/ImageBitmap"><code>ImageBitmap</code></a>对象，该对象可以被用在各种Web APIs中，也可以用在下一个canvas中，并且不需要转换备份。</p>

<p>为了显示<code>ImageBitmap</code>，你可以用<a href="/zh-CN/docs/Web/API/ImageBitmapRenderingContext"><code>ImageBitmapRenderingContext</code></a>上下文，通过一个canvas（可见的）元素调用<code>canvas.getContext(&quot;bitmaprenderer&quot;)</code>方法来创建它。该上下文只提供用<code>ImageBitmap</code>替换canvas的内容的功能。调用<a href="/zh-CN/docs/Web/API/ImageBitmapRenderingContext/transferFromImageBitmap"><code>ImageBitmapRenderingContext.transferFromImageBitmap()</code></a> 以前的渲染结果并且通过OffscreenCanvas保存<code>ImageBitmap</code>，会在canvas里显示<code>ImageBitmap</code>并且转换其所有权到canvas。 一个单独的OffscreenCanvas可以将帧转换到任意数量的其他<code>ImageBitmapRenderingContext</code>对象。</p>

<p>提供两个 <a href="/zh-CN/docs/Web/HTML/Element/canvas" title="&lt;canvas&gt;元素可被用来通过JavaScript（Canvas API 或 WebGL API）绘制图形及图形动画。"><code>&lt;canvas&gt;</code></a> 元素</p>

<pre class="brush: html notranslate">&lt;canvas id=&quot;one&quot;&gt;&lt;/canvas&gt;
&lt;canvas id=&quot;two&quot;&gt;&lt;/canvas&gt;</pre>

<p>下面的代码会用<code>OffscreenCanva提供渲染结果，就像上面描述的一样。</code></p>

<pre class="brush: js notranslate">var one = document.getElementById(&quot;one&quot;).getContext(&quot;bitmaprenderer&quot;);
var two = document.getElementById(&quot;two&quot;).getContext(&quot;bitmaprenderer&quot;);

var offscreen = new OffscreenCanvas(256, 256);
var gl = offscreen.getContext(&apos;webgl&apos;);

// ... some drawing for the first canvas using the gl context ...

// Commit rendering to the first canvas
var bitmapOne = offscreen.transferToImageBitmap();
one.transferFromImageBitmap(bitmapOne);

// ... some more drawing for the second canvas using the gl context ...

// Commit rendering to the second canvas
var bitmapTwo = offscreen.transferToImageBitmap();
two.transferFromImageBitmap(bitmapTwo);
</pre>

<h3 id="异步显示OffscreenCanvas生成的帧"> 异步显示<code>OffscreenCanvas生成的帧</code></h3>

<p><code>另一种使用 OffscreenCanvas</code> API的方式, 是在一个<a href="/zh-CN/docs/Web/HTML/Element/canvas" title="&lt;canvas&gt;元素可被用来通过JavaScript（Canvas API 或 WebGL API）绘制图形及图形动画。"><code>&lt;canvas&gt;</code></a>元素上调用<a href="/zh-CN/docs/Web/API/HTMLCanvasElement/transferControlToOffscreen"><code>transferControlToOffscreen()</code></a>， 也可以在<a href="/en-US/docs/Web/API/Web_Workers_API">worker</a>或主线程,上调用，这将从主线程的<a href="/zh-CN/docs/Web/API/HTMLCanvasElement"><code>HTMLCanvasElement</code></a>对象返回一个<code>OffscreenCanvas对象。调用</code><a href="/zh-CN/docs/Web/API/OffscreenCanvas/getContext"><code>getContext()</code></a> 会从这个<code>OffscreenCanvas获取一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/RenderingContext">RenderingContext </a>。</code></p>

<p>main.js (主线程代码):</p>

<pre class="brush: js notranslate">var htmlCanvas = document.getElementById(&quot;canvas&quot;);
var offscreen = htmlCanvas.transferControlToOffscreen();

var worker = new Worker(&quot;offscreencanvas.js&quot;);
worker.postMessage({canvas: offscreen}, [offscreen]);
</pre>

<p>offscreencanvas.js (web work代码):</p>

<pre class="brush: js notranslate">onmessage = function(evt) {
  var canvas = evt.data.canvas.
  var gl = canvas.getContext(&quot;webgl&quot;);

  // ... some drawing using the gl context ...

  // Push frames back to the original HTMLCanvasElement
  gl.commit();
};
</pre>

<p>也可以在 worker 中使用 requestAnimationFrame</p>

<pre class="brush: js notranslate">onmessage = function(evt) {
  const canvas = evt.data.canvas;
  const gl = canvas.getContext(&quot;webgl&quot;);

  function render(time) {
    // ... some drawing using the gl context ...
    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);
};</pre>

<h2 id="规范">规范</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">规范</th>
   <th scope="col">状态</th>
   <th scope="col">备注</th>
  </tr>
  <tr>
   <td><a class="external" href="https://html.spec.whatwg.org/multipage/scripting.html#the-offscreencanvas-interface" hreflang="en" lang="en">HTML Living Standard<br><small lang="zh-CN">OffscreenCanvas</small></a></td>
   <td><span class="spec-Living">Living Standard</span></td>
   <td></td>
  </tr>
 </tbody>
</table>

<h2 id="浏览器兼容性">浏览器兼容性</h2>

<div>
<div class="hidden">该兼容性表由结构化数据自动生成. 如果你愿意贡献数据，请向 <a href="https://github.com/mdn/browser-compat-data">https://github.com/mdn/browser-compat-data</a> 提交 pull request.</div>

<div class="bc-data" id="bcd:api.OffscreenCanvas"></div>
</div>

<h2 id="另请参见">另请参见</h2>

<ul>
 <li><a href="https://hacks.mozilla.org/2016/01/webgl-off-the-main-thread/">WebGL Off the Main Thread – Mozilla Hacks</a></li>
 <li><a href="/zh-CN/docs/Web/API/CanvasRenderingContext2D"><code>CanvasRenderingContext2D</code></a></li>
 <li><a href="/zh-CN/docs/Web/API/ImageBitmap"><code>ImageBitmap</code></a></li>
 <li><a href="/zh-CN/docs/Web/API/ImageBitmapRenderingContext"><code>ImageBitmapRenderingContext</code></a></li>
 <li><a href="/zh-CN/docs/Web/API/HTMLCanvasElement/transferControlToOffscreen"><code>HTMLCanvasElement.transferControlToOffscreen()</code></a></li>
 <li><a href="/zh-CN/docs/Web/API/WebGLRenderingContext/commit"><code>WebGLRenderingContext.commit()</code></a></li>
</ul>

<div id="gtx-anchor" style="position: absolute; left: 78px; top: 2140px; width: 183px; height: 20px;"></div>

<div class="jfk-bubble gtx-bubble" style>
<div class="jfk-bubble-content-id" id="bubble-3">
<div id="gtx-host" style="max-width: 400px;"></div>
</div>

<div class="jfk-bubble-closebtn-id jfk-bubble-closebtn"></div>

<div class="jfk-bubble-arrow-id jfk-bubble-arrow jfk-bubble-arrowdown" style="left: 71.5px;">
<div class="jfk-bubble-arrowimplbefore"></div>

<div class="jfk-bubble-arrowimplafter"></div>
</div>
</div>

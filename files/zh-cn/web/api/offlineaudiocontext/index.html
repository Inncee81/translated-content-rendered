---
title: OfflineAudioContext
slug: Web/API/OfflineAudioContext
translation_of: Web/API/OfflineAudioContext
---
<div><section class="Quick_links" id="Quick_Links"><ol><li><strong><a href="/zh-CN/docs/Web/API/Web_Audio_API">Web Audio API</a></strong></li><li><strong><a href="/zh-CN/docs/Web/API/OfflineAudioContext"><code>OfflineAudioContext</code></a></strong></li><li class="toggle"><details open><summary>Constructor</summary><ol><li><a href="/zh-CN/docs/Web/API/OfflineAudioContext/OfflineAudioContext"><code>OfflineAudioContext()</code></a></li></ol></details></li><li class="toggle"><details open><summary>属性</summary><ol><li><a href="/zh-CN/docs/Web/API/OfflineAudioContext/length"><code>length</code></a></li><li><a href="/zh-CN/docs/Web/API/OfflineAudioContext/oncomplete"><code>oncomplete</code></a> <a style="opacity: 0.5;" href="/zh-CN/docs/Web/API/OfflineAudioContext/oncomplete$translate">[我来译!]</a></li></ol></details></li><li class="toggle"><details open><summary>方法</summary><ol><li><a href="/zh-CN/docs/Web/API/OfflineAudioContext/resume"><code>resume()</code></a> <a style="opacity: 0.5;" href="/zh-CN/docs/Web/API/OfflineAudioContext/resume$translate">[我来译!]</a></li><li><a href="/zh-CN/docs/Web/API/OfflineAudioContext/startRendering"><code>startRendering()</code></a> <a style="opacity: 0.5;" href="/zh-CN/docs/Web/API/OfflineAudioContext/startRendering$translate">[我来译!]</a></li><li><a href="/zh-CN/docs/Web/API/OfflineAudioContext/suspend"><code>suspend</code></a></li></ol></details></li><li class="toggle"><details open><summary>继承</summary><ol><li><a href="/zh-CN/docs/Web/API/AudioContext"><code>AudioContext</code></a></li><li><a href="/zh-CN/docs/Web/API/EventTarget"><code>EventTarget</code></a></li></ol></details></li><li class="toggle"><details open><summary>Events</summary><ol><li><a href="/zh-CN/docs/Web/Events/statechange"><code>statechange</code></a></li><li><a href="/zh-CN/docs/Web/Events/complete"><code>complete</code></a></li><li><a href="/zh-CN/docs/Web/Events/ended"><code>ended</code></a></li><li><a href="/zh-CN/docs/Web/Events/message"><code>message</code></a></li><li><a href="/zh-CN/docs/Web/Events/loaded"><code>loaded</code></a></li><li><a href="/zh-CN/docs/Web/Events/audioprocess"><code>audioprocess</code></a></li><li><a href="/zh-CN/docs/Web/Events/nodecreate"><code>nodecreate</code></a></li></ol></details></li><li class="toggle"><details open><summary>Related pages for Web Audio API</summary><ol><li><a href="/zh-CN/docs/Web/API/AnalyserNode"><code>AnalyserNode</code></a></li><li><a href="/zh-CN/docs/Web/API/AudioBuffer"><code>AudioBuffer</code></a></li><li><a href="/zh-CN/docs/Web/API/AudioBufferSourceNode"><code>AudioBufferSourceNode</code></a></li><li><a href="/zh-CN/docs/Web/API/AudioContext"><code>AudioContext</code></a></li><li><a href="/zh-CN/docs/Web/API/AudioContextOptions"><code>AudioContextOptions</code></a></li><li><a href="/zh-CN/docs/Web/API/AudioDestinationNode"><code>AudioDestinationNode</code></a></li><li><a href="/zh-CN/docs/Web/API/AudioListener"><code>AudioListener</code></a></li><li><a href="/zh-CN/docs/Web/API/AudioNode"><code>AudioNode</code></a></li><li><a href="/zh-CN/docs/Web/API/AudioNodeOptions"><code>AudioNodeOptions</code></a></li><li><a href="/zh-CN/docs/Web/API/AudioParam"><code>AudioParam</code></a></li><li><a href="/zh-CN/docs/Web/API/AudioProcessingEvent"><code>AudioProcessingEvent</code></a></li><li><a href="/zh-CN/docs/Web/API/AudioScheduledSourceNode"><code>AudioScheduledSourceNode</code></a></li><li><a href="/zh-CN/docs/Web/API/BaseAudioContext"><code>BaseAudioContext</code></a></li><li><a href="/zh-CN/docs/Web/API/BiquadFilterNode"><code>BiquadFilterNode</code></a></li><li><a href="/zh-CN/docs/Web/API/ChannelMergerNode"><code>ChannelMergerNode</code></a></li><li><a href="/zh-CN/docs/Web/API/ChannelSplitterNode"><code>ChannelSplitterNode</code></a></li><li><a href="/zh-CN/docs/Web/API/ConstantSourceNode"><code>ConstantSourceNode</code></a></li><li><a href="/zh-CN/docs/Web/API/ConvolverNode"><code>ConvolverNode</code></a></li><li><a href="/zh-CN/docs/Web/API/DelayNode"><code>DelayNode</code></a></li><li><a href="/zh-CN/docs/Web/API/DynamicsCompressorNode"><code>DynamicsCompressorNode</code></a></li><li><a href="/zh-CN/docs/Web/API/GainNode"><code>GainNode</code></a></li><li><a href="/zh-CN/docs/Web/API/IIRFilterNode"><code>IIRFilterNode</code></a></li><li><a href="/zh-CN/docs/Web/API/MediaElementAudioSourceNode"><code>MediaElementAudioSourceNode</code></a></li><li><a href="/zh-CN/docs/Web/API/MediaStreamAudioDestinationNode"><code>MediaStreamAudioDestinationNode</code></a></li><li><a href="/zh-CN/docs/Web/API/MediaStreamAudioSourceNode"><code>MediaStreamAudioSourceNode</code></a></li><li><a href="/zh-CN/docs/Web/API/OfflineAudioCompletionEvent"><code>OfflineAudioCompletionEvent</code></a></li><li><a href="/zh-CN/docs/Web/API/OscillatorNode"><code>OscillatorNode</code></a></li><li><a href="/zh-CN/docs/Web/API/PannerNode"><code>PannerNode</code></a></li><li><a href="/zh-CN/docs/Web/API/PeriodicWave"><code>PeriodicWave</code></a></li><li><a href="/zh-CN/docs/Web/API/StereoPannerNode"><code>StereoPannerNode</code></a></li><li><a href="/zh-CN/docs/Web/API/WaveShaperNode"><code>WaveShaperNode</code></a></li></ol></details></li></ol></section></div>

<p><code>OfflineAudioContext</code> 接口是一个 <a href="/zh-CN/docs/Web/API/AudioContext" title="AudioContext接口表示由音频模块连接而成的音频处理图，每个模块对应一个AudioNode。AudioContext可以控制它所包含的节点的创建，以及音频处理、解码操作的执行。做任何事情之前都要先创建AudioContext对象，因为一切都发生在这个环境之中。"><code>AudioContext</code></a> 的接口，代表由多个 <a href="/zh-CN/docs/Web/API/AudioNode" title="AudioNode 接口是一个处理音频的通用模块, 比如一个音频源 (e.g. 一个 HTML &lt;audio&gt; or &lt;video&gt; 元素), 一个音频地址或者一个中间处理模块 (e.g. 一个过滤器如 BiquadFilterNode, 或一个音量控制器如 GainNode)."><code>AudioNode</code></a> 连接在一起构成的音频处理图。与 <a href="/zh-CN/docs/Web/API/AudioContext" title="AudioContext接口表示由音频模块连接而成的音频处理图，每个模块对应一个AudioNode。AudioContext可以控制它所包含的节点的创建，以及音频处理、解码操作的执行。做任何事情之前都要先创建AudioContext对象，因为一切都发生在这个环境之中。"><code>AudioContext</code></a> 标准相反的是， <code>OfflineAudioContext</code> 不在硬件设备渲染音频；相反，它尽可能快地生成音频，输出一个 <a href="/zh-CN/docs/Web/API/AudioBuffer" title="这些类型对象被设计来控制小音频片段，往往短于45秒。对于更长的声音，通过 MediaElementAudioSourceNode来实现更为合适。缓存区（buffer）包含以下数据：不间断的IEEE75432位线性PCM，从-1到1的范围额定，就是说，32位的浮点缓存区的每个样本在-1.0到1.0之间。如果AudioBuffer有不同的频道，他们通常被保存在独立的缓存区。"><code>AudioBuffer</code></a> 作为结果。</p>

<h2 id="构造函数">构造函数</h2>

<dl>
 <dt><a href="/zh-CN/docs/Web/API/OfflineAudioContext/OfflineAudioContext" title="OfflineAudioContext() 构造函数创建一个新的 OfflineAudioContext 对象实例。"><code>OfflineAudioContext.OfflineAudioContext()</code></a></dt>
 <dd>创建一个新的 <code>OfflineAudioContext</code> 实例。</dd>
</dl>

<h2 id="属性">属性</h2>

<p><em>从父级 <a href="/zh-CN/docs/Web/API/AudioContext" title="AudioContext接口表示由音频模块连接而成的音频处理图，每个模块对应一个AudioNode。AudioContext可以控制它所包含的节点的创建，以及音频处理、解码操作的执行。做任何事情之前都要先创建AudioContext对象，因为一切都发生在这个环境之中。"><code>AudioContext</code></a> 获取属性。</em></p>

<dl>
 <dt><a href="/zh-CN/docs/Web/API/OfflineAudioContext/length" title="OfflineAudioContext 接口的 length 属性返回一个代表采样帧的缓冲区大小的整数。"><code>OfflineAudioContext.length</code></a> <span class="readOnly readOnlyInline notecard inline" title="该属性的值无法更改">只读 </span></dt>
 <dd>代表采样帧缓冲区大小的整数。</dd>
</dl>

<h3 id="事件处理程序">事件处理程序</h3>

<dl>
 <dt><a href="/zh-CN/docs/Web/API/OfflineAudioContext/oncomplete" title="此页面仍未被本地化, 期待您的翻译!"><code>OfflineAudioContext.oncomplete</code></a></dt>
 <dd>当进程完成时，基于事件版本的<a href="/zh-CN/docs/Web/API/OfflineAudioContext/startRendering" title="此页面仍未被本地化, 期待您的翻译!"><code>OfflineAudioContext.startRendering()</code></a> 被使用之后，<a href="/zh-CN/docs/Web/API/EventHandler" title="此页面仍未被本地化, 期待您的翻译!"><code>EventHandler</code></a> 将会被调用，<code><a href="/zh-CN/docs/Web/Reference/Events/complete" title="/zh-CN/docs/Web/Reference/Events/complete">complete</a></code> 事件类型为 <a href="/zh-CN/docs/Web/API/OfflineAudioCompletionEvent" title="此页面仍未被本地化, 期待您的翻译!"><code>OfflineAudioCompletionEvent</code></a>）被触发。</dd>
</dl>

<h2 id="方法">方法</h2>

<p><em>从父级 <a href="/zh-CN/docs/Web/API/AudioContext" title="AudioContext接口表示由音频模块连接而成的音频处理图，每个模块对应一个AudioNode。AudioContext可以控制它所包含的节点的创建，以及音频处理、解码操作的执行。做任何事情之前都要先创建AudioContext对象，因为一切都发生在这个环境之中。"><code>AudioContext</code></a> 和 <a href="/zh-CN/docs/Web/API/EventTarget" title="EventTarget是一个由可以接收事件的对象实现的接口，并且可以为它们创建侦听器。"><code>EventTarget</code></a> 获取方法的实现。</em></p>

<dl>
 <dt><a href="/zh-CN/docs/Web/API/OfflineAudioContext/resume" title="此页面仍未被本地化, 期待您的翻译!"><code>OfflineAudioContext.resume()</code></a></dt>
 <dd>恢复一个被暂停的音频的时间进程。</dd>
 <dt><a href="/zh-CN/docs/Web/API/OfflineAudioContext/suspend" title="The suspend() method of the OfflineAudioContext interface schedules a suspension of the time progression in the audio context at the specified time and returns a promise. This is generally useful at the time of manipulating the audio graph synchronously on OfflineAudioContext."><code>OfflineAudioContext.suspend()</code></a></dt>
 <dd>在指定的时间安排音频暂停时间进程，并且通过 Promise 返回。</dd>
 <dt><a href="/zh-CN/docs/Web/API/OfflineAudioContext/startRendering" title="此页面仍未被本地化, 期待您的翻译!"><code>OfflineAudioContext.startRendering()</code></a></dt>
 <dd>开始渲染音频，考虑当前连接和当前计划的修改。这个页面涵盖基于事件的和基于 Promise 的版本。</dd>
</dl>

<h2 id="例子">例子</h2>

<p>这个简单的例子中，我们声明了 <a href="/zh-CN/docs/Web/API/AudioContext" title="AudioContext接口表示由音频模块连接而成的音频处理图，每个模块对应一个AudioNode。AudioContext可以控制它所包含的节点的创建，以及音频处理、解码操作的执行。做任何事情之前都要先创建AudioContext对象，因为一切都发生在这个环境之中。"><code>AudioContext</code></a> 和 <code>OfflineAudioContext</code> 对象。我们使用 <code>AudioContext</code> 去加载一个 XHR （<a href="/zh-CN/docs/Web/API/AudioContext/decodeAudioData" title="这是从音频轨道创建用于web audio API音频源的首选方法。"><code>AudioContext.decodeAudioData</code></a>）获取的音轨，然后使用 <code>OfflineAudioContext</code> 去渲染音频并得到一个 into an <a href="/zh-CN/docs/Web/API/AudioBufferSourceNode" title="AudioBufferSourceNode 接口继承自,表现为一个音频源，它包含了一些写在内存中的音频数据，通常储存在一个ArrayBuffer对象中。在处理有严格的时间精确度要求的回放的情形下它尤其有用。比如播放那些需要满足一个指定节奏的声音或者那些储存在内存而不是硬盘或者来自网络的声音。为了播放那些有时间精确度需求但来自网络的流文件或者来自硬盘，则使用"><code>AudioBufferSourceNode</code></a>，并播放这个音轨。在离线音频处理图建立后，你需要去使用 <a href="/zh-CN/docs/Web/API/OfflineAudioContext/startRendering" title="此页面仍未被本地化, 期待您的翻译!"><code>OfflineAudioContext.startRendering</code></a> 来渲染它成为 <a href="/zh-CN/docs/Web/API/AudioBuffer" title="这些类型对象被设计来控制小音频片段，往往短于45秒。对于更长的声音，通过 MediaElementAudioSourceNode来实现更为合适。缓存区（buffer）包含以下数据：不间断的IEEE75432位线性PCM，从-1到1的范围额定，就是说，32位的浮点缓存区的每个样本在-1.0到1.0之间。如果AudioBuffer有不同的频道，他们通常被保存在独立的缓存区。"><code>AudioBuffer</code></a>。</p>

<p>当 <code>startRendering()</code> 的 Promise 解决后，渲染也完成了，在 Promise 内可以获得输出的 <code>AudioBuffer。</code></p>

<p>在此刻，我们创建了一个另外的音频上下文，在它里面创建了一个 <a href="/zh-CN/docs/Web/API/AudioBufferSourceNode" title="AudioBufferSourceNode 接口继承自,表现为一个音频源，它包含了一些写在内存中的音频数据，通常储存在一个ArrayBuffer对象中。在处理有严格的时间精确度要求的回放的情形下它尤其有用。比如播放那些需要满足一个指定节奏的声音或者那些储存在内存而不是硬盘或者来自网络的声音。为了播放那些有时间精确度需求但来自网络的流文件或者来自硬盘，则使用"><code>AudioBufferSourceNode</code></a>，并且设置它的 buffer 为之前生成的 Promise 中的 <code>AudioBuffer。这样它就可以作为简单标准音频图来播放了</code>。</p>

<div class="note notecard">
<p><strong>注意</strong>: 为了获取可以运行的例子，请看我们在 Github 的仓库 <a href="https://mdn.github.io/webaudio-examples/offline-audio-context-promise/">offline-audio-context-promise</a> （也可以看到 <a href="https://github.com/mdn/webaudio-examples/tree/master/offline-audio-context-promise">源代码</a>。）</p>
</div>

<pre class="brush: js">// 定义一个在线或者离线的音频上下文

var audioCtx = new AudioContext();
var offlineCtx = new OfflineAudioContext(2,44100*40,44100);

source = offlineCtx.createBufferSource();

// 使用 XHR 去加载一个音轨，
// 使用 decodeAudioData 去解码，
// 使用 OfflineAudioContext 去渲染它

function getData() {
  request = new XMLHttpRequest();

  request.open(&apos;GET&apos;, &apos;viper.ogg&apos;, true);

  request.responseType = &apos;arraybuffer&apos;;

  request.onload = function() {
    var audioData = request.response;

    audioCtx.decodeAudioData(audioData, function(buffer) {
      myBuffer = buffer;
      source.buffer = myBuffer;
      source.connect(offlineCtx.destination);
      source.start();
      //source.loop = true;
      offlineCtx.startRendering().then(function(renderedBuffer) {
        console.log(&apos;渲染完全成功&apos;);
        var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        var song = audioCtx.createBufferSource();
        song.buffer = renderedBuffer;

        song.connect(audioCtx.destination);

        play.onclick = function() {
          song.start();
        }
      }).catch(function(err) {
          console.log(&apos;渲染失败: &apos; + err);
          // 注意: 当 OfflineAudioContext 上 startRendering 被立刻调用，Promise 应该被 reject
      });
    });
  }

  request.send();
}

// 运行 getData 去开始这个进程

getData();</pre>

<h2 id="备注">备注</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Specification</th>
   <th scope="col">Status</th>
   <th scope="col">Comment</th>
  </tr>
  <tr>
   <td><a lang="en" href="https://webaudio.github.io/web-audio-api/#OfflineAudioContext" class="external" hreflang="en">Web Audio API<br><small lang="zh-CN">OfflineAudioContext</small></a></td>
   <td><span class="spec-WD">Working Draft</span></td>
   <td>Initial definition</td>
  </tr>
 </tbody>
</table>

<h2 id="浏览器兼容性">浏览器兼容性</h2>

<div><div class="warning notecard"><strong><a href="https://github.com/mdn/browser-compat-data">We&apos;re converting our compatibility data into a machine-readable JSON format</a></strong>.
            This compatibility table still uses the old format,
            because we haven&apos;t yet converted the data it contains.
            <strong><a href="/zh-CN/docs/MDN/Contribute/Structures/Compatibility_tables">Find out how you can help!</a></strong></div>

<div class="htab">
    <a id="AutoCompatibilityTable" name="AutoCompatibilityTable"></a>
    <ul>
        <li class="selected"><a>Desktop</a></li>
        <li><a>Mobile</a></li>
    </ul>
</div></div>

<div id="compat-desktop">
<table class="compat-table">
 <tbody>
  <tr>
   <th>Feature</th>
   <th>Chrome</th>
   <th>Edge</th>
   <th>Firefox (Gecko)</th>
   <th>Internet Explorer</th>
   <th>Opera</th>
   <th>Safari (WebKit)</th>
  </tr>
  <tr>
   <td>Basic support</td>
   <td>10.0<span class="prefixBox prefixBoxInline notecard inline" title="prefix"><a href="/zh-CN/docs/Web/Guide/Prefixes">webkit</a></span></td>
   <td><span style="color: #888;" title="Please update this with the earliest version of support.">(Yes)</span></td>
   <td><a href="/en-US/Firefox/Releases/25">25.0</a> (25.0)</td>
   <td><span style="color: #f00;">未实现</span></td>
   <td>15.0<span class="prefixBox prefixBoxInline notecard inline" title="prefix"><a href="/zh-CN/docs/Web/Guide/Prefixes">webkit</a></span><br>
    22 (unprefixed)</td>
   <td>6.0<span class="prefixBox prefixBoxInline notecard inline" title="prefix"><a href="/zh-CN/docs/Web/Guide/Prefixes">webkit</a></span></td>
  </tr>
  <tr>
   <td>Promise-based <code>startRendering()</code></td>
   <td>42.0</td>
   <td><span style="color: rgb(255, 153, 0);" title="Compatibility unknown; please update this.">?</span></td>
   <td><a href="/en-US/Firefox/Releases/37">37.0</a> (37.0)</td>
   <td><span style="color: rgb(255, 153, 0);" title="Compatibility unknown; please update this.">?</span></td>
   <td><span style="color: rgb(255, 153, 0);" title="Compatibility unknown; please update this.">?</span></td>
   <td><span style="color: rgb(255, 153, 0);" title="Compatibility unknown; please update this.">?</span></td>
  </tr>
  <tr>
   <td><code>suspend()</code>, <code>resume()</code></td>
   <td>49.0</td>
   <td><span style="color: rgb(255, 153, 0);" title="Compatibility unknown; please update this.">?</span></td>
   <td> </td>
   <td> </td>
   <td> </td>
   <td> </td>
  </tr>
  <tr>
   <td><code>length</code></td>
   <td>51.0</td>
   <td><span style="color: rgb(255, 153, 0);" title="Compatibility unknown; please update this.">?</span></td>
   <td> </td>
   <td> </td>
   <td> </td>
   <td> </td>
  </tr>
 </tbody>
</table>
</div>

<div id="compat-mobile">
<table class="compat-table">
 <tbody>
  <tr>
   <th>Feature</th>
   <th>Android Webview</th>
   <th>Firefox Mobile (Gecko)</th>
   <th>Firefox OS</th>
   <th>Edge</th>
   <th>IE Mobile</th>
   <th>Opera Mobile</th>
   <th>Safari Mobile</th>
   <th>Chrome for Android</th>
  </tr>
  <tr>
   <td>Basic support</td>
   <td>33.0</td>
   <td>26.0</td>
   <td>1.2</td>
   <td><span style="color: #888;" title="Please update this with the earliest version of support.">(Yes)</span></td>
   <td><span style="color: rgb(255, 153, 0);" title="Compatibility unknown; please update this.">?</span></td>
   <td><span style="color: rgb(255, 153, 0);" title="Compatibility unknown; please update this.">?</span></td>
   <td><span style="color: rgb(255, 153, 0);" title="Compatibility unknown; please update this.">?</span></td>
   <td><span style="color: #888;" title="Please update this with the earliest version of support.">(Yes)</span></td>
  </tr>
  <tr>
   <td>Promise-based <code>startRendering()</code></td>
   <td>42.0</td>
   <td>37.0</td>
   <td>2.2</td>
   <td><span style="color: rgb(255, 153, 0);" title="Compatibility unknown; please update this.">?</span></td>
   <td><span style="color: rgb(255, 153, 0);" title="Compatibility unknown; please update this.">?</span></td>
   <td><span style="color: rgb(255, 153, 0);" title="Compatibility unknown; please update this.">?</span></td>
   <td><span style="color: rgb(255, 153, 0);" title="Compatibility unknown; please update this.">?</span></td>
   <td>42.0</td>
  </tr>
  <tr>
   <td><code>suspend()</code>, <code>resume()</code></td>
   <td>49.0</td>
   <td> </td>
   <td> </td>
   <td><span style="color: rgb(255, 153, 0);" title="Compatibility unknown; please update this.">?</span></td>
   <td> </td>
   <td> </td>
   <td> </td>
   <td>49.0</td>
  </tr>
  <tr>
   <td><code>length</code></td>
   <td>51.0</td>
   <td> </td>
   <td> </td>
   <td><span style="color: rgb(255, 153, 0);" title="Compatibility unknown; please update this.">?</span></td>
   <td> </td>
   <td> </td>
   <td> </td>
   <td>51.0</td>
  </tr>
 </tbody>
</table>
</div>

<h2 id="参见">参见</h2>

<ul>
 <li><a href="/zh-CN/docs/Web/API/Web_Audio_API/Using_Web_Audio_API">Web Audio API 的运用</a></li>
</ul>

---
title: RTCPeerConnection
slug: Web/API/RTCPeerConnection
tags:
  - WebRTC
  - 视频通话
translation_of: Web/API/RTCPeerConnection
---
<section class="Quick_links" id="Quick_Links"><ol><li><strong><a href="/zh-CN/docs/Web/API/RTCPeerConnection"><code>RTCPeerConnection</code></a></strong></li><li class="toggle"><details open><summary>Constructor</summary><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/RTCPeerConnection"><code>RTCPeerConnection()</code></a></li></ol></details></li><li class="toggle"><details open><summary>属性</summary><ol><li><a href="/zh-CN/docs/Web/API/RTCPeerConnection/canTrickleIceCandidates"><code>canTrickleIceCandidates</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/connectionState"><code>connectionState</code></a></li><li><a href="/zh-CN/docs/Web/API/RTCPeerConnection/currentLocalDescription"><code>currentLocalDescription</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/currentLocalDescription$translate" style="opacity: 0.5;">[我来译!]</a></li><li><a href="/zh-CN/docs/Web/API/RTCPeerConnection/currentRemoteDescription"><code>currentRemoteDescription</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/currentRemoteDescription$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/defaultIceServers"><code>defaultIceServers</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/defaultIceServers$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/iceConnectionState"><code>iceConnectionState</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/iceGatheringState"><code>iceGatheringState</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/iceGatheringState$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/localDescription"><code>localDescription</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/localDescription$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/onaddstream"><code>onaddstream</code></a></li><li><a href="/zh-CN/docs/Web/API/RTCPeerConnection/onconnectionstatechange"><code>onconnectionstatechange</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/onconnectionstatechange$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/ondatachannel"><code>ondatachannel</code></a></li><li><a href="/zh-CN/docs/Web/API/RTCPeerConnection/onicecandidate"><code>onicecandidate</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/oniceconnectionstatechange"><code>oniceconnectionstatechange</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/oniceconnectionstatechange$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/onicegatheringstatechange"><code>onicegatheringstatechange</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/onicegatheringstatechange$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/onidentityresult"><code>onidentityresult</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/onidentityresult$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This is an obsolete API and is no longer guaranteed to work."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/zh-CN/docs/Web/API/RTCPeerConnection/onidpassertionerror"><code>onidpassertionerror</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/onidpassertionerror$translate" style="opacity: 0.5;">[我来译!]</a></s></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This is an obsolete API and is no longer guaranteed to work."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/zh-CN/docs/Web/API/RTCPeerConnection/onidpvalidationerror"><code>onidpvalidationerror</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/onidpvalidationerror$translate" style="opacity: 0.5;">[我来译!]</a></s></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/onnegotiationneeded"><code>onnegotiationneeded</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/onnegotiationneeded$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This is an obsolete API and is no longer guaranteed to work."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/zh-CN/docs/Web/API/RTCPeerConnection/onpeeridentity"><code>onpeeridentity</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/onpeeridentity$translate" style="opacity: 0.5;">[我来译!]</a></s></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/onremovestream"><code>onremovestream</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/onremovestream$translate" style="opacity: 0.5;">[我来译!]</a></li><li><a href="/zh-CN/docs/Web/API/RTCPeerConnection/onsignalingstatechange"><code>onsignalingstatechange</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/onsignalingstatechange$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/ontrack"><code>ontrack</code></a></li><li><a href="/zh-CN/docs/Web/API/RTCPeerConnection/peerIdentity"><code>peerIdentity</code></a></li><li><a href="/zh-CN/docs/Web/API/RTCPeerConnection/pendingLocalDescription"><code>pendingLocalDescription</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/pendingLocalDescription$translate" style="opacity: 0.5;">[我来译!]</a></li><li><a href="/zh-CN/docs/Web/API/RTCPeerConnection/pendingRemoteDescription"><code>pendingRemoteDescription</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/pendingRemoteDescription$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/remoteDescription"><code>remoteDescription</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/sctp"><code>sctp</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/sctp$translate" style="opacity: 0.5;">[我来译!]</a></li><li><a href="/zh-CN/docs/Web/API/RTCPeerConnection/signalingState"><code>signalingState</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/signalingState$translate" style="opacity: 0.5;">[我来译!]</a></li></ol></details></li><li class="toggle"><details open><summary>方法</summary><ol><li><a href="/zh-CN/docs/Web/API/RTCPeerConnection/addIceCandidate"><code>addIceCandidate()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/addStream"><code>addStream()</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/addStream$translate" style="opacity: 0.5;">[我来译!]</a></li><li><a href="/zh-CN/docs/Web/API/RTCPeerConnection/addTrack"><code>addTrack()</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/addTrack$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/close"><code>close()</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/close$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/createAnswer"><code>createAnswer()</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/createAnswer$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/createDataChannel"><code>createDataChannel()</code></a></li><li><a href="/zh-CN/docs/Web/API/RTCPeerConnection/createOffer"><code>createOffer()</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/createOffer$translate" style="opacity: 0.5;">[我来译!]</a></li><li><a href="/zh-CN/docs/Web/API/RTCPeerConnection/generateCertificate"><code>generateCertificate()</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/generateCertificate$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/getConfiguration"><code>getConfiguration()</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/getConfiguration$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/getIdentityAssertion"><code>getIdentityAssertion()</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/getIdentityAssertion$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/getLocalStreams"><code>getLocalStreams()</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/getLocalStreams$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/getReceivers"><code>getReceivers()</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/getReceivers$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/getRemoteStreams"><code>getRemoteStreams()</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/getRemoteStreams$translate" style="opacity: 0.5;">[我来译!]</a></li><li><a href="/zh-CN/docs/Web/API/RTCPeerConnection/getSenders"><code>getSenders()</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/getSenders$translate" style="opacity: 0.5;">[我来译!]</a></li><li><a href="/zh-CN/docs/Web/API/RTCPeerConnection/getStats"><code>getStats()</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/getStats$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/getStreamById"><code>getStreamById()</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/getStreamById$translate" style="opacity: 0.5;">[我来译!]</a></li><li><a href="/zh-CN/docs/Web/API/RTCPeerConnection/getTransceivers"><code>getTransceivers()</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/getTransceivers$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/removeStream"><code>removeStream()</code></a></li><li><a href="/zh-CN/docs/Web/API/RTCPeerConnection/removeTrack"><code>removeTrack()</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/removeTrack$translate" style="opacity: 0.5;">[我来译!]</a></li><li><a href="/zh-CN/docs/Web/API/RTCPeerConnection/restartIce"><code>restartIce()</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/restartIce$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/setConfiguration"><code>setConfiguration()</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/setConfiguration$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/setIdentityProvider"><code>setIdentityProvider()</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/setIdentityProvider$translate" style="opacity: 0.5;">[我来译!]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="这是一个实验性的 API，请尽量不要在生产环境中使用它。"><i class="icon-beaker"> </i></span></span><a href="/zh-CN/docs/Web/API/RTCPeerConnection/setLocalDescription"><code>setLocalDescription()</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/setLocalDescription$translate" style="opacity: 0.5;">[我来译!]</a></li><li><a href="/zh-CN/docs/Web/API/RTCPeerConnection/setRemoteDescription"><code>setRemoteDescription()</code></a></li></ol></details></li><li class="toggle"><details open><summary>Events</summary><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="This is an obsolete API and is no longer guaranteed to work."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/zh-CN/docs/Web/API/RTCPeerConnection/addstream_event"><code>addstream</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/addstream_event$translate" style="opacity: 0.5;">[我来译!]</a></s></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This is an obsolete API and is no longer guaranteed to work."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/zh-CN/docs/Web/API/RTCPeerConnection/identityresult_event"><code>identityresult</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/identityresult_event$translate" style="opacity: 0.5;">[我来译!]</a></s></li><li><a href="/zh-CN/docs/Web/API/RTCPeerConnection/negotiationneeded_event"><code>negotiationneeded</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/negotiationneeded_event$translate" style="opacity: 0.5;">[我来译!]</a></li><li><a href="/zh-CN/docs/Web/API/RTCPeerConnection/removestream_event"><code>removestream</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/removestream_event$translate" style="opacity: 0.5;">[我来译!]</a></li><li><a href="/zh-CN/docs/Web/API/RTCPeerConnection/signalingstatechange_event"><code>signalingstatechange</code></a> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/signalingstatechange_event$translate" style="opacity: 0.5;">[我来译!]</a></li></ol></details></li><li class="toggle"><details open><summary>继承</summary><ol><li><a href="/zh-CN/docs/Web/API/EventTarget"><code>EventTarget</code></a></li></ol></details></li></ol></section><div class="experimental indicator-warning notecard">
    <p><strong>这是一个实验中的功能</strong><br>此功能某些浏览器尚在开发中，请参考<a href="#Browser_compatibility">浏览器兼容性表格</a>以得到在不同浏览器中适合使用的前缀。由于该功能对应的标准文档可能被重新修订，所以在未来版本的浏览器中该功能的语法和行为可能随之改变。</p>
</div>

<p><strong><code>RTCPeerConnection</code></strong> 接口代表一个由本地计算机到远端的WebRTC连接。该接口提供了创建，保持，监控，关闭连接的方法的实现。</p>

<div class="note">
<p><strong>提示:</strong> <code>RTCPeerConnection</code> 和<a href="https://developer.mozilla.org/en-US/docs/Web/API/RTCSessionDescription" title="The RTCSessionDescription interface describes one end of a connection—or potential connection—and how it&apos;s configured. Each RTCSessionDescription consists of a description type indicating which part of the offer/answer negotiation process it describes and of the SDP descriptor of the session."><code>RTCSessionDescription</code></a> 是很多浏览器中使用的名称。强烈建议使用补充库，例如强大并且被广泛支持的<a href="https://github.com/webrtcHacks/adapter" rel="noopener">Adapter.js</a>，以确保您网站或Web应用程序的兼容性。值得注意的是<a href="https://github.com/webrtcHacks/adapter" rel="noopener">Adapter.js</a>不仅仅提供这些，它还做了一些其他补充以增强WebRTC在浏览器中的兼容性。参考：</p>

<pre>var PeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
var SessionDescription = window.RTCSessionDescription || window.mozRTCSessionDescription || window.webkitRTCSessionDescription;
var GET_USER_MEDIA = navigator.getUserMedia ? &quot;getUserMedia&quot; :
                     navigator.mozGetUserMedia ? &quot;mozGetUserMedia&quot; :
                     navigator.webkitGetUserMedia ? &quot;webkitGetUserMedia&quot; : &quot;getUserMedia&quot;;
var v = document.createElement(&quot;video&quot;);
var SRC_OBJECT = &apos;srcObject&apos; in v ? &quot;srcObject&quot; :
                 &apos;mozSrcObject&apos; in v ? &quot;mozSrcObject&quot; :
                 &apos;webkitSrcObject&apos; in v ? &quot;webkitSrcObject&quot; : &quot;srcObject&quot;;</pre>
</div>

<p>由于RTCPeerConnection实现了 <a href="/zh-CN/docs/Web/API/EventTarget" title="EventTarget是一个由可以接收事件的对象实现的接口，并且可以为它们创建侦听器。"><code>EventTarget</code></a> 接口，故其可以接收处理事件。</p>

<h3 id="构造函数"><strong>构造函数</strong></h3>

<dl>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/RTCPeerConnection" title="RTCPeerConnection()构造函数，返回一个新建的  RTCPeerConnection实例，它代表了本地端机器与远端机器的一条连接。"><code>RTCPeerConnection.RTCPeerConnection()</code></a></dt>
 <dd>构造函数;创建一个新的RTCPeerConnection对象。</dd>
</dl>

<h3 id="属性"><strong>属性</strong> </h3>

<p><em>该接口的属性继承了其父接口, <a href="/zh-CN/docs/Web/API/EventTarget" title="EventTarget是一个由可以接收事件的对象实现的接口，并且可以为它们创建侦听器。"><code>EventTarget</code></a>.</em></p>

<dl>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/canTrickleIceCandidates" title="RTCPeerConnection"><code>RTCPeerConnection.canTrickleIceCandidates</code></a> <span class="readOnly readOnlyInline notecard inline" title="该属性的值无法更改">只读 </span></dt>
 <dd><code>如果远端支持UDP打洞或支持通过中继服务器连接，则该属性值为true。否则，为false。该属性的值依赖于远端设置且仅在本地的</code> <a href="/zh-CN/docs/Web/API/RTCPeerConnection/setRemoteDescription" title="RTCPeerConnection.setRemoteDescription() 方法改变与连接相关的描述，该描述主要是描述有些关于连接的属性，例如对端使用的解码器。 连接受此更改影响，并且必须能够支持旧的和新的描述。 方法带三个参数，RTCSessionDescription 对象用于设置，然后是更改成功的回调方法，一个是更改失败的回调方法。"><code>RTCPeerConnection.setRemoteDescription()</code></a>方法被调用时有效，如果该方法没被调用，则其值为null.</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/connectionState" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.connectionState</code></a> <span class="readOnly readOnlyInline notecard inline" title="该属性的值无法更改">只读 </span></dt>
 <dd>只读connectionState属性通过返回由枚举RTCPeerConnectionState指定的字符串值之一来指示对等连接的当前状态。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/currentLocalDescription" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.currentLocalDescription</code></a> <span class="readOnly readOnlyInline notecard inline" title="该属性的值无法更改">只读 </span></dt>
 <dd>只读属性RTCPeerConnection.currentLocalDescription返回一个描述连接本地端的RTCSessionDescription对象，因为自上次RTCPeerConnection完成协商并连接到远程对等体之后，它最近成功协商。 还包括可能已经由ICE代理生成的任何ICE候选者的列表，因为首先被描述的描述所表示的要约或答案。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/currentRemoteDescription" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.currentRemoteDescription</code></a> <span class="readOnly readOnlyInline notecard inline" title="该属性的值无法更改">只读 </span></dt>
 <dd>只读属性RTCPeerConnection.currentRemoteDescription返回一个RTCSessionDescription对象，描述连接的远程端，因为最近一次RTCPeerConnection完成协商并连接到远程对等体后最近成功协商。 还包括可能已经由ICE代理生成的任何ICE候选者的列表，因为首先被描述的描述所表示的要约或答案。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/defaultIceServers" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.defaultIceServers</code></a> <span class="readOnly readOnlyInline notecard inline" title="该属性的值无法更改">只读 </span></dt>
 <dd>只读属性RTCPeerConnection.defaultIceServers根据RTCIceServer字典返回一个对象数组，该字典指示如果在RTCConfiguration中没有提供给RTCPeerConnection的默认情况下，浏览器将使用ICE服务器。 然而，浏览器根本不需要提供任何默认的ICE服务器。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/iceConnectionState" title="RTCPeerConnection.iceConnectionState 是一个只读属性，用于描述连接的ICE连接状态，返回值为枚举类型。"><code>RTCPeerConnection.iceConnectionState</code></a> <span class="readOnly readOnlyInline notecard inline" title="该属性的值无法更改">只读 </span></dt>
 <dd>只读属性RTCPeerConnection.iceConnectionState返回与RTCPeerConnection关联的ICE代理的状态类型为RTCIceConnectionState的枚举。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/iceGatheringState" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.iceGatheringState</code></a> <span class="readOnly readOnlyInline notecard inline" title="该属性的值无法更改">只读 </span></dt>
 <dd>只读属性，返回一个RTCIceGatheringState类型的结构体，它描述了连接的ICE收集状态</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/idpLoginUrl" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.idpLoginUrl</code></a> <span class="readOnly readOnlyInline notecard inline" title="该属性的值无法更改">只读 </span></dt>
 <dd>blah</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/localDescription" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.localDescription</code></a> <span class="readOnly readOnlyInline notecard inline" title="该属性的值无法更改">只读 </span></dt>
 <dd>只读属性，返回一个 <a href="/zh-CN/docs/Web/API/RTCSessionDescription" title="RTCSessionDescription 接口描述连接或潜在连接的一端的配置方式。 每一个RTCSessionDescription 由一个描述类型组成，该描述类型指示它所描述的请求/应答协商过程的SDP 协议的相关描述。"><code>RTCSessionDescription</code></a> ，它描述了这条连接的本地端的会话控制（用户会话所需的属性以及配置信息）。如果本地的会话控制还没有被设置，它的值就会是null。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/peerIdentity" title="只读属性 RTCPeerConnection  peerIdentity ，返回Promise 对象，成功时返回 RTCIdentityAssertion ，该结构 DOMString 标识了远端的ID。这个身份标识在连接过程中将不会改变（直到连接结束）"><code>RTCPeerConnection.peerIdentity</code></a> <span class="readOnly readOnlyInline notecard inline" title="该属性的值无法更改">只读 </span></dt>
 <dd>只读属性，返回一个<code>RTCIdentityAssertion,它由一组信息构成，包括一个域名（idp）以及一个名称（name），它们代表了这条连接的远端机器的身份识别信息。如果远端机器还没有被设置以及校验，这个属性会返回一个null值。一旦被设置，它不能被一般方法改变。</code></dd>
</dl>

<p><a href="/zh-CN/docs/Web/API/RTCPeerConnection/pendingLocalDescription" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.pendingLocalDescription</code></a> <span class="readOnly readOnlyInline notecard inline" title="该属性的值无法更改">只读 </span></p>

<dl>
 <dd>blah</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/pendingRemoteDescription" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.pendingRemoteDescription</code></a> <span class="readOnly readOnlyInline notecard inline" title="该属性的值无法更改">只读 </span></dt>
 <dd>blah</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/remoteDescription" title="只读属性 RTCPeerConnection.remoteDescription 返回一个 RTCSessionDescription ，它描述了和远程对端之间的会话(包括配置和媒体信息) ，如果还没有被设置过的话，它会是 null."><code>RTCPeerConnection.remoteDescription</code></a> <span class="readOnly readOnlyInline notecard inline" title="该属性的值无法更改">只读 </span></dt>
 <dd>blah</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/sctp" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.sctp</code></a> <span class="readOnly readOnlyInline notecard inline" title="该属性的值无法更改">只读 </span></dt>
 <dd>blah</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/signalingState" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.signalingState</code></a> <span class="readOnly readOnlyInline notecard inline" title="该属性的值无法更改">只读 </span></dt>
</dl>

<p>返回一个RTC通信状态的结构体，这个结构体描述了本地连接的通信状态。这个 状态描述了一个定义连接配置的SDP offer。它包含了下列信息，与<a href="/zh-CN/docs/Web/API/MediaStream" title="MediaStream 接口是一个媒体内容的流.。一个流包含几个轨道，比如视频和音频轨道。"><code>MediaStream</code></a> 类型本地相关的对象的描述，媒体流编码方式或RTP和  RTCP协议的选项 ，以及被ICE服务器收集到的candidates(连接候选者)。当<a href="/zh-CN/docs/Web/API/RTCPeerConnection/signalingState" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.signalingState</code></a>的值改变时，对象上的<code><a href="/zh-CN/docs/Web/Reference/Events/signalingstatechange" title="/zh-CN/docs/Web/Reference/Events/signalingstatechange">signalingstatechange</a></code>事件会被触发。</p>

<h3 id="基本用法"><strong>基本用法</strong></h3>

<p>一个基本的RTCPeerConnection使用需要协调本地机器以及远端机器的连接，它可以通过在两台机器间生成Session Description的数据交换协议来实现。呼叫方发送一个offer(请求)，被呼叫方发出一个answer（应答）来回答请求。双方-呼叫方以及被呼叫方，最开始的时候都要建立他们各自的RTCPeerConnection对象。</p>

<pre>var pc = new RTCPeerConnection();
pc.onaddstream = function(obj) {
  var vid = document.createElement(&quot;video&quot;);
  document.appendChild(vid);
  vid.srcObject = obj.stream;
}

// Helper functions
function endCall() {
  var videos = document.getElementsByTagName(&quot;video&quot;);
  for (var i = 0; i &lt; videos.length; i++) {
    videos[i].pause();
  }

  pc.<a href="#close()">close</a>();
}

function error(err) { endCall(); }</pre>

<dl>
 <dt>呼叫初始化</dt>
</dl>

<p>如果你是呼叫方，你需要初始化一个连接</p>

<pre>// Get a list of friends from a server
// User selects a friend to start a peer connection with
navigator.getUserMedia({video: true}, function(stream) {
  pc.onaddstream({stream: stream});
  // Adding a local stream won&apos;t trigger the onaddstream callback
  pc.<a href="#addStream()">addStream</a>(stream);

  pc.<a href="#createOffer()">createOffer</a>(function(offer) {
    pc.<a href="#setLocalDescription()">setLocalDescription</a>(new <span class="nx">RTCSessionDescription</span>(offer), function() {
      // send the offer to a server to be forwarded to the friend you&apos;re calling.
    }, error);
  }, error);
})</pre>

<dl>
 <dt>呼叫回答</dt>
</dl>

<p>在另一端，你的朋友会从服务器收到offer信息。</p>

<pre>var offer = getOfferFromFriend();
navigator.getUserMedia({video: true}, function(stream) {
  pc.onaddstream({stream: stream});
  pc.<a href="#addStream()">addStream</a>(stream);

  pc.setRemoteDescription(new <span class="nx">RTCSessionDescription</span>(offer), function() {
    pc.<a href="#createAnswer()">createAnswer</a>(function(answer) {
      pc.<a href="#setLocalDescription()">setLocalDescription</a>(new <span class="nx">RTCSessionDescription</span>(answer), function() {
        // <span style="font-size: 1rem;">send the answer to a server to be forwarded back to the caller (you)</span>
      }, error);
    }, error);
  }, error);
})

</pre>

<dl>
 <dt>处理应答</dt>
</dl>

<p>同时在呼叫发起方，你会收到这个应答（前面被呼叫方发出的answer），你需要将它设置为你的远端连接。</p>

<pre>// pc was set up earlier when we made the original offer
var offer = getResponseFromFriend();
pc.<a href="#createAnswer()">setRemoteDescription</a>(new <span class="nx">RTCSessionDescription</span>(offer), function() { }, error);
</pre>

<h2 id="属性_2"><span class="short_text" id="result_box" lang="zh-CN"><span>属性</span></span></h2>

<p><em>这个接口从它的父元素中继承属性, <a href="/zh-CN/docs/Web/API/EventTarget" title="EventTarget是一个由可以接收事件的对象实现的接口，并且可以为它们创建侦听器。"><code>EventTarget</code></a>.</em></p>

<dl>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/iceConnectionState" title="RTCPeerConnection.iceConnectionState 是一个只读属性，用于描述连接的ICE连接状态，返回值为枚举类型。"><code>RTCPeerConnection.iceConnectionState</code></a> <span class="readOnly readOnlyInline notecard inline" title="该属性的值无法更改">只读 </span></dt>
 <dd>返回一个RTCIceConnectionState类型的结构体，这个结构体描述了连接的ICE连接状态。当这个状态的值改变时，这个对象会触发一个<code><a href="/zh-CN/docs/Web/Reference/Events/iceconnectionstatechange" title="/zh-CN/docs/Web/Reference/Events/iceconnectionstatechange">iceconnectionstatechange</a></code> 事件。状态可能存在的值如下：</dd>
 <dd>
 <ul>
  <li>&quot;new&quot;: ICE服务器正在收集地址或正在等待远端的candidates(这两种情况可能同时存在)。</li>
  <li><code>&quot;checking&quot;</code>: ICE服务器找到了远端的candidates（连接候选者）,这些candidates至少有一个，同时ICE服务器在检测这些candidates，尽管它可能还没有找到连接。此刻，ICE服务器可能仍在收集candidates（连接候选者）。</li>
  <li><code>&quot;connected&quot;</code>: ICE服务器已经找到了一条可用的适合所有组件的连接，但它仍然在测试更多的远端candidate以提供更好的连接。同时，ICE服务器可能仍在收集candidates。</li>
  <li><code>&quot;completed&quot;</code>: ICE服务器已经找到了一条可用的连接，并不再测试远端candidates。</li>
  <li><code>&quot;failed&quot;</code>: ICE服务器已经检测了所有的远端candidates，但并没有找到可用的。对一些组件适用的连接可能已经被找到。</li>
  <li><code>&quot;disconnected&quot;</code>: 至少一个组件的活跃度检查失败了，这可能是由糟糕的网络环境造成的一个短期状态，它可以被它自身所修复。</li>
  <li><code>&quot;closed&quot;</code>: ICE服务器已经关闭，并不再响应请求。</li>
 </ul>
 </dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/iceGatheringState" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.iceGatheringState</code></a> <span class="readOnly readOnlyInline notecard inline" title="该属性的值无法更改">只读 </span></dt>
 <dd>返回一个iceGatheringState类型的结构体，它描述了这条连接的ICE收集状态。该状态可能取以下的值：
 <ul>
  <li><code>&quot;new&quot;</code>: 对象刚刚被创建,还没有网络化。</li>
  <li><code>&quot;gathering&quot;</code>: ICE引擎正在为连接收集candidates(连接候选者)。</li>
  <li><code>&quot;complete&quot;</code>: 引擎已经完成了candidates收集。但像添加一个新的接口或者一个新的turn服务器这些事件会导致状态回到&quot;gathering&quot;。</li>
 </ul>
 </dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/localDescription" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.localDescription</code></a> <span class="readOnly readOnlyInline notecard inline" title="该属性的值无法更改">只读 </span></dt>
 <dd>返回一个 <a href="/zh-CN/docs/Web/API/RTCSessionDescription" title="RTCSessionDescription 接口描述连接或潜在连接的一端的配置方式。 每一个RTCSessionDescription 由一个描述类型组成，该描述类型指示它所描述的请求/应答协商过程的SDP 协议的相关描述。"><code>RTCSessionDescription</code></a> ，它描述了这条连接的本地端的会话控制（用户会话所需的属性以及配置信息）。如果本地的会话控制还没有被设置，它的值就会是null。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/peerIdentity" title="只读属性 RTCPeerConnection  peerIdentity ，返回Promise 对象，成功时返回 RTCIdentityAssertion ，该结构 DOMString 标识了远端的ID。这个身份标识在连接过程中将不会改变（直到连接结束）"><code>RTCPeerConnection.peerIdentity</code></a> <span class="readOnly readOnlyInline notecard inline" title="该属性的值无法更改">只读 </span></dt>
 <dd>返回一个<code>RTCIdentityAssertion,它由一组信息构成，包括一个域名（idp）以及一个名称（name），它们代表了这条连接的远端机器的身份识别信息。如果远端机器还没有被设置以及校验，这个属性会返回一个null值。一旦被设置，它不能被一般方法改变。</code></dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/remoteDescription" title="只读属性 RTCPeerConnection.remoteDescription 返回一个 RTCSessionDescription ，它描述了和远程对端之间的会话(包括配置和媒体信息) ，如果还没有被设置过的话，它会是 null."><code>RTCPeerConnection.remoteDescription</code></a> <span class="readOnly readOnlyInline notecard inline" title="该属性的值无法更改">只读 </span></dt>
 <dd>返回一个 <a href="/zh-CN/docs/Web/API/RTCSessionDescription" title="RTCSessionDescription 接口描述连接或潜在连接的一端的配置方式。 每一个RTCSessionDescription 由一个描述类型组成，该描述类型指示它所描述的请求/应答协商过程的SDP 协议的相关描述。"><code>RTCSessionDescription</code></a> 它描述了这条连接的远端机器的会话控制，如果远端机器还未被设置，它的值会是null。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/signalingState" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.signalingState</code></a> <span class="readOnly readOnlyInline notecard inline" title="该属性的值无法更改">只读 </span></dt>
 <dd>返回一个RTC通信状态的结构体，这个结构体描述了本地连接的通信状态。这个 状态描述了一个定义连接配置的SDP offer。它包含了下列信息，与<a href="/zh-CN/docs/Web/API/MediaStream" title="MediaStream 接口是一个媒体内容的流.。一个流包含几个轨道，比如视频和音频轨道。"><code>MediaStream</code></a> 类型本地相关的对象的描述，媒体流编码方式或RTP和  RTCP协议的选项 ，以及被ICE服务器收集到的candidates(连接候选者)。当<a href="/zh-CN/docs/Web/API/RTCPeerConnection/signalingState" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.signalingState</code></a>的值改变时，对象上的<code><a href="/zh-CN/docs/Web/Reference/Events/signalingstatechange" title="/zh-CN/docs/Web/Reference/Events/signalingstatechange">signalingstatechange</a></code>事件会被触发。 它可能取下列的值：
 <ul>
  <li><code>&quot;stable&quot;</code>: 没有SDP offer/answer正在被交换，连接仍然处于初始化状态。</li>
  <li><code>&quot;have-local-offer&quot;</code>: 这条连接的本地端机器已经本地应用了一个SDP offer。</li>
  <li><code>&quot;have-remote-offer&quot;</code>: 这条连接的远端机器已经本地应用了一个SDP offer。</li>
  <li><code>&quot;have-local-pranswer&quot;</code>: 一个来自远端的SDP offer已经被应用，同时一个SDP pranswer在本地被应用。</li>
  <li><code>&quot;have-remote-pranswer&quot;:</code> 一个本地的SDP offer被应用，同时一个SDP pranswer在远端被应用。</li>
  <li><code>&quot;closed&quot;</code>: 连接被关闭。</li>
 </ul>
 </dd>
</dl>

<h3 id="事件处理器">事件处理器</h3>

<dl>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/onaddstream" title="当类型为MediaStreamEvent的addstream 事件发生时，通过RTCPeerConnection触发RTCPeerConnection.onaddstream 事件处理函数。当远程媒体流MediaStream 添加到连接后发送事件。当RTCPeerConnection.setRemoteDescription() 后此事件立即被调用而不需要等待SDP交换完成。"><code>RTCPeerConnection.onaddstream</code></a></dt>
 <dd>是收到<code><a href="/zh-CN/docs/Web/Reference/Events/addstream" title="/zh-CN/docs/Web/Reference/Events/addstream">addstream</a></code> 事件时调用的事件处理器。 Such an event is 当<a href="/zh-CN/docs/Web/API/MediaStream" title="MediaStream 接口是一个媒体内容的流.。一个流包含几个轨道，比如视频和音频轨道。"><code>MediaStream</code></a> 被远端机器添加到这条连接时，该事件会被触发。 当调用<a href="/zh-CN/docs/Web/API/RTCPeerConnection/setRemoteDescription" title="RTCPeerConnection.setRemoteDescription() 方法改变与连接相关的描述，该描述主要是描述有些关于连接的属性，例如对端使用的解码器。 连接受此更改影响，并且必须能够支持旧的和新的描述。 方法带三个参数，RTCSessionDescription 对象用于设置，然后是更改成功的回调方法，一个是更改失败的回调方法。"><code>RTCPeerConnection.setRemoteDescription()</code></a>方法时，这个事件就会被立即触发，它不会等待SDP协商的结果。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/ondatachannel" title="RTCPeerConnection.ondatachannel 属性是一个EventHandler，当这个datachannel事件在RTCPeerConnection发生时，它指定的那个事件处理函数就会被调用。这个事件继承于 RTCDataChannelEvent，当远方伙伴调用createDataChannel()时这个事件被加到这个连接（RTCPeerConnection）中。"><code>RTCPeerConnection.ondatachannel</code></a></dt>
 <dd>是收到<code><a href="/zh-CN/docs/Web/Reference/Events/datachannel" title="/zh-CN/docs/Web/Reference/Events/datachannel">datachannel</a></code> 事件时调用的事件处理器。 当一个 <a href="/zh-CN/docs/Web/API/RTCDataChannel" title="RTCDataChannel接口代表在两者之间建立了一个双向数据通道的连接。"><code>RTCDataChannel</code></a> 被添加到连接时，这个事件被触发。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/onicecandidate" title=" RTCPeerConnection 的属性 onicecandidate （是一个事件触发器 EventHandler） 能够让函数在事件icecandidate发生在实例  RTCPeerConnection 上时被调用。 只要本地代理ICE 需要通过信令服务器传递信息给其他对等端时就会触发。"><code>RTCPeerConnection.onicecandidate</code></a></dt>
 <dd>是收到 <code><a href="/zh-CN/docs/Web/Reference/Events/icecandidate" title="/zh-CN/docs/Web/Reference/Events/icecandidate">icecandidate</a></code> 事件时调用的事件处理器.。当一个 <a href="/zh-CN/docs/Web/API/RTCICECandidate" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCICECandidate</code></a> 对象被添加时，这个事件被触发。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/oniceconnectionstatechange" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.oniceconnectionstatechange</code></a></dt>
 <dd>是收到<code><a href="/zh-CN/docs/Web/Reference/Events/iceconnectionstatechange" title="/zh-CN/docs/Web/Reference/Events/iceconnectionstatechange">iceconnectionstatechange</a></code>事件时调用的事件处理器 。 当<a href="/zh-CN/docs/Web/API/RTCPeerConnection/iceConnectionState" title="RTCPeerConnection.iceConnectionState 是一个只读属性，用于描述连接的ICE连接状态，返回值为枚举类型。"><code>iceConnectionState</code></a> 改变时，这个事件被触发。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/onidentityresult" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.onidentityresult</code></a></dt>
 <dd>是收到 <code><a href="/zh-CN/docs/Web/Reference/Events/identityresult" title="/zh-CN/docs/Web/Reference/Events/identityresult">identityresult</a></code>事件时调用的事件处理器。 当通过<a href="/zh-CN/docs/Web/API/RTCPeerConnection/getIdentityAssertion" title="此页面仍未被本地化, 期待您的翻译!"><code>getIdentityAssertion()</code></a>生成身份断言, 或在生成一个answer或一个offer的过程中，这个事件被触发。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/onidpassertionerror" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.onidpassertionerror</code></a></dt>
 <dd>是收到 <code><a href="/zh-CN/docs/Web/Reference/Events/idpassertionerror" title="/zh-CN/docs/Web/Reference/Events/idpassertionerror">idpassertionerror</a></code> 事件时调用的事件处理器。当生成一个身份断言时，如果关联的身份提供者（idP）遇到一个错误，这个事件就会被触发。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/onidpvalidationerror" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.onidpvalidationerror</code></a></dt>
 <dd>是收到 <code><a href="/zh-CN/docs/Web/Reference/Events/idpvalidationerror" title="/zh-CN/docs/Web/Reference/Events/idpvalidationerror">idpvalidationerror</a></code> 事件时调用的事件处理器。当检查 一个身份断言时，如果关联的身份提供者（idP）遇到一个错误，这个事件就会被触发。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/onnegotiationneeded" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.onnegotiationneeded</code></a></dt>
 <dd>是收到<code><a href="/zh-CN/docs/Web/Reference/Events/negotiationneeded" title="/zh-CN/docs/Web/Reference/Events/negotiationneeded">negotiationneeded</a></code> 事件时调用的事件处理器， 浏览器发送该事件以告知在将来某一时刻需要协商。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/onpeeridentity" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.onpeeridentity</code></a></dt>
 <dd>是收到<code><a href="/zh-CN/docs/Web/Reference/Events/peeridentity" title="/zh-CN/docs/Web/Reference/Events/peeridentity">peeridentity</a></code> 事件时调用的事件处理器, 当一条连接的peer identify被设置以及校验后，该事件被触发</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/onremovestream" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.onremovestream</code></a></dt>
 <dd>是收到<code><a href="/zh-CN/docs/Web/Reference/Events/removestream" title="/zh-CN/docs/Web/Reference/Events/removestream">removestream</a></code> 事件时调用的事件处理器，当一条<a href="/zh-CN/docs/Web/API/MediaStream" title="MediaStream 接口是一个媒体内容的流.。一个流包含几个轨道，比如视频和音频轨道。"><code>MediaStream</code></a> 从连接上移除时，该事件被触发。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/onsignalingstatechange" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.onsignalingstatechange</code></a></dt>
 <dd>是收到<code><a href="/zh-CN/docs/Web/Reference/Events/signalingstatechange" title="/zh-CN/docs/Web/Reference/Events/signalingstatechange">signalingstatechange</a></code> 事件时调用的事件处理器, 当<a href="/zh-CN/docs/Web/API/RTCPeerConnection/signalingState" title="此页面仍未被本地化, 期待您的翻译!"><code>signalingState</code></a>的值发生改变时，该事件被触发。</dd>
</dl>

<h2 id="方法">方法</h2>

<dl>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/RTCPeerConnection" title="RTCPeerConnection()构造函数，返回一个新建的  RTCPeerConnection实例，它代表了本地端机器与远端机器的一条连接。"><code>RTCPeerConnection()</code></a></dt>
 <dd>RTCPeerConnection的初始化函数，通过 new RTCPeerConnection()初始化一个RTCPeerConnection实例。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/createOffer" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.createOffer()</code></a></dt>
 <dd>生成一个offer，它是一个带有特定的配置信息寻找远端匹配机器（peer）的请求。这个方法的前两个参数分别是方法调用成功以及失败的回调函数，可选的第三个参数是用户对视频流以及音频流的定制选项（一个对象）。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/createAnswer" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.createAnswer()</code></a></dt>
 <dd>在协调一条连接中的两端offer/answers时，根据从远端发来的offer生成一个answer。这个方法的前两个参数分别是方法调用成功以及失败时的回调函数，可选的第三个参数是生成的answer的可供选项。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/setLocalDescription" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.setLocalDescription()</code></a></dt>
 <dd>改变与连接相关的本地描述。这个描述定义了连接的属性，例如：连接的编码方式。连接会受到它的改变的影响，而且连接必须能同时支持新的以及旧的描述。这个方法可以接收三个参数，一个<a href="/zh-CN/docs/Web/API/RTCSessionDescription" title="RTCSessionDescription 接口描述连接或潜在连接的一端的配置方式。 每一个RTCSessionDescription 由一个描述类型组成，该描述类型指示它所描述的请求/应答协商过程的SDP 协议的相关描述。"><code>RTCSessionDescription</code></a> 对象包含设置信息，还有两个回调函数，它们分别是方法调用成功以及失败的回调函数。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/setRemoteDescription" title="RTCPeerConnection.setRemoteDescription() 方法改变与连接相关的描述，该描述主要是描述有些关于连接的属性，例如对端使用的解码器。 连接受此更改影响，并且必须能够支持旧的和新的描述。 方法带三个参数，RTCSessionDescription 对象用于设置，然后是更改成功的回调方法，一个是更改失败的回调方法。"><code>RTCPeerConnection.setRemoteDescription()</code></a></dt>
 <dd>改变与连接相关的远端描述。这个描述定义了连接的属性，例如：连接的编码方式。连接会受到它的改变的影响，而且连接必须能同时支持新的以及旧的描述。这个方法可以接收三个参数，一个<a href="/zh-CN/docs/Web/API/RTCSessionDescription" title="RTCSessionDescription 接口描述连接或潜在连接的一端的配置方式。 每一个RTCSessionDescription 由一个描述类型组成，该描述类型指示它所描述的请求/应答协商过程的SDP 协议的相关描述。"><code>RTCSessionDescription</code></a> 对象包含设置信息，还有两个回调函数，它们分别是方法调用成功以及失败的回调函数。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/updateIce" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.updateIce()</code></a></dt>
 <dd>更新ICE服务器时调用的方法。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/addIceCandidate" title="当本机当前页面的 RTCPeerConnection 接收到一个从远端页面通过信号通道发来的新的 ICE 候选地址信息，本机可以通过调用RTCPeerConnection.addIceCandidate() 来添加一个 ICE 代理。"><code>RTCPeerConnection.addIceCandidate()</code></a></dt>
 <dd>添加iceCandidate时调用的方法。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/getConfiguration" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.getConfiguration()</code></a></dt>
 <dd>获取配置信息时调用的方法。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/getLocalStreams" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.getLocalStreams()</code></a></dt>
 <dd>返回连接的本地媒体流数组。这个数组可能是空数组。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/getRemoteStreams" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.getRemoteStreams()</code></a></dt>
 <dd>返回连接的远端媒体流数组。这个数组可能是空数组。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/getStreamById" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.getStreamById()</code></a></dt>
 <dd>返回连接中与所给id匹配的媒体流 <a href="/zh-CN/docs/Web/API/MediaStream" title="MediaStream 接口是一个媒体内容的流.。一个流包含几个轨道，比如视频和音频轨道。"><code>MediaStream</code></a>，如果没有匹配项，返回null。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/addStream" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.addStream()</code></a></dt>
 <dd>添加一个媒体流 <a href="/zh-CN/docs/Web/API/MediaStream" title="MediaStream 接口是一个媒体内容的流.。一个流包含几个轨道，比如视频和音频轨道。"><code>MediaStream</code></a>作为本地音频或视频源。如果本地端与远端协调已经发生了，那么需要一个新的媒体流，这样远端才可以使用它。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/removeStream" title="RTCPeerConnection.removeStream() 方法用来移除本地音频或视频的 媒体流 。 如果已经发生交互，远程主机可能需要使用一个新的媒体流。"><code>RTCPeerConnection.removeStream()</code></a></dt>
 <dd>将一个作为本地音频或视频源的媒体流 <a href="/zh-CN/docs/Web/API/MediaStream" title="MediaStream 接口是一个媒体内容的流.。一个流包含几个轨道，比如视频和音频轨道。"><code>MediaStream</code></a>移除。如果本地端与远端协调已经发生了，那么需要一个新的媒体流，这样远端才可以停止使用它。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/close" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.close()</code></a></dt>
 <dd>关闭一个RTCPeerConnection实例所调用的方法。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/createDataChannel" title="RTCPeerConnection 的 createDataChannel() 方法创建一个可以发送任意数据的数据通道(data channel)。常用于后台传输内容, 例如: 图像, 文件传输, 聊天文字, 游戏数据更新包, 等等。"><code>RTCPeerConnection.createDataChannel()</code></a></dt>
 <dd>在一条连接上建立一个新的<a href="/zh-CN/docs/Web/API/RTCDataChannel" title="RTCDataChannel接口代表在两者之间建立了一个双向数据通道的连接。"><code>RTCDataChannel</code></a>（用于数据发送）。这个方法把一个数据对象作为参数，数据对象中包含必要的配置信息。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/createDTMFSender" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.createDTMFSender()</code></a></dt>
 <dd>创建一个新的与特殊的<a href="/zh-CN/docs/Web/API/MediaStreamTrack" title="MediaStreamTrack接口在User Agent中表示一段媒体源，比如音轨或视频。"><code>MediaStreamTrack</code></a>相关的<a href="/zh-CN/docs/Web/API/RTCDTMFSender" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCDTMFSender</code></a>，可以在连接上发送<a class="glossaryLink" href="/en-US/docs/Glossary/DTMF" title="DTMF: Dual-Tone Multi-Frequency (DTMF) signaling is a system by which audible tones are used to represent buttons being pressed on a keypad. Frequently referred to in the United States as &quot;touch tone&quot; (after the Touch-Tone trademark used when the transition from pulse dialing to DTMF began), DTMF makes it possible to signal the digits 0-9 as well as the letters &quot;A&quot; through &quot;D&quot; and the symbols &quot;#&quot; and &quot;*&quot;. Few telephone keypads include the letters, which are typically used for control signaling by the telephone network.">DTMF</a>手机信号。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/getStats" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.getStats()</code></a></dt>
 <dd>生成一个新的<a href="/zh-CN/docs/Web/API/RTCStatsReport" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCStatsReport</code></a>，它包含连接相关的统计信息。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/setIdentityProvider" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.setIdentityProvider()</code></a></dt>
 <dd>根据所给的三个参数设置身份提供者（IdP)，这三个参数是它的名称，通信所使用的协议（可选），以及一个可选的用户名。只有当一个断言被需要时，这个IdP才会被使用。</dd>
 <dt><a href="/zh-CN/docs/Web/API/RTCPeerConnection/getIdentityAssertion" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnection.getIdentityAssertion()</code></a></dt>
 <dd>初始化身份断言的收集，只有当<a href="/zh-CN/docs/Web/API/RTCPeerConnection/signalingState" title="此页面仍未被本地化, 期待您的翻译!"><code>signalingState</code></a>的值不为&quot;closed&quot;时，它才有效。它自动完成，在需求发生前调用它是最好的选择。</dd>
</dl>

<h3 id="构造函数_2">构造函数</h3>

<pre>new RTCPeerConnection(<a href="/zh-CN/docs/Web/API/RTCConfiguration" title="The RTCConfiguration dictionary is used to provide configuration options for an RTCPeerConnection. It may be passed into the constructor when instantiating a connection, or used with the RTCPeerConnection.getConfiguration() and RTCPeerConnection.setConfiguration() methods, which allow inspecting and changing the configuration while a connection is established."><code>RTCConfiguration</code></a> configuration, optional <a href="/zh-CN/docs/Web/API/MediaConstraints" title="此页面仍未被本地化, 期待您的翻译!"><code>MediaConstraints</code></a> constraints);</pre>

<div class="note">
<p><strong>注意:</strong> PeerConnection需要传递一个RTCConfiguration对象作为参数，如果你没有传递参数的话，火狐浏览器会自动提供一个参数。</p>
</div>

<h2 id="方法_2">方法</h2>

<h3 id="createOffer">createOffer</h3>

<p><code>void createOffer(<a href="/zh-CN/docs/Web/API/RTCSessionDescriptionCallback" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCSessionDescriptionCallback</code></a> successCallback, <a href="/zh-CN/docs/Web/API/RTCPeerConnectionErrorCallback" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnectionErrorCallback</code></a> failureCallback, optional <a href="/zh-CN/docs/Web/API/MediaConstraints" title="此页面仍未被本地化, 期待您的翻译!"><code>MediaConstraints</code></a> constraints);</code></p>

<p>createOffer方法会生成描述信息的一个blob对象，它会帮助连接到本地机器。当你已经找到一个远端的PeerConnection并且打算设置建立本地的PeerConnection时，你可以使用该方法。</p>

<h4 id="举例">举例</h4>

<pre class="prettyprint">var pc = new PeerConnection();
pc.addStream(video);
pc.createOffer(function(desc){
  pc.setLocalDescription(desc, function() {
    // send the offer to a server that can negotiate with a remote client
  });
}</pre>

<h4 id="参数">参数</h4>

<dl>
 <dt>successCallback（方法调用成功时的回调函数）</dt>
 <dd>一个 <a href="/zh-CN/docs/Web/API/RTCSessionDescriptionCallback" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCSessionDescriptionCallback</code></a> 它会收到一个 <a href="/zh-CN/docs/Web/API/RTCSessionDescription" title="RTCSessionDescription 接口描述连接或潜在连接的一端的配置方式。 每一个RTCSessionDescription 由一个描述类型组成，该描述类型指示它所描述的请求/应答协商过程的SDP 协议的相关描述。"><code>RTCSessionDescription</code></a> 对象作为参数。</dd>
 <dt>errorCallback（方法调用失败时的回调函数）</dt>
 <dd>一个 <a href="/zh-CN/docs/Web/API/RTCPeerConnectionErrorCallback" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnectionErrorCallback</code></a> 它会收到一个 <a href="/zh-CN/docs/Web/API/DOMError" title="DOMError 接口描述一个错误对象,该对象包含一个错误的名字。"><code>DOMError</code></a> 对象作为参数。</dd>
 <dt>[optional] constraints(可选的约束条件)</dt>
 <dd>一个可选的<a href="/zh-CN/docs/Web/API/MediaConstraints" title="此页面仍未被本地化, 期待您的翻译!"><code>MediaConstraints</code></a> 对象。</dd>
</dl>

<h3 id="createAnswer">createAnswer</h3>

<p><code>void createAnswer(<a href="/zh-CN/docs/Web/API/RTCSessionDescriptionCallback" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCSessionDescriptionCallback</code></a> successCallback, <a href="/zh-CN/docs/Web/API/RTCPeerConnectionErrorCallback" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnectionErrorCallback</code></a> failureCallback, optional <a href="/zh-CN/docs/Web/API/MediaConstraints" title="此页面仍未被本地化, 期待您的翻译!"><code>MediaConstraints</code></a> constraints)&quot;)</code></p>

<p>对从远方收到的offer进行回答。</p>

<h4 id="举例_2">举例</h4>

<pre class="line">var pc = new PeerConnection();
pc.setRemoteDescription(new RTCSessionDescription(offer), function() {
  pc.createAnswer(function(answer) {
    pc.setLocalDescription(answer, function() {
      // send the answer to the remote connection
    })
  })
});</pre>

<h4 id="参数_2">参数</h4>

<dl>
 <dt>successCallback（方法调用成功时的回调函数）</dt>
 <dd>一个 <a href="/zh-CN/docs/Web/API/RTCSessionDescriptionCallback" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCSessionDescriptionCallback</code></a> 它会收到一个 <a href="/zh-CN/docs/Web/API/RTCSessionDescription" title="RTCSessionDescription 接口描述连接或潜在连接的一端的配置方式。 每一个RTCSessionDescription 由一个描述类型组成，该描述类型指示它所描述的请求/应答协商过程的SDP 协议的相关描述。"><code>RTCSessionDescription</code></a> 对象作为参数。</dd>
 <dt>errorCallback（方法调用失败时的回调函数）</dt>
 <dd>一个 <a href="/zh-CN/docs/Web/API/RTCPeerConnectionErrorCallback" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnectionErrorCallback</code></a> 它会收到一个<a href="/zh-CN/docs/Web/API/DOMError" title="DOMError 接口描述一个错误对象,该对象包含一个错误的名字。"><code>DOMError</code></a> 对象作为参数。</dd>
 <dt>[optional] constraints（可选的约束条件）</dt>
</dl>

<p>      一个可选的<a href="/zh-CN/docs/Web/API/MediaConstraints" title="此页面仍未被本地化, 期待您的翻译!"><code>MediaConstraints</code></a> 对象。</p>

<h3 id="updateIce">updateIce()</h3>

<p>updateIce(optional <a href="/zh-CN/docs/Web/API/RTCConfiguration" title="The RTCConfiguration dictionary is used to provide configuration options for an RTCPeerConnection. It may be passed into the constructor when instantiating a connection, or used with the RTCPeerConnection.getConfiguration() and RTCPeerConnection.setConfiguration() methods, which allow inspecting and changing the configuration while a connection is established."><code>RTCConfiguration</code></a> configuration, optional <a href="/zh-CN/docs/Web/API/MediaConstraints" title="此页面仍未被本地化, 期待您的翻译!"><code>MediaConstraints</code></a> constraints)</p>

<p>该方法会更新ICE代理收集本地candidates以及连接云端candidates的进程。如果强制约束条件&quot;IceTransports&quot;存在，那么它会控制ICE代理的工作方式。它可以用于限制接听者对TURN candidates的使用，这样可以避免在请求被应答前泄露位置信息。如果这个方法影响了已经建立的连接，那么它可能导致ICE代理状态的改变以及媒体状态的改变。</p>

<h4 id="举例_3">举例</h4>

<pre></pre>

<h3 id="addIceCandidate">addIceCandidate()</h3>

<p>addIceCandidate (<a href="/zh-CN/docs/Web/API/RTCIceCandidate" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCIceCandidate</code></a> candidate, <a href="/zh-CN/docs/Web/API/Function" title="此页面仍未被本地化, 期待您的翻译!"><code>Function</code></a> successCallback, <a href="/zh-CN/docs/Web/API/RTCPeerConnectionErrorCallback" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCPeerConnectionErrorCallback</code></a> failureCallback);</p>

<p>除了被添加到远端描述之外，只要约束条件&quot;IceTransports&quot; 没有被设置为null，连接检测结果会被发送给新的candidates。如果这个方法影响了已经建立的连接，那么它可能导致ICE代理状态的改变以及媒体状态的改变。</p>

<h4 id="举例_4">举例</h4>

<pre>  pc.addIceCandidate(new RTCIceCandidate(candidate));
</pre>

<h3 id="createDataChannel">createDataChannel</h3>

<p><code><a href="/zh-CN/docs/Web/API/RTCDataChannel" title="RTCDataChannel接口代表在两者之间建立了一个双向数据通道的连接。"><code>RTCDataChannel</code></a> createDataChannel (<a href="/zh-CN/docs/Web/API/DOMString" title="DOMString 是一个UTF-16字符串。由于JavaScript已经使用了这样的字符串，所以DOMString 直接映射到 一个String。"><code>DOMString</code></a> label, optional <a href="/zh-CN/docs/Web/API/RTCDataChannelInit" title="此页面仍未被本地化, 期待您的翻译!"><code>RTCDataChannelInit</code></a> dataChannelDict);</code></p>

<p>通过peerconnection建立一条数据信道，用于发送非视频音频信息。</p>

<h4 id="例子">例子</h4>

<pre>var pc = new PeerConnection();
var channel = pc.createDataChannel(&quot;Mydata&quot;);
channel.onopen = function(event) {
  <code>channel.send(&apos;sending a message&apos;);</code>
}
channel.onmessage = function(event) { console.log(event.data); }</pre>

<h2 id="引申阅读">引申阅读</h2>

<ul>
 <li><a href="https://github.com/jesup/nightly-gupshup/blob/master/static/js/chat.js">https://github.com/jesup/nightly-gupshup/blob/master/static/js/chat.js</a></li>
 <li><a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-simple">http://www.html5rocks.com/en/tutorials/webrtc/basics/#toc-simple</a></li>
 <li><a href="http://dev.w3.org/2011/webrtc/editor/webrtc.html">http://dev.w3.org/2011/webrtc/editor/webrtc.html</a></li>
</ul>

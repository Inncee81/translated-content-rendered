---
title: Map
slug: Web/JavaScript/Reference/Global_Objects/Map
tags:
  - ECMAScript6
  - JavaScript
  - Map
translation_of: Web/JavaScript/Reference/Global_Objects/Map
---
<div>
<div><section class="Quick_links" id="Quick_Links"><ol><li><strong><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects">JavaScript 标准库</a></strong></li><li><strong><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map"><code>Map</code></a></strong></li><li data-default-state="open"><a href="#"><strong>属性</strong></a><ol><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/size"><code>Map.prototype.size</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/@@toStringTag"><code>Map.prototype[@@toStringTag]</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/@@species"><code>get Map[@@species]</code></a></li></ol></li><li data-default-state="open"><a href="#"><strong>方法</strong></a><ol><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/clear"><code>Map.prototype.clear()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/delete"><code>Map.prototype.delete()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/entries"><code>Map.prototype.entries()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach"><code>Map.prototype.forEach()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/get"><code>Map.prototype.get()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/has"><code>Map.prototype.has()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/keys"><code>Map.prototype.keys()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/set"><code>Map.prototype.set()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/values"><code>Map.prototype.values()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator"><code>Map.prototype[@@iterator]()</code></a></li></ol></li><li><strong>继承</strong></li><li><strong><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function"><code>Function</code></a></strong></li><li><a href="#"><strong>属性</strong></a><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments"><code>Function.arguments</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/caller"><code>Function.caller</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/displayName"><code>Function.displayName</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/length"><code>Function.length</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/name"><code>Function.name</code></a></li></ol></li><li><a href="#"><strong>方法</strong></a><ol><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"><code>Function.prototype.apply()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"><code>Function.prototype.bind()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call"><code>Function.prototype.call()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="This is an obsolete API and is no longer guaranteed to work."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/toSource"><code>Function.prototype.toSource()</code></a></s></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/toString"><code>Function.prototype.toString()</code></a></li></ol></li><li><strong><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object"><code>Object</code></a></strong></li><li><a href="#"><strong>属性</strong></a><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"><code>Object.prototype.__proto__</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor"><code>Object.prototype.constructor</code></a></li></ol></li><li><a href="#"><strong>方法</strong></a><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__"><code>Object.prototype.__defineGetter__()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineSetter__"><code>Object.prototype.__defineSetter__()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupGetter__"><code>Object.prototype.__lookupGetter__()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupSetter__"><code>Object.prototype.__lookupSetter__()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty"><code>Object.prototype.hasOwnProperty()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf"><code>Object.prototype.isPrototypeOf()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable"><code>Object.prototype.propertyIsEnumerable()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString"><code>Object.prototype.toLocaleString()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="This is an obsolete API and is no longer guaranteed to work."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toSource"><code>Object.prototype.toSource()</code></a></s></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString"><code>Object.prototype.toString()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf"><code>Object.prototype.valueOf()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"><code>Object.setPrototypeOf()</code></a></li></ol></li></ol></section></div>
</div>

<p><strong><code>Map</code></strong> 对象保存键值对，并且能够记住键的原始插入顺序。任何值(对象或者<a href="/zh-CN/docs/Glossary/Primitive">原始值</a>) 都可以作为一个键或一个值。</p>

<dl>
</dl>

<h2 id="描述">描述</h2>

<p>一个Map对象在迭代时会根据对象中元素的插入顺序来进行 — 一个  <a href="/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of"><code>for...of</code></a> 循环在每次迭代后会返回一个形式为[key，value]的数组。</p>

<h3 id="键的相等Key_equality">键的相等(Key equality)</h3>

<ul>
 <li>键的比较是基于 <code><a href="/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness#零值相等">sameValueZero</a></code> 算法：</li>
 <li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN"><code>NaN</code></a> 是与 <code>NaN</code> 相等的（虽然 <code>NaN !== NaN</code>），剩下所有其它的值是根据 <code>===</code> 运算符的结果判断是否相等。</li>
 <li>在目前的ECMAScript规范中，<code>-0</code>和<code>+0</code>被认为是相等的，尽管这在早期的草案中并不是这样。有关详细信息，请参阅<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map#浏览器兼容性">浏览器兼容性</a> 表中的“Value equality for -0 and 0”。</li>
</ul>

<h3 id="Objects_和_maps_的比较">Objects 和 maps 的比较</h3>

<p><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object"><code>Objects</code></a> 和 <code>Maps</code> 类似的是，它们都允许你按键存取一个值、删除键、检测一个键是否绑定了值。因此（并且也没有其他内建的替代方式了）过去我们一直都把对象当成 <code>Maps</code> 使用。不过 <code>Maps</code> 和 <code>Objects</code> 有一些重要的区别，在下列情况里使用 <code>Map</code> 会是更好的选择：</p>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="row"></th>
   <th scope="col">Map</th>
   <th scope="col">Object</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <th scope="row">意外的键</th>
   <td><code>Map</code> 默认情况不包含任何键。只包含显式插入的键。</td>
   <td>
    <p>一个 <code>Object</code> 有一个原型, 原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</p>

    <div class="note notecard">
    <p><strong>注意:</strong> 虽然 ES5 开始可以用 <code>Object.create(null)</code> 来创建一个没有原型的对象，但是这种用法不太常见。</p>
    </div>
   </td>
  </tr>
  <tr>
   <th scope="row">键的类型</th>
   <td>一个 <code>Map</code>的键可以是<strong>任意值</strong>，包括函数、对象或任意基本类型。</td>
   <td>一个<code>Object</code> 的键必须是一个 <a href="/zh-CN/docs/Web/JavaScript/Reference/String"><code>String</code></a> 或是<a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol"><code>Symbol</code></a>。</td>
  </tr>
  <tr>
   <th scope="row">键的顺序</th>
   <td>
    <p><code>Map</code> 中的 key 是有序的。因此，当迭代的时候，一个 <code>Map</code> 对象以插入的顺序返回键值。</p>
   </td>
   <td>
    <p>一个 <code>Object</code> 的键是无序的</p>

    <div class="note notecard">
    <p>注意：自ECMAScript 2015规范以来，对象<em>确实</em>保留了字符串和Symbol键的创建顺序； 因此，在只有字符串键的对象上进行迭代将按插入顺序产生键。</p>
    </div>
   </td>
  </tr>
  <tr>
   <th scope="row">Size</th>
   <td> <code>Map</code> 的键值对个数可以轻易地通过<a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/size"><code>size</code></a> 属性获取</td>
   <td><code>Object</code> 的键值对个数只能手动计算</td>
  </tr>
  <tr>
   <th scope="row">迭代</th>
   <td><code>Map</code> 是 <a href="/en-US/docs/Web/JavaScript/Guide/iterable">iterable</a> 的，所以可以直接被迭代。</td>
   <td>迭代一个<code>Object</code>需要以某种方式获取它的键然后才能迭代。</td>
  </tr>
  <tr>
   <th scope="row">性能</th>
   <td>
    <p>在频繁增删键值对的场景下表现更好。</p>
   </td>
   <td>
    <p>在频繁添加和删除键值对的场景下未作出优化。</p>
   </td>
  </tr>
 </tbody>
</table>

<h2 id="构造函数">构造函数</h2>

<dl>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/Map"><code>Map()</code></a></dt>
 <dd>创建 <code>Map</code> 对象</dd>
</dl>

<h2 id="属性">属性</h2>

<dl>
 <dt><code>Map.length</code></dt>
 <dd>属性 length 的值为 0 。<br>
 想要计算一个<code>Map</code> 中的条目数量， 使用 <a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/size"><code>Map.prototype.size</code></a>.</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/@@species"><code>get Map[@@species]</code></a></dt>
 <dd>本构造函数用于创建派生对象。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/prototype"><code>Map.prototype</code></a></dt>
 <dd>表示 <code>Map</code> 构造器的原型。 允许添加属性从而应用于所有的 <code>Map</code> 对象。</dd>
</dl>

<h2 id="Map_实例"><code>Map</code> 实例</h2>

<p><font face="Open Sans, Arial, sans-serif">所有的 </font><code>Map</code> 对象实例都会继承 <a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/prototype"><code>Map.prototype</code></a>。</p>

<h3 id="属性_2">属性</h3>

<dl>
 <dt><code>Map.prototype.constructor</code></dt>
 <dd>返回一个函数，它创建了实例的原型。默认是<a href="/zh-CN/docs/Web/JavaScript/Reference/Map" title="此页面仍未被本地化, 期待您的翻译!"><code>Map</code></a>函数。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/size" title="size 是可访问属性，用于返回 一个Map 对象的成员数量。"><code>Map.prototype.size</code></a></dt>
 <dd>返回Map对象的键/值对的数量。</dd>
</dl>

<h3 id="方法">方法</h3>

<dl>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/clear" title="clear()方法会移除Map对象中的所有元素。"><code>Map.prototype.clear()</code></a></dt>
 <dd>移除Map对象的所有键/值对 。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/delete" title=" delete() 方法用于移除 Map 对象中指定的元素。"><code>Map.prototype.delete(key)</code></a></dt>
 <dd>如果 <code>Map</code> 对象中存在该元素，则移除它并返回<em> <code>true</code></em>；否则如果该元素不存在则返回 <code><em>false</em></code>。随后调用 <code>Map.prototype.has(key)</code> 将返回 <code>false</code> 。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/entries" title="entries() 方法返回一个新的包含 [key, value] 对的 Iterator 对象，返回的迭代器的迭代顺序与 Map 对象的插入顺序相同。"><code>Map.prototype.entries()</code></a></dt>
 <dd>返回一个新的 <code>Iterator</code> 对象，它按插入顺序包含了Map对象中每个元素的 <strong><code>[key, value]</code></strong> <code><strong>数组</strong></code>。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach" title="forEach() 方法将会以插入顺序对 Map 对象中的每一个键值对执行一次参数中提供的回调函数。"><code>Map.prototype.forEach(callbackFn[, thisArg])</code></a></dt>
 <dd>按插入顺序，为 <code>Map</code>对象里的每一键值对调用一次callbackFn函数。如果为forEach提供了thisArg，它将在每次回调中作为this值。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/get" title="get() 方法返回某个 Map 对象中的一个指定元素。"><code>Map.prototype.get(key)</code></a></dt>
 <dd>返回键对应的值，如果不存在，则返回undefined。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/has" title="方法has() 返回一个bool值，用来表明map 中是否存在指定元素."><code>Map.prototype.has(key)</code></a></dt>
 <dd>返回一个布尔值，表示Map实例是否包含键对应的值。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/keys" title="keys() 返回一个新的 Iterator 对象。它包含按照顺序插入 Map 对象中每个元素的key值。"><code>Map.prototype.keys()</code></a></dt>
 <dd>返回一个新的 <code>Iterator</code>对象， 它按插入顺序包含了Map对象中每个元素的<strong>键 </strong>。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/set" title="set() 方法为 Map 对象添加或更新一个指定了键（key）和值（value）的（新）键值对。"><code>Map.prototype.set(key, value)</code></a></dt>
 <dd>设置Map对象中键的值。返回该Map对象。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/values" title="一个新的 Map 可迭代对象."><code>Map.prototype.values()</code></a></dt>
 <dd>返回一个新的<code>Iterator</code>对象，它按插入顺序包含了Map对象中每个元素的<strong>值</strong> 。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/@@iterator" title="@@iterator 属性的初始值与 entries 属性的初始值是同一个函数对象。"><code>Map.prototype[@@iterator]()</code></a></dt>
 <dd>返回一个新的<code>Iterator</code>对象，它按插入顺序包含了Map对象中每个元素的 <strong><code>[key, value]</code></strong> <code><strong>数组</strong></code>。</dd>
</dl>

<h2 id="示例">示例</h2>

<h3 id="使用_Map_对象">使用 <code>Map</code> 对象</h3>

<pre class="brush: js notranslate">let myMap = new Map();

let keyObj = {};
let keyFunc = function() {};
let keyString = &apos;a string&apos;;

// 添加键
myMap.set(keyString, &quot;和键&apos;a string&apos;关联的值&quot;);
myMap.set(keyObj, &quot;和键keyObj关联的值&quot;);
myMap.set(keyFunc, &quot;和键keyFunc关联的值&quot;);

myMap.size; // 3

// 读取值
myMap.get(keyString);    // &quot;和键&apos;a string&apos;关联的值&quot;
myMap.get(keyObj);       // &quot;和键keyObj关联的值&quot;
myMap.get(keyFunc);      // &quot;和键keyFunc关联的值&quot;

myMap.get(&apos;a string&apos;);   // &quot;和键&apos;a string&apos;关联的值&quot;
                         // 因为keyString === &apos;a string&apos;
myMap.get({});           // undefined, 因为keyObj !== {}
myMap.get(function() {}); // undefined, 因为keyFunc !== function () {}</pre>

<h3 id="将_NaN_作为_Map_的键">将 <code>NaN</code> 作为 <code>Map</code> 的键</h3>

<p><code>NaN</code> 也可以作为<code>Map</code>对象的键。虽然 <code>NaN</code> 和任何值甚至和自己都不相等(<code>NaN !== NaN</code> 返回true)，但下面的例子表明，<code>NaN</code>作为Map的键来说是没有<span><span>区别的</span></span>:</p>

<pre class="brush: js notranslate">let myMap = new Map();
myMap.set(NaN, &quot;not a number&quot;);

myMap.get(NaN); // &quot;not a number&quot;

let otherNaN = Number(&quot;foo&quot;);
myMap.get(otherNaN); // &quot;not a number&quot;
</pre>

<h3 id="使用_for..of_方法迭代_Map">使用 <code>for..of</code> 方法迭代 <code>Map</code></h3>

<p><code>Map</code>可以使用<code>for..of</code>循环来实现迭代：</p>

<pre class="brush: js notranslate">let myMap = new Map();
myMap.set(0, &quot;zero&quot;);
myMap.set(1, &quot;one&quot;);
for (let [key, value] of myMap) {
  console.log(key + &quot; = &quot; + value);
}
// 将会显示两个log。一个是&quot;0 = zero&quot;另一个是&quot;1 = one&quot;

for (let key of myMap.keys()) {
  console.log(key);
}
// 将会显示两个log。 一个是 &quot;0&quot; 另一个是 &quot;1&quot;

for (let value of myMap.values()) {
  console.log(value);
}
// 将会显示两个log。 一个是 &quot;zero&quot; 另一个是 &quot;one&quot;

for (let [key, value] of myMap.entries()) {
  console.log(key + &quot; = &quot; + value);
}
// 将会显示两个log。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;</pre>

<h3 id="使用_forEach_方法迭代_Map">使用 <code>forEach()</code> 方法迭代 <code>Map</code></h3>

<p><code>Map</code>也可以通过<code>forEach()</code>方法迭代：</p>

<pre class="brush: js notranslate">myMap.forEach(function(value, key) {
  console.log(key + &quot; = &quot; + value);
})
// 将会显示两个logs。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;
</pre>

<h3 id="Map_与数组的关系"><code>Map</code> 与数组的关系</h3>

<pre class="brush: js notranslate">let kvArray = [[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]];

// 使用常规的Map构造函数可以将一个二维键值对数组转换成一个Map对象
let myMap = new Map(kvArray);

myMap.get(&quot;key1&quot;); // 返回值为 &quot;value1&quot;

// 使用Array.from函数可以将一个Map对象转换成一个二维键值对数组
console.log(Array.from(myMap)); // 输出和kvArray相同的数组

// 更简洁的方法来做如上同样的事情，使用展开运算符
console.log([...myMap]);

// 或者在键或者值的迭代器上使用Array.from，进而得到只含有键或者值的数组
console.log(Array.from(myMap.keys())); // 输出 [&quot;key1&quot;, &quot;key2&quot;]
</pre>

<h3 id="复制或合并_Maps">复制或合并 <code>Maps</code></h3>

<p>Map 能像数组一样被复制：</p>

<pre class="brush: js notranslate">let original = new Map([
  [1, &apos;one&apos;]
]);

let clone = new Map(original);

console.log(clone.get(1)); // one
console.log(original === clone); // false. 浅比较 不为同一个对象的引用
</pre>

<div class="note notecard">
<p>重要：请记住，<em>数据本身</em>未被克隆。</p>
</div>

<p>Map对象间可以进行合并，但是会保持键的唯一性。</p>

<pre class="brush: js notranslate">let first = new Map([
  [1, &apos;one&apos;],
  [2, &apos;two&apos;],
  [3, &apos;three&apos;],
]);

let second = new Map([
  [1, &apos;uno&apos;],
  [2, &apos;dos&apos;]
]);

// 合并两个Map对象时，如果有重复的键值，则后面的会覆盖前面的。
// 展开运算符本质上是将Map对象转换成数组。
let merged = new Map([...first, ...second]);

console.log(merged.get(1)); // uno
console.log(merged.get(2)); // dos
console.log(merged.get(3)); // three</pre>

<p>Map对象也能与数组合并：</p>

<pre class="brush: js notranslate">let first = new Map([
  [1, &apos;one&apos;],
  [2, &apos;two&apos;],
  [3, &apos;three&apos;],
]);

let second = new Map([
  [1, &apos;uno&apos;],
  [2, &apos;dos&apos;]
]);

// Map对象同数组进行合并时，如果有重复的键值，则后面的会覆盖前面的。
let merged = new Map([...first, ...second, [1, &apos;eins&apos;]]);

console.log(merged.get(1)); // eins
console.log(merged.get(2)); // dos
console.log(merged.get(3)); // three</pre>

<h2 id="使用说明">使用说明</h2>

<p>请注意！为Map设置对象属性也是可以的，但是可能引起大量的混乱。</p>

<p>所以，你还是<em>可以这样做.</em>..</p>

<pre class="syntaxbox example-bad brush js notranslate">let wrongMap = new Map()
wrongMap[&apos;bla&apos;] = &apos;blaa&apos;
wrongMap[&apos;bla2&apos;] = &apos;blaaa2&apos;

console.log(wrongMap)  // Map { bla: &apos;blaa&apos;, bla2: &apos;blaaa2&apos; }
</pre>

<p>...但是，这样做的话，它的行为会不符合预期:</p>

<pre class="syntaxbox example-bad brush js notranslate">wrongMap.has(&apos;bla&apos;)    // false
wrongMap.delete(&apos;bla&apos;) // false
console.log(wrongMap)  // Map { bla: &apos;blaa&apos;, bla2: &apos;blaaa2&apos; }</pre>

<p>无论如何，和正确用法比较起来，几乎没有什么不同: </p>

<pre class="syntaxbox brush js example-good notranslate">let myMap = new Map()
myMap.set(&apos;bla&apos;,&apos;blaa&apos;)
myMap.set(&apos;bla2&apos;,&apos;blaa2&apos;)
console.log(myMap)  // Map { &apos;bla&apos; =&gt; &apos;blaa&apos;, &apos;bla2&apos; =&gt; &apos;blaa2&apos; }

myMap.has(&apos;bla&apos;)    // true
myMap.delete(&apos;bla&apos;) // true
console.log(myMap)  // Map { &apos;bla2&apos; =&gt; &apos;blaa2&apos; }</pre>

<h2 id="规范">规范</h2>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col">Specification</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><a class="external" href="https://tc39.es/ecma262/#sec-map-objects" hreflang="en" lang="en">ECMAScript (ECMA-262)<br><small lang="zh-CN">Map</small></a></td>
  </tr>
 </tbody>
</table>

<h2 id="浏览器兼容性">浏览器兼容性</h2>

<div class="hidden">
<p>The compatibility table on this page is generated from structured data. If you&apos;d like to contribute to the data, please check out <a href="https://github.com/mdn/browser-compat-data">https://github.com/mdn/browser-compat-data</a> and send us a pull request.</p>
</div>

<div class="bc-data" id="bcd:javascript.builtins.Map"></div>

<h2 id="相关链接">相关链接</h2>

<ul>
 <li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set"><code>Set</code></a></li>
 <li><a href="/zh-CN/docs/Web/JavaScript/Reference/WeakMap"><code>WeakMap</code></a></li>
 <li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/WeakSet"><code>WeakSet</code></a></li>
</ul>

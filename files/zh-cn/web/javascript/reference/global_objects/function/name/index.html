---
title: Function.name
slug: Web/JavaScript/Reference/Global_Objects/Function/name
tags:
  - ECMAScript 2015
  - Function
  - JavaScript
  - Property
translation_of: Web/JavaScript/Reference/Global_Objects/Function/name
---
<div><section class="Quick_links" id="Quick_Links"><ol><li><strong><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects">JavaScript 标准库</a></strong></li><li><strong><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function"><code>Function</code></a></strong></li><li data-default-state="open"><a href="#"><strong>属性</strong></a><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments"><code>Function.arguments</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/caller"><code>Function.caller</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/displayName"><code>Function.displayName</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/length"><code>Function.length</code></a></li><li><em><code>Function.name</code></em></li></ol></li><li data-default-state="open"><a href="#"><strong>方法</strong></a><ol><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"><code>Function.prototype.apply()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"><code>Function.prototype.bind()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call"><code>Function.prototype.call()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="This is an obsolete API and is no longer guaranteed to work."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/toSource"><code>Function.prototype.toSource()</code></a></s></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/toString"><code>Function.prototype.toString()</code></a></li></ol></li><li><strong>继承</strong></li><li><strong><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object"><code>Object</code></a></strong></li><li><a href="#"><strong>属性</strong></a><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"><code>Object.prototype.__proto__</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor"><code>Object.prototype.constructor</code></a></li></ol></li><li><a href="#"><strong>方法</strong></a><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__"><code>Object.prototype.__defineGetter__()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineSetter__"><code>Object.prototype.__defineSetter__()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupGetter__"><code>Object.prototype.__lookupGetter__()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupSetter__"><code>Object.prototype.__lookupSetter__()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty"><code>Object.prototype.hasOwnProperty()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf"><code>Object.prototype.isPrototypeOf()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable"><code>Object.prototype.propertyIsEnumerable()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString"><code>Object.prototype.toLocaleString()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="This is an obsolete API and is no longer guaranteed to work."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toSource"><code>Object.prototype.toSource()</code></a></s></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString"><code>Object.prototype.toString()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf"><code>Object.prototype.valueOf()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"><code>Object.setPrototypeOf()</code></a></li></ol></li></ol></section></div>

<div><code><strong><em>function</em>.name</strong></code> 属性返回函数实例的名称。</div>

<table class="standard-table">
  <thead>
    <tr>
      <th class="header" colspan="2"><code>Function.name</code> 属性的属性特性：</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>writable</td>
      <td>false</td>
    </tr>
    <tr>
      <td>enumerable</td>
      <td>false</td>
    </tr>
    <tr>
      <td>configurable</td>
      <td>true</td>
    </tr>
  </tbody>
</table>

<div class="note notecard">
<p>请注意，在非标准的ES2015之前的实现中，<code>configurable</code>属性也是<code>false</code> 。</p>
</div>

<h2 id="示例">示例</h2>

<h3 id="函数声明的名称">函数声明的名称</h3>

<p> <code>name</code> 属性返回一个函数声明的名称。</p>

<pre class="brush:js notranslate">function doSomething() { }
doSomething.name;  // &quot;doSomething&quot;
</pre>

<h3 id="构造函数的名称">构造函数的名称</h3>

<p>使用<code>new Function(...)</code>语法创建的函数或只是 <code>Function(...) create</code> <a href="/zh-CN/docs/Web/JavaScript/Reference/Function"><code>Function</code></a>对象及其名称为“anonymous”。</p>

<pre class="brush: js notranslate">(new Function).name; // &quot;anonymous&quot;</pre>

<h3 id="推断函数名称">推断函数名称</h3>

<p>变量和方法可以从句法位置推断匿名函数的名称（ECMAScript 2015中新增）。</p>

<pre class="brush: js notranslate">var f = function() {};
var object = {
  someMethod: function() {}
};

console.log(f.name); // &quot;f&quot;
console.log(object.someMethod.name); // &quot;someMethod&quot;</pre>

<p style="color: rgb(77, 78, 83);">你可以在 <a href="/zh-CN/docs/Web/JavaScript/Reference/Operators/Function">函数表达式</a>中定义函数的名称:</p>

<pre class="brush:js notranslate">var object = {
  someMethod: function object_someMethod() {}
};

console.log(object.someMethod.name); // &quot;object_someMethod&quot;

try { object_someMethod } catch(e) { alert(e); }
// ReferenceError: object_someMethod is not defined
</pre>

<p>你不能更改函数的名称，此属性是只读的：</p>

<div class="hidden">
<p>Example below contradicts with what is said at the beginning of this section and doesn&apos;t work as described.</p>
</div>

<pre class="brush: js notranslate">var object = {
  // anonymous
  someMethod: function() {}
};

object.someMethod.name = &apos;otherMethod&apos;;
console.log(object.someMethod.name); // someMethod</pre>

<p>要更改它，可以使用<a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty()</code></a>。</p>

<h3 id="简写方法的名称">简写方法的名称</h3>

<pre class="brush: js notranslate">var o = {
  foo(){}
};
o.foo.name; // &quot;foo&quot;;</pre>

<h3 id="绑定函数的名称">绑定函数的名称</h3>

<p><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"><code>Function.bind()</code></a> 所创建的函数将会在函数的名称前加上&quot;bound &quot; 。</p>

<pre class="brush: js notranslate">function foo() {};
foo.bind({}).name; // &quot;bound foo&quot;</pre>

<h3 id="getters_和_setters_的函数名">getters 和 setters 的函数名</h3>

<p>当通过 <code><a href="/zh-CN/docs/Web/JavaScript/Reference/Functions/get">get</a></code> 和 <code><a href="/zh-CN/docs/Web/JavaScript/Reference/Functions/set">set</a></code> 访问器来存取属性时, &quot;get&quot; 或 &quot;set&quot; 会出现在函数名称前。</p>

<pre class="brush: js notranslate">var o = {
  get foo(){},
  set foo(x){}
};

var descriptor = Object.getOwnPropertyDescriptor(o, &quot;foo&quot;);
descriptor.get.name; // &quot;get foo&quot;
descriptor.set.name; // &quot;set foo&quot;;</pre>

<h3 id="类中的函数名称">类中的函数名称</h3>

<p>你可以使用<code>obj.constructor.name</code>来检查对象的“类”（但请务必阅读以下警告）：</p>

<pre class="brush: js notranslate">function Foo() {}  // ES2015 Syntax: class Foo {}

var fooInstance = new Foo();
console.log(fooInstance.constructor.name); // logs &quot;Foo&quot;</pre>

<div class="warning notecard">
<p><strong>警告：</strong>脚本解释器只有在函数没有名为name的属性时才会设置内置的<code>Function.name</code>属性（参见 <a href="https://www.ecma-international.org/ecma-262/6.0/#sec-setfunctionname">9.2.11 of the ECMAScript2015 Language Specification</a>）。但是，ES2015规定由关键字<em>static</em>修饰的静态方法也会被认为是类的属性（ECMAScript2015, <a href="https://www.ecma-international.org/ecma-262/6.0/#sec-runtime-semantics-classdefinitionevaluation">14.5.14.21.b</a> + <a href="https://www.ecma-international.org/ecma-262/6.0/#sec-object-initializer-runtime-semantics-propertydefinitionevaluation">12.2.6.9</a>）。</p>
</div>

<p>因此，我们无法获取具有静态方法属性<code>name()</code>的几乎任何类的类名称：</p>

<pre class="brush: js notranslate">class Foo {
  constructor() {}
  static name() {}
}
</pre>

<p>使用<code>static name()</code>方法<code>Foo.name</code>不再保存实际的类名称，而是引用<code>name()</code>函数对象。 ES2015语法中的上述类定义将在Chrome或Firefox中运行，类似于ES5语法中的以下代码段：</p>

<pre class="brush: js notranslate">function Foo() {}
Object.defineProperty(Foo, &apos;name&apos;, { writable: true });
Foo.name = function() {};
</pre>

<p>通过<code>fooInstance.constructor.name</code>获取<code>fooInstance</code>类不会给我们所有的类名，而是静态类方法的引用。 例如：</p>

<pre class="brush: js notranslate">var fooInstance = new Foo();
console.log(fooInstance.constructor.name); // logs function name()</pre>

<p>你也可以从ES5语法示例中看到，在Chrome或Firefox的中静态定义的<code>Foo.name</code>变得可写。内置定义在没有自定义静态定义时是只读的：</p>

<pre class="brush: js notranslate">Foo.name = &apos;Hello&apos;;
console.log(Foo.name);
//如果Foo具有静态name()属性，则输出“Hello”，否则为“Foo”
</pre>

<p>因此，你不能依赖内置的<code>Function.name</code>属性来保持一个类的名称。</p>

<h3 id="Symbol作为函数名称">Symbol作为函数名称</h3>

<p>如果<a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol"><code>Symbol</code></a> 被用于函数名称，并且这个symbol具有相应的描述符，那么方法的名字就是方括号中的描述符。</p>

<pre class="brush: js notranslate">var sym1 = Symbol(&quot;foo&quot;);
var sym2 = Symbol();
var o = {
  [sym1]: function(){},
  [sym2]: function(){}
};

o[sym1].name; // &quot;[foo]&quot;
o[sym2].name; // &quot;&quot;
</pre>

<h2 id="JavaScript_压缩和_minifiers">JavaScript 压缩和 minifiers</h2>

<div class="warning notecard">
<p><strong>警告：</strong>当使用<code>Function.name</code>和那些JavaScript压缩器（minifiers）或混淆器进行源码转换时要小心。这些工具通常用作JavaScript构建管道的一部分，以在程序部署到生产之前减少程序的大小。但这种转换通常会在构建时更改函数的名称。</p>
</div>

<p>例如下面的代码:</p>

<pre class="brush: js notranslate">function Foo() {};
var foo = new Foo();

if (foo.constructor.name === &apos;Foo&apos;) {
  console.log(&quot;&apos;foo&apos; is an instance of &apos;Foo&apos;&quot;);
} else {
  console.log(&apos;Oops!&apos;);
}</pre>

<p>可能被压缩为:</p>

<pre class="brush: js notranslate">function a() {};
var b = new a();
if (b.constructor.name === &apos;Foo&apos;) {
  console.log(&quot;&apos;foo&apos; is an instance of &apos;Foo&apos;&quot;);
} else {
  console.log(&apos;Oops!&apos;);
}
</pre>

<p>在未压缩版本中，程序运行到真实分支并打印<code>&apos;foo&apos; is an instance of &apos;Foo&apos;</code>。 而在压缩版本中，它的行为不同，并且进入else分支。如果您依赖于<code>Function.name</code>，就像上面的示例一样，确保您的构建管道不会更改函数名称，也不要假定函数具有特定的名称。</p>

<article>
<h2 id="规范">规范</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Specification</th>
   <th scope="col">Status</th>
   <th scope="col">Comment</th>
  </tr>
  <tr>
   <td><a class="external" href="https://www.ecma-international.org/ecma-262/6.0/#sec-name" hreflang="en" lang="en">ECMAScript 2015 (6th Edition, ECMA-262)<br><small lang="zh-CN">name</small></a></td>
   <td><span class="spec-Standard">Standard</span></td>
   <td>Initial definition.</td>
  </tr>
  <tr>
   <td><a class="external" href="https://tc39.es/ecma262/#sec-name" hreflang="en" lang="en">ECMAScript (ECMA-262)<br><small lang="zh-CN">name</small></a></td>
   <td><span class="spec-Living">Living Standard</span></td>
   <td> </td>
  </tr>
 </tbody>
</table>

<h2 id="浏览器兼容性">浏览器兼容性</h2>

<div class="hidden">The compatibility table on this page is generated from structured data. If you&apos;d like to contribute to the data, please check out <a href="https://github.com/mdn/browser-compat-data">https://github.com/mdn/browser-compat-data</a> and send us a pull request.</div>

<div class="bc-data" id="bcd:javascript.builtins.Function.name"></div>
</article>

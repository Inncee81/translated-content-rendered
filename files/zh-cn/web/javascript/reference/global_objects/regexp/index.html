---
title: RegExp
slug: Web/JavaScript/Reference/Global_Objects/RegExp
tags:
  - Class
  - JavaScript
  - Reference
  - RegExp
  - Regular Expressions
translation_of: Web/JavaScript/Reference/Global_Objects/RegExp
---
<div><section class="Quick_links" id="Quick_Links"><ol><li><strong><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects">JavaScript 标准库</a></strong></li><li><strong><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp"><code>RegExp</code></a></strong></li><li data-default-state="open"><a href="#"><strong>属性</strong></a><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/n"><code>RegExp.$1-$9</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/input"><code>RegExp.input ($_)</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastMatch"><code>RegExp.lastMatch ($&amp;)</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastParen"><code>RegExp.lastParen ($+)</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/leftContext"><code>RegExp.leftContext ($`)</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/dotAll"><code>RegExp.prototype.dotAll</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/flags"><code>RegExp.prototype.flags</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/global"><code>RegExp.prototype.global</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/ignoreCase"><code>RegExp.prototype.ignoreCase</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/multiline"><code>RegExp.prototype.multiline</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/source"><code>RegExp.prototype.source</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky"><code>RegExp.prototype.sticky</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/unicode"><code>RegExp.prototype.unicode</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/rightContext"><code>RegExp.rightContext ($&apos;)</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex"><code>RegExp.lastIndex</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@species"><code>get RegExp[@@species]</code></a></li></ol></li><li data-default-state="open"><a href="#"><strong>方法</strong></a><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/compile"><code>RegExp.prototype.compile()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec"><code>RegExp.prototype.exec()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test"><code>RegExp.prototype.test()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="This is an obsolete API and is no longer guaranteed to work."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/toSource"><code>RegExp.prototype.toSource()</code></a></s></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/toString"><code>RegExp.prototype.toString()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@matchAll"><code>RegExp.prototype[@@matchAll]()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@match"><code>RegExp.prototype[@@match]()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@replace"><code>RegExp.prototype[@@replace]()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@search"><code>RegExp.prototype[@@search]()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@split"><code>RegExp.prototype[@@split]()</code></a></li></ol></li><li><strong>继承</strong></li><li><strong><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function"><code>Function</code></a></strong></li><li><a href="#"><strong>属性</strong></a><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments"><code>Function.arguments</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/caller"><code>Function.caller</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/displayName"><code>Function.displayName</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/length"><code>Function.length</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/name"><code>Function.name</code></a></li></ol></li><li><a href="#"><strong>方法</strong></a><ol><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"><code>Function.prototype.apply()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"><code>Function.prototype.bind()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call"><code>Function.prototype.call()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="This is an obsolete API and is no longer guaranteed to work."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/toSource"><code>Function.prototype.toSource()</code></a></s></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/toString"><code>Function.prototype.toString()</code></a></li></ol></li><li><strong><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object"><code>Object</code></a></strong></li><li><a href="#"><strong>属性</strong></a><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"><code>Object.prototype.__proto__</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor"><code>Object.prototype.constructor</code></a></li></ol></li><li><a href="#"><strong>方法</strong></a><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__"><code>Object.prototype.__defineGetter__()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineSetter__"><code>Object.prototype.__defineSetter__()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupGetter__"><code>Object.prototype.__lookupGetter__()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupSetter__"><code>Object.prototype.__lookupSetter__()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty"><code>Object.prototype.hasOwnProperty()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf"><code>Object.prototype.isPrototypeOf()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable"><code>Object.prototype.propertyIsEnumerable()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString"><code>Object.prototype.toLocaleString()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="This is an obsolete API and is no longer guaranteed to work."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toSource"><code>Object.prototype.toSource()</code></a></s></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString"><code>Object.prototype.toString()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf"><code>Object.prototype.valueOf()</code></a></li><li><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"><code>Object.setPrototypeOf()</code></a></li></ol></li></ol></section></div>

<p><strong><code>RegExp</code></strong> 对象用于将文本与一个模式匹配。</p>

<p>有关正则表达式的介绍，请阅读 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/">JavaScript指南</a>中的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式章节</a>。</p>

<h2 id="描述">描述</h2>

<h3 id="字面量和构造函数">字面量和构造函数</h3>

<p>有两种方法可以创建一个 <code>RegExp</code> 对象：一种是字面量，另一种是构造函数。</p>

<dl>
 <dt>字面量</dt>
 <dd>由斜杠包围而不是引号包围。</dd>
 <dt>构造函数的字符串参数</dt>
 <dd>由引号而不是斜杠包围。</dd>
</dl>

<p>以下三种表达式都会创建相同的正则表达式：</p>

<pre class="brush: js notranslate" style="font-size: 14px;">/ab+c/i;
new RegExp(&apos;ab+c&apos;, &apos;i&apos;);
new RegExp(/ab+c/, &apos;i&apos;);</pre>

<p>当表达式被赋值时，字面量形式提供正则表达式的编译（compilation）状态，当正则表达式保持为常量时使用字面量。例如当你在循环中使用字面量构造一个正则表达式时，正则表达式不会在每一次迭代中都被重新编译（recompiled）。</p>

<p>而正则表达式对象的构造函数，如 <code>new RegExp(&apos;ab+c&apos;)</code> 提供了正则表达式运行时编译（runtime compilation）。如果你知道正则表达式模式将会改变，或者你事先不知道什么模式，而是从另一个来源获取，如用户输入，这些情况都可以使用构造函数。</p>

<h3 id="构造函数中的标志参数flags">构造函数中的标志参数(flags)</h3>

<p>从 ECMAScript 6 开始，当第一个参数为正则表达式而第二个标志参数存在时，<code>new RegExp(/ab+c/, &apos;i&apos;)</code> 不再抛出 <a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/TypeError"><code>TypeError</code></a> （<code>&quot;从另一个RegExp构造一个RegExp时无法提供标志&quot;</code>）的异常，取而代之，将使用这些参数创建一个新的正则表达式。</p>

<p>当使用构造函数创造正则对象时，需要常规的字符转义规则（在前面加反斜杠 <code>\</code>）。</p>

<p>比如，以下是等价的：</p>

<pre class="brush: js notranslate">var re = new RegExp(&quot;\\w+&quot;);
var re = /\w+/;</pre>

<h3 id="Perl-like_RegExp_属性">Perl-like RegExp 属性</h3>

<p>请注意，<a href="/zh-CN/docs/Web/JavaScript/Reference/RegExp"><code>RegExp</code></a>属性有长名称和短名称（类似Perl）。两个名称总是引用同一个值。（Perl是JavaScript为其正则表达式建模的编程语言）。另请参见<a href="/en-US/docs/Web/JavaScript/Reference/Deprecated_and_obsolete_features#RegExp_Properties">不推荐使用的RegExp属性。</a></p>

<h2 id="构造函数">构造函数</h2>

<dl>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/RegExp"><code>RegExp()</code></a></dt>
 <dd>创建一个新的 <code>RegExp</code> 对象。</dd>
</dl>

<h2 id="静态属性">静态属性</h2>

<dl>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@species"><code>get RegExp[@@species]</code></a></dt>
 <dd>该构造函数用于创建派生对象。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex"><code>RegExp.lastIndex</code></a></dt>
 <dd>该索引表示从哪里开始下一个匹配</dd>
</dl>

<h2 id="实例属性">实例属性</h2>

<dl>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/flags"><code>RegExp.prototype.flags</code></a></dt>
 <dd>含有 <code>RegExp</code> 对象 flags 的字符串。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/dotAll"><code>RegExp.prototype.dotAll</code></a></dt>
 <dd><code>.</code> 是否要匹配新行（newlines）。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/global"><code>RegExp.prototype.global</code></a></dt>
 <dd>针对字符串中所有可能的匹配项测试正则表达式，还是仅针对第一个匹配项。</dd>
 <dt></dt>
 <dt></dt>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/ignoreCase"><code>RegExp.prototype.ignoreCase</code></a></dt>
 <dd>匹配文本的时候是否忽略大小写。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/multiline"><code>RegExp.prototype.multiline</code></a></dt>
 <dd>是否进行多行搜索。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/source"><code>RegExp.prototype.source</code></a></dt>
 <dd>正则表达式的文本。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky"><code>RegExp.prototype.sticky</code></a></dt>
 <dd>搜索是否是 sticky。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/unicode"><code>RegExp.prototype.unicode</code></a></dt>
 <dd>Unicode 功能是否开启。</dd>
</dl>

<h2 id="实例方法">实例方法</h2>

<dl>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/compile"><code>RegExp.prototype.compile()</code></a></dt>
 <dd>运行脚本的期间（重新）编译正则表达式。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec"><code>RegExp.prototype.exec()</code></a></dt>
 <dd>在该字符串中执行匹配项的搜索。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/test"><code>RegExp.prototype.test()</code></a></dt>
 <dd>该正则在字符串里是否有匹配。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@match"><code>RegExp.prototype[@@match]()</code></a></dt>
 <dd>对给定字符串执行匹配并返回匹配结果。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@matchAll"><code>RegExp.prototype[@@matchAll]()</code></a></dt>
 <dd>对给定字符串执行匹配，返回所有匹配结果。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@replace"><code>RegExp.prototype[@@replace]()</code></a></dt>
 <dd>给定新的子串，替换所有匹配结果。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@search"><code>RegExp.prototype[@@search]()</code></a></dt>
 <dd>在给定字符串中搜索匹配项，并返回在字符串中找到字符索引。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/@@split"><code>RegExp.prototype[@@split]()</code></a></dt>
 <dd>通过将给定字符串拆分为子字符串，并返回字符串形成的数组。</dd>
 <dt><a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/toString"><code>RegExp.prototype.toString()</code></a></dt>
 <dd>返回表示指定对象的字符串。重写<a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString"><code>Object.prototype.toString()</code></a>方法。</dd>
</dl>

<h2 id="Syntax" name="Syntax">示例</h2>

<h3 id="Using_a_regular_expression_to_change_data_format" name="Using_a_regular_expression_to_change_data_format">使用正则改变数据结构</h3>

<p>下例使用  <a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String"><code>String</code></a> 的 <a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace"><code>replace()</code></a> 方法去匹配姓名 <em>first last </em>输出新的格式 <em>last</em>, <em>first</em>。</p>

<p>在替换的文本中，脚本中使用 <code>$1</code> 和 <code>$2</code> 指明括号里先前的匹配.</p>

<pre class="brush: js notranslate">let re = /(\w+)\s(\w+)/;
let str = &quot;John Smith&quot;;
let newstr = str.replace(re, &quot;$2, $1&quot;);
console.log(newstr);
</pre>

<p>这将显示 &quot;Smith, John&quot;.</p>

<h3 id="使用正则来划分带有多种行结束符和换行符的文本">使用正则来划分带有多种行结束符和换行符的文本</h3>

<p>对于不同的平台（Unix，Windows等等），其默认的行结束符是不一样的. 而下面的划分方式适用于所有平台。</p>

<pre class="notranslate">let text = &apos;Some text\nAnd some more\r\nAnd yet\rThis is the end&apos;
let lines = text.split(/\r\n|\r|\n/)
console.log(lines) // logs [ &apos;Some text&apos;, &apos;And some more&apos;, &apos;And yet&apos;, &apos;This is the end&apos; ]
</pre>

<p>注意：在正则表达式中，以竖线分割的子模式的顺序会影响匹配结果。</p>

<h3 id="在多行文本中使用正则表达式">在多行文本中使用正则表达式</h3>

<pre class="brush: js notranslate">let s = &quot;Please yes\nmake my day!&quot;;

s.match(/yes.*day/);
// Returns null

s.match(/yes[^]*day/);
// Returns &apos;yes\nmake my day&apos;</pre>

<h3 id="Using_a_regular_expression_with_the_sticky_flag" name="Using_a_regular_expression_with_the_sticky_flag">使用带有 sticky 标志的正则表达式</h3>

<p>带有<a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/sticky"><code>sticky</code></a>标志的正则表达式将会从源字符串的<a href="/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/lastIndex"><code>RegExp.prototype.lastIndex</code></a>位置开始匹配，也就是进行“粘性匹配”。</p>

<pre class="brush: js notranslate">let str = &apos;#foo#&apos;
let regex = /foo/y

regex.lastIndex = 1
regex.test(str)      // true
regex.lastIndex = 5
regex.test(str)      // false (lastIndex is taken into account with sticky flag)
regex.lastIndex      // 0 (reset after match failure)</pre>

<h3 id="sticky_标志和_global_标志的不同点"> sticky 标志和 global 标志的不同点</h3>

<p>如果正则表达式有粘性 <code>y</code> 标志，下一次匹配一定在 <code>lastIndex</code> 位置开始；如果正则表达式有全局 <code>g</code> 标志，下一次匹配可能在 <code>lastIndex</code> 位置开始，也可能在这个位置的后面开始。</p>

<pre class="brush: js notranslate">re = /\d/y;
while (r = re.exec(&quot;123 456&quot;)) console.log(r, &quot;AND re.lastIndex&quot;, re.lastIndex);

// [ &apos;1&apos;, index: 0, input: &apos;123 456&apos;, groups: undefined ] AND re.lastIndex 1
// [ &apos;2&apos;, index: 1, input: &apos;123 456&apos;, groups: undefined ] AND re.lastIndex 2
// [ &apos;3&apos;, index: 2, input: &apos;123 456&apos;, groups: undefined ] AND re.lastIndex 3
//   ... and no more match.</pre>

<p>如果使用带有全局标志<code>g</code>的正则表达式<code>re</code>，就会捕获字符串中的所有6个数字，而非3个</p>

<h3 id="Browser_Compatibility" name="Browser_Compatibility">使用正则表达式和 Unicode 字符</h3>

<p>正如上面表格提到的，<code>\w</code> 或 <code>\W</code> 只会匹配基本的 ASCII 字符；如 <code>a</code> 到 <code>z</code>、 <code>A</code> 到 <code>Z</code>、 <code>0</code> 到 <code>9</code> 及 <code>_</code>。</p>

<p>为了匹配其他语言中的字符，如西里尔（Cyrillic）或 希伯来语（Hebrew），要使用 <code>\uhhhh</code>，<code>hhhh</code> 表示以十六进制表示的字符的 Unicode 值。</p>

<p>下例展示了怎样从一个单词中分离出 Unicode 字符。</p>

<pre class="brush: js notranslate">let text = &quot;Образец text на русском языке&quot;;
let regex = /[\u0400-\u04FF]+/g;

let match = regex.exec(text);
console.log(match[1]);  // prints &quot;Образец&quot;
console.log(regex.lastIndex);  // prints &quot;7&quot;

let match2 = regex.exec(text);
console.log(match2[1]);  // prints &quot;на&quot; [did not print &quot;text&quot;]
console.log(regex.lastIndex);  // prints &quot;15&quot;

// and so on</pre>

<p><a href="https://wiki.developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Unicode_Property_Escapes">Unicode属性转义特性</a>引入了一种解决方案，它允许使用像\p{scx=Cyrl}这样简单的语句。这里有一个外部资源，用来获取 Unicode 中的不同区块范围：<a href="http://kourge.net/projects/regexp-unicode-block" title="http://kourge.net/projects/regexp-unicode-block">Regexp-unicode-block</a></p>

<h3 id="从_URL_中提取子域名">从 URL 中提取子域名</h3>

<pre class="brush: js notranslate">var url = &quot;http://xxx.domain.com&quot;;
console.log(/[^.]+/.exec(url)[0].substr(7)); // logs &quot;xxx&quot;

</pre>

<div class="note notecard">
<p>使用浏览器内建的<a href="/en-US/docs/Web/API/URL_API">URL API</a>而非正则表达式来解析URL是更好的做法</p>
</div>

<h2 id="规范" style="margin-bottom: 20px; line-height: 30px;">规范</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">规范</th>
   <th scope="col">状态</th>
   <th scope="col">备注</th>
  </tr>
  <tr>
   <td>ECMAScript 1st Edition. Implemented in JavaScript 1.1</td>
   <td>Standard</td>
   <td>Initial definition.</td>
  </tr>
  <tr>
   <td><a class="external" href="https://www.ecma-international.org/ecma-262/5.1/#sec-15.10" hreflang="en" lang="en">ECMAScript 5.1 (ECMA-262)<br><small lang="zh-CN">RegExp</small></a></td>
   <td><span class="spec-Standard">Standard</span></td>
   <td></td>
  </tr>
  <tr>
   <td><a class="external" href="https://www.ecma-international.org/ecma-262/6.0/#sec-regexp-regular-expression-objects" hreflang="en" lang="en">ECMAScript 2015 (6th Edition, ECMA-262)<br><small lang="zh-CN">RegExp</small></a></td>
   <td><span class="spec-Standard">Standard</span></td>
   <td></td>
  </tr>
 </tbody>
</table>

<h2 id="Browser_Compatibility" name="Browser_Compatibility">浏览器兼容性</h2>

<div class="bc-data" id="bcd:javascript.builtins.RegExp"></div>

<h3 id="Firefox_特定版本提示">Firefox 特定版本提示</h3>

<p>Starting with Gecko 34 (Firefox 34 / Thunderbird 34 / SeaMonkey 2.31), in the case of a capturing group with quantifiers preventing its exercise, the matched text for a capturing group is now <code>undefined</code> instead of an empty string:</p>

<pre class="notranslate"><code>// Firefox 33 or older
&apos;x&apos;.replace(/x(.)?/g, function(m, group) {
  console.log(&quot;&apos;group:&quot; + group + &quot;&apos;&quot;);
}); // &apos;group:&apos;

// Firefox 34 or newer
&apos;x&apos;.replace(/x(.)?/g, function(m, group) {
  console.log(&quot;&apos;group:&quot; + group + &quot;&apos;&quot;);
}); // &apos;group:undefined&apos;</code></pre>

<p>注意，由于web兼容性 <code>RegExp.$N</code> 仍会返回一个空的字符串代替 <code>undefined</code> (<a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1053944">bug 1053944</a>).</p>

<h2 id="相关链接">相关链接</h2>

<ul>
 <li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide" title="JavaScript/Guide">JavaScript指南</a>中的<a href="/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" title="JavaScript/Guide/Regular_Expressions">正则表达式</a>一节</li>
 <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match">String.prototype.match()</a></li>
 <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace">String.prototype.replace()</a></li>
</ul>

---
title: Function.prototype.bind()
slug: Web/JavaScript/Reference/Global_Objects/Function/bind
tags:
  - ECMAScript5
  - ECMAScript6
  - Function
  - JavaScript
  - Method
  - Reference
  - polyfill
translation_of: Web/JavaScript/Reference/Global_Objects/Function/bind
---
<div><section class="Quick_links" id="Quick_Links"><ol><li><strong><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects">Стандартные встроенные объекты</a></strong></li><li><strong><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function"><code>Function</code></a></strong></li><li data-default-state="open"><a href="#"><strong>Свойства</strong></a><ol><li><span class="sidebar-icon"><span title="Это устаревшее API больше не должно использоваться, но оно по-прежнему может работать."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments"><code>Function.arguments</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="Этот API вышел из употребления и его работа больше не гарантируется."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/arity"><code>Function.arity</code></a></s></li><li><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/caller"><code>Function.caller</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="Это API не было стандартизировано."><i class="icon-warning-sign"> </i></span></span><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/displayName"><code>Function.displayName</code></a></li><li><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/length"><code>Function.length</code></a></li><li><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype"><code>Function.prototype</code></a></li><li><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/name"><code>Function.name</code></a></li></ol></li><li data-default-state="open"><a href="#"><strong>Методы</strong></a><ol><li><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"><code>Function.prototype.apply()</code></a></li><li><em><code>Function.prototype.bind()</code></em></li><li><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/call"><code>Function.prototype.call()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="Это API не было стандартизировано."><i class="icon-warning-sign"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="Этот API вышел из употребления и его работа больше не гарантируется."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/isGenerator"><code>Function.prototype.isGenerator()</code></a></s></li><li><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/toSource"><code>Function.prototype.toSource()</code></a></li><li><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/toString"><code>Function.prototype.toString()</code></a></li></ol></li><li><strong>Наследование:</strong></li><li><strong><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object"><code>Object</code></a></strong></li><li><a href="#"><strong>Свойства</strong></a><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="Это API не было стандартизировано."><i class="icon-warning-sign"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="Этот API вышел из употребления и его работа больше не гарантируется."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/count"><code>Object.prototype.__count__</code></a></s></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="Это API не было стандартизировано."><i class="icon-warning-sign"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="Этот API вышел из употребления и его работа больше не гарантируется."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/noSuchMethod"><code>Object.prototype.__noSuchMethod__</code></a></s></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="Это API не было стандартизировано."><i class="icon-warning-sign"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="Этот API вышел из употребления и его работа больше не гарантируется."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/parent"><code>Object.prototype.__parent__</code></a></s></li><li><span class="sidebar-icon"><span title="Это устаревшее API больше не должно использоваться, но оно по-прежнему может работать."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"><code>Object.prototype.__proto__</code></a></li><li><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor"><code>Object.prototype.constructor</code></a></li></ol></li><li><a href="#"><strong>Методы</strong></a><ol><li><span class="sidebar-icon"><span title="Это устаревшее API больше не должно использоваться, но оно по-прежнему может работать."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__"><code>Object.prototype.__defineGetter__()</code></a></li><li><span class="sidebar-icon"><span title="Это устаревшее API больше не должно использоваться, но оно по-прежнему может работать."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineSetter__"><code>Object.prototype.__defineSetter__()</code></a></li><li><span class="sidebar-icon"><span title="Это устаревшее API больше не должно использоваться, но оно по-прежнему может работать."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupGetter__"><code>Object.prototype.__lookupGetter__()</code></a></li><li><span class="sidebar-icon"><span title="Это устаревшее API больше не должно использоваться, но оно по-прежнему может работать."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupSetter__"><code>Object.prototype.__lookupSetter__()</code></a></li><li><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty"><code>Object.prototype.hasOwnProperty()</code></a></li><li><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf"><code>Object.prototype.isPrototypeOf()</code></a></li><li><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable"><code>Object.prototype.propertyIsEnumerable()</code></a></li><li><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString"><code>Object.prototype.toLocaleString()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="Это API не было стандартизировано."><i class="icon-warning-sign"> </i></span></span><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/toSource"><code>Object.prototype.toSource()</code></a></li><li><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/toString"><code>Object.prototype.toString()</code></a></li><li><span class="sidebar-icon"><span title="Это устаревшее API больше не должно использоваться, но оно по-прежнему может работать."><i class="icon-thumbs-down-alt"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="Этот API вышел из употребления и его работа больше не гарантируется."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/unwatch"><code>Object.prototype.unwatch()</code></a></s></li><li><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf"><code>Object.prototype.valueOf()</code></a></li><li><span class="sidebar-icon"><span title="Это устаревшее API больше не должно использоваться, но оно по-прежнему может работать."><i class="icon-thumbs-down-alt"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="Этот API вышел из употребления и его работа больше не гарантируется."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/watch"><code>Object.prototype.watch()</code></a></s></li><li><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"><code>Object.setPrototypeOf()</code></a></li></ol></li></ol></section></div>

<h2 id="Summary" name="Summary">Сводка</h2>

<p>Метод <code><strong>bind()</strong></code> создаёт новую функцию, которая при вызове устанавливает в качестве контекста выполнения <code>this</code> предоставленное значение. В метод также передаётся набор аргументов, которые будут установлены перед переданными в привязанную функцию аргументами при её вызове.</p>

<h2 id="Syntax" name="Syntax">Синтаксис</h2>

<pre class="syntaxbox"><code><var>fun</var>.bind(<var>thisArg</var>[, <var>arg1</var>[, <var>arg2</var>[, ...]]])</code></pre>

<h3 id="Parameters" name="Parameters">Параметры</h3>

<dl>
 <dt><code>thisArg</code></dt>
 <dd>Значение, передаваемое в качестве <code>this</code> в целевую функцию при вызове привязанной функции. Значение игнорируется, если привязанная функция конструируется с помощью оператора <a href="/ru/docs/Web/JavaScript/Reference/Operators/new" title="Оператор (операторная функция) new создает экземпляр объекта, встроенного или определенного пользователем, имеющего конструктор."><code>new</code></a>.</dd>
 <dt><code>arg1, arg2, ...</code></dt>
 <dd>Аргументы целевой функции, передаваемые перед аргументами привязанной функции при вызове целевой функции.</dd>
</dl>

<h2 id="Description" name="Description">Описание</h2>

<p>Метод <code>bind()</code> создаёт новую &quot;<strong>привязанную функцию</strong>&quot; (<strong>ПФ</strong>).  <strong>ПФ</strong> <span class="translation-chunk">- это &quot;необычный </span> <span class="translation-chunk">функциональный объект&quot; ( термин из </span> <strong>ECMAScript 6</strong> <span class="translation-chunk"> ), который является оберткой над исходным </span> <span class="translation-chunk">функциональным объектом. Вызов </span> <strong>ПФ</strong> <span class="translation-chunk">  приводит к исполнению кода обернутой функции.</span></p>

<p><strong>ПФ</strong> <span class="translation-chunk"> имеет следующие внутренние ( скрытые ) свойства:</span></p>

<ul>
 <li><span class="translation-chunk"><strong>[[BoundTargetFunction]]</strong> - оборачиваемый  (целевой ) </span> <span class="translation-chunk">функциональный </span><span class="translation-chunk">объект</span></li>
 <li><span class="translation-chunk"><strong>[[BoundThis]]</strong> - значение, которое всегда передается в качестве значения   <strong>this </strong>при вызове обернутой функции.</span></li>
 <li><span class="translation-chunk"><strong>[[BoundArguments]] </strong>- список значений, элементы которого используются в качестве первого аргумента при вызове оборачиваемой функции.</span></li>
 <li><strong><span class="translation-chunk">[[</span>Call</strong><span class="translation-chunk"><strong>]] </strong>- внутренний метод. Выполняет код (функциональное выражение), связанный с функциональным объектом. </span></li>
</ul>

<p><span class="translation-chunk">Когда <strong>ПФ </strong>вызывается, исполняется ее внутренний метод </span> <strong>[[Call]]</strong> <span class="translation-chunk"> со следующими аргументами </span> <strong>Call(<em>target</em>, <em>boundThis</em>, <em>args</em>).</strong></p>

<ul>
 <li><strong><em>target</em></strong> <span class="translation-chunk">  -    <strong>[[BoundTargetFunction]]</strong>;</span></li>
 <li><span class="translation-chunk"><em><strong>boundThis </strong></em></span><em><strong> <span class="translation-chunk"> </span> </strong></em><span class="translation-chunk"><em><strong>  </strong></em>-    </span><strong> </strong><span class="translation-chunk"><strong>[[BoundThis]]</strong>;</span></li>
 <li><em><strong>args  </strong></em> -  <strong> <span class="translation-chunk">[[BoundArguments]].</span></strong></li>
</ul>

<p>Привязанная функция также может быть сконструирована с помощью оператора <a href="/ru/docs/Web/JavaScript/Reference/Operators/new" title="Оператор (операторная функция) new создает экземпляр объекта, встроенного или определенного пользователем, имеющего конструктор."><code>new</code></a>: это работает так, как если бы вместо неё конструировалась целевая функция. Предоставляемое значение <code>this</code> в этом случае игнорируется, хотя ведущие аргументы всё ещё передаются в эмулируемую функцию.</p>

<h2 id="Examples" name="Examples">Примеры</h2>

<h3 id="Example:_Creating_a_bound_function" name="Example:_Creating_a_bound_function">Пример: создание привязанной функции</h3>

<p>Простейшим способом использования <code>bind()</code> является создание функции, которая, вне зависимости от способа её вызова, вызывается с определённым значением <code>this</code>. Обычным заблуждением для новичков в JavaScript является извлечение метода из объекта с целью его дальнейшего вызова в качестве функции и ожидание того, что он будет использовать оригинальный объект в качестве своего значения <code>this</code> (например, такое может случиться при использовании метода как функции обратного вызова). Однако, без специальной обработки, оригинальный объект зачастую теряется. Создание привязанной функции из функции, использующей оригинальный объект, изящно решает эту проблему:</p>

<pre class="brush: js">this.x = 9;
var module = {
  x: 81,
  getX: function() { return this.x; }
};

module.getX(); // 81

var getX = module.getX;
getX(); // 9, поскольку в этом случае this ссылается на глобальный объект

// создаём новую функцию с this, привязанным к module
var boundGetX = getX.bind(module);
boundGetX(); // 81
</pre>

<h3 id="Example:_Partial_Functions" name="Example:_Partial_Functions">Пример: частичные функции</h3>

<p>Следующим простейшим способом использования <code>bind()</code> является создание функции с предопределёнными аргументами. Эти аргументы (если они есть) передаются после значения <code>this</code> и вставляются перед аргументами, передаваемыми в целевую функцию при вызове привязанной функции.</p>

<pre class="brush: js">function list() {
  return Array.prototype.slice.call(arguments);
}

var list1 = list(1, 2, 3); // [1, 2, 3]

// Создаём функцию с предустановленным ведущим аргументом
var leadingThirtysevenList = list.bind(undefined, 37);

var list2 = leadingThirtysevenList(); // [37]
var list3 = leadingThirtysevenList(1, 2, 3); // [37, 1, 2, 3]
</pre>

<h3 id="Example:_With_setTimeout" name="Example:_With_setTimeout">Пример: с <code>setTimeout</code></h3>

<p>По умолчанию, внутри <a href="/ru/docs/Web/API/Window/setTimeout" title="Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!"><code>window.setTimeout()</code></a> контекст <code>this</code> устанавливается в объект <a href="/ru/docs/Web/API/Window" title="Объект window представляет собой окно, содержащее DOM документ; свойство document указывает на DOM document, загруженный в данном окне."><code>window</code></a> (или <code>global</code>). При работе с методами класса, требующими <code>this</code> для ссылки на экземпляры класса, вы можете явно привязать <code>this</code> к функции обратного вызова для сохранения экземпляра.</p>

<pre class="brush: js">function LateBloomer() {
  this.petalCount = Math.ceil(Math.random() * 12) + 1;
}

// Объявляем цветение с задержкой в 1 секунду
LateBloomer.prototype.bloom = function() {
  window.setTimeout(this.declare.bind(this), 1000);
};

LateBloomer.prototype.declare = function() {
  console.log(&apos;Я прекрасный цветок с &apos; +
    this.petalCount + &apos; лепестками!&apos;);
};
</pre>

<h3 id="Example:_Bound_functions_used_as_constructors" name="Example:_Bound_functions_used_as_constructors">Пример: привязывание функций, используемых в качестве конструкторов</h3>

<div class="warning notecard">
<p><strong>Предупреждение:</strong> этот раздел демонстрирует возможности JavaScript и документирует некоторые граничные случаи использования метода <code>bind()</code>. Показанные ниже методы не являются лучшей практикой и, вероятно, их не следует использовать в рабочем окружении.</p>
</div>

<p>Привязанные функции автоматически подходят для использования вместе с оператором <a href="/ru/docs/Web/JavaScript/Reference/Operators/new" title="Оператор (операторная функция) new создает экземпляр объекта, встроенного или определенного пользователем, имеющего конструктор."><code>new</code></a> для конструирования новых экземпляров, создаваемых целевой функцией. Когда привязанная функция используется для конструирования значения, предоставляемое значение <code>this</code> игнорируется. Однако, предоставляемые аргументы всё так же вставляются перед аргументами конструктора:</p>

<pre class="brush: js">function Point(x, y) {
  this.x = x;
  this.y = y;
}

Point.prototype.toString = function() {
  return this.x + &apos;,&apos; + this.y;
};

var p = new Point(1, 2);
p.toString(); // &apos;1,2&apos;


var emptyObj = {};
var YAxisPoint = Point.bind(emptyObj, 0/*x*/);
// не поддерживается полифиллом, приведённым ниже,
// но отлично работает с родным bind:
var YAxisPoint = Point.bind(null, 0/*x*/);

var axisPoint = new YAxisPoint(5);
axisPoint.toString(); // &apos;0,5&apos;

axisPoint instanceof Point; // true
axisPoint instanceof YAxisPoint; // true
new Point(17, 42) instanceof YAxisPoint; // true
</pre>

<p>Обратите внимание, что вам не нужно делать ничего особенного для создания привязанной функции, используемой с оператором <a href="/ru/docs/Web/JavaScript/Reference/Operators/new" title="Оператор (операторная функция) new создает экземпляр объекта, встроенного или определенного пользователем, имеющего конструктор."><code>new</code></a>. В итоге, для создания явно вызываемой привязанной функции, вам тоже не нужно делать ничего особенного, даже если вам требуется, чтобы привязанная функция вызывалась только с помощью оператора <a href="/ru/docs/Web/JavaScript/Reference/Operators/new" title="Оператор (операторная функция) new создает экземпляр объекта, встроенного или определенного пользователем, имеющего конструктор."><code>new</code></a>.</p>

<pre class="brush: js">// Пример может быть запущен прямо в вашей консоли JavaScript
// ...продолжение примера выше

// Всё ещё можно вызывать как нормальную функцию
// (хотя обычно это не предполагается)
YAxisPoint(13);

emptyObj.x + &apos;,&apos; + emptyObj.y;
// &gt;  &apos;0,13&apos;
</pre>

<p>Если вы хотите поддерживать использование привязанной функции только с помощью оператора <a href="/ru/docs/Web/JavaScript/Reference/Operators/new" title="Оператор (операторная функция) new создает экземпляр объекта, встроенного или определенного пользователем, имеющего конструктор."><code>new</code></a>, либо только с помощью прямого вызова, целевая функция должна предусматривать такие ограничения.</p>

<h3 id="Example:_Creating_shortcuts" name="Example:_Creating_shortcuts">Пример: создание сокращений</h3>

<p>Метод <code>bind()</code> также полезен в случаях, если вы хотите создать сокращение для функции, требующей определёное значение <code>this</code>.</p>

<p>Возьмём, например, метод <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" title="Метод slice() возвращает новый массив, содержащий копию части исходного массива."><code>Array.prototype.slice</code></a>, который вы можете использовать для преобразования массивоподобного объекта в настоящий массив. Вы можете создать подобное сокращение:</p>

<pre class="brush: js">var slice = Array.prototype.slice;

// ...

slice.call(arguments);
</pre>

<p>С помощью метода <code>bind()</code>, это сокращение может быть упрощено. В следующем куске кода <code>slice</code> является функцией, привязанной к функции <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/call" title="Метод call() вызывает функцию с указанным значением this и индивидуально предоставленными аргументами."><code>call()</code></a> объекта <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/prototype" title="Свойство Function.prototype представляет прототип объекта Function."><code>Function.prototype</code></a>, со значением <code>this</code>, установленным в функцию <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" title="Метод slice() возвращает новый массив, содержащий копию части исходного массива."><code>slice()</code></a> объекта <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/prototype" title="Свойство Array.prototype представляет прототип для конструктора Array."><code>Array.prototype</code></a>. Это означает, что дополнительный вызов <code>call()</code> может быть устранён:</p>

<pre class="brush: js">// Тоже самое, что и slice в предыдущем примере
var unboundSlice = Array.prototype.slice;
var slice = Function.prototype.call.bind(unboundSlice);

// ...

slice(arguments);
</pre>

<h2 id="Polyfill" name="Polyfill">Полифилл</h2>

<p>Функция <code>bind</code> является дополнением к стандарту ECMA-262 5-го издания; поэтому она может присутствовать не во всех браузерах. Вы можете частично обойти это ограничение, вставив следующий код в начало ваших скриптов, он позволяет использовать большую часть возможностей <code>bind()</code> в реализациях, не имеющих его родной поддержки.</p>

<pre class="brush: js">if (!Function.prototype.bind) {
  Function.prototype.bind = function(oThis) {
    if (typeof this !== &apos;function&apos;) {
      // ближайший аналог внутренней функции
      // IsCallable в ECMAScript 5
      throw new TypeError(&apos;Function.prototype.bind - what is trying to be bound is not callable&apos;);
    }

    var aArgs = Array.prototype.slice.call(arguments, 1),
        fToBind = this,
        fNOP    = function() {},
        fBound  = function() {
          return fToBind.apply(this instanceof fNOP &amp;&amp; oThis
                 ? this
                 : oThis,
                 aArgs.concat(Array.prototype.slice.call(arguments)));
        };

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();

    return fBound;
  };
}
</pre>

<p>Некоторые из многих отличий (так же могут быть и другие, данный список далеко не исчерпывающий) между этой реализацией и реализацией по умолчанию:</p>

<ul>
 <li>Частичная реализация предполагает, что методы <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/slice" title="Метод slice() возвращает новый массив, содержащий копию части исходного массива."><code>Array.prototype.slice()</code></a>, <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Array/concat" title="Метод concat() возвращает новый массив, состоящий из массива, на котором он был вызван, соединённого с другими массивами и/или значениями, переданными в качестве аргументов."><code>Array.prototype.concat()</code></a>, <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/call" title="Метод call() вызывает функцию с указанным значением this и индивидуально предоставленными аргументами."><code>Function.prototype.call()</code></a> и <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" title="Метод apply() вызывает функцию с указанным значением this и аргументами, предоставленными в виде массива (либо массивоподобного объекта)."><code>Function.prototype.apply()</code></a> являются встроенными, имеют своё первоначальное значение.</li>
 <li>Частичная реализация создаёт функции, не имеющие неизменяемых свойств «отравленной пилюли» — <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/caller" title="Свойство function.caller возвращает функцию, которая вызвала указанную функцию."><code>caller</code></a> и <code>arguments</code> — которые выбрасывают исключение <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/TypeError" title="Объект TypeError представляет ошибку, возникающую, когда значение имеет не ожидаемый тип."><code>TypeError</code></a> при попытке получить, установить или удалить эти свойства. (Такие свойства могут быть добавлены, если реализация поддерживает <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" title="Метод Object.defineProperty() определяет новое или изменяет существующее свойство непосредственно на объекте, возвращая этот объект."><code>Object.defineProperty</code></a>, либо частично реализованы [без поведения исключение-при-попытке-удаления], если реализация поддерживает расширения <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineGetter" title="Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!"><code>__defineGetter__</code></a> и <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/defineSetter" title="Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!"><code>__defineSetter__</code></a>.)</li>
 <li>Частичная реализация создаёт функции, имеющие свойство <code>prototype</code>. (Правильная привязанная функция его не имеет.)</li>
 <li>Частичная реализация создаёт привязанные функции, чьё свойство <a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/length" title="Свойство length определяет количество аргументов, ожидаемых функцией."><code>length</code></a> не соответствует с определением в ECMA-262; оно равно 0, в то время, как полная реализация, в зависимости от значения свойства <code>length</code> целевой функции и количества предопределённых аргументов, может вернуть значение, отличное от нуля.</li>
</ul>

<p>Если вы решили использовать частичную реализацию, <strong>не рассчитывайте на корректную работу в тех случаях, когда реализация отклоняется от спецификации ECMA-262 5-го издания!</strong> Однако, в определённых случаях (и, возможно, с дополнительными модификациями для отдельных нужд), применение данной частичной реализации может быть вполне оправданным до тех пор, пока <code>bind()</code> не станет широко реализован в соответствии со спецификацией.</p>

<h2 id="Specifications" name="Specifications">Спецификации</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Спецификация</th>
   <th scope="col">Статус</th>
   <th scope="col">Комментарии</th>
  </tr>
  <tr>
   <td><a lang="en" href="https://www.ecma-international.org/ecma-262/5.1/#sec-15.3.4.5" class="external" hreflang="en">ECMAScript 5.1 (ECMA-262)<br><small lang="ru">Определение &apos;Function.prototype.bind&apos; в этой спецификации.</small></a></td>
   <td><span class="spec-Standard">Стандарт</span></td>
   <td>Изначальное определение. Реализована в JavaScript 1.8.5.</td>
  </tr>
  <tr>
   <td><a lang="en" href="https://www.ecma-international.org/ecma-262/6.0/#sec-function.prototype.bind" class="external" hreflang="en">ECMAScript 2015 (6th Edition, ECMA-262)<br><small lang="ru">Определение &apos;Function.prototype.bind&apos; в этой спецификации.</small></a></td>
   <td><span class="spec-Standard">Стандарт</span></td>
   <td> </td>
  </tr>
 </tbody>
</table>

<h2 id="Browser_compatibility" name="Browser_compatibility">Совместимость с браузерами</h2>

<div><div class="warning notecard"><strong><a href="https://github.com/mdn/browser-compat-data">We&apos;re converting our compatibility data into a machine-readable JSON format</a></strong>.
            This compatibility table still uses the old format,
            because we haven&apos;t yet converted the data it contains.
            <strong><a href="/ru/docs/MDN/Contribute/Structures/Compatibility_tables">Find out how you can help!</a></strong></div>

<div class="htab">
    <a id="AutoCompatibilityTable" name="AutoCompatibilityTable"></a>
    <ul>
        <li class="selected"><a>Настольные</a></li>
        <li><a>Мобильные</a></li>
    </ul>
</div></div>

<div id="compat-desktop">
<table class="compat-table">
 <tbody>
  <tr>
   <th>Возможность</th>
   <th>Chrome</th>
   <th>Firefox (Gecko)</th>
   <th>Internet Explorer</th>
   <th>Opera</th>
   <th>Safari</th>
  </tr>
  <tr>
   <td>Базовая поддержка</td>
   <td>7</td>
   <td><a href="/en-US/Firefox/Releases/4" title="Выпущен 2011-03-22.">4.0</a> (2)</td>
   <td>9</td>
   <td>11.60</td>
   <td>5.1.4</td>
  </tr>
 </tbody>
</table>
</div>

<div id="compat-mobile">
<table class="compat-table">
 <tbody>
  <tr>
   <th>Возможность</th>
   <th>Android</th>
   <th>Chrome для Android</th>
   <th>Firefox Mobile (Gecko)</th>
   <th>IE Mobile</th>
   <th>Opera Mobile</th>
   <th>Safari Mobile</th>
  </tr>
  <tr>
   <td>Базовая поддержка</td>
   <td>4.0</td>
   <td>0.16</td>
   <td>4.0 (2)</td>
   <td><span style="color: rgb(255, 153, 0);" title="Совместимость неизвестна; пожалуйста, обновите информацию.">?</span></td>
   <td>11.50</td>
   <td>6.0</td>
  </tr>
 </tbody>
</table>
</div>

<p>На основе <a href="http://kangax.github.com/es5-compat-table/">таблицы совместимости Kangax</a>.</p>

<h2 id="See_also" name="See_also">Смотрите также</h2>

<ul>
 <li><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/apply" title="Метод apply() вызывает функцию с указанным значением this и аргументами, предоставленными в виде массива (либо массивоподобного объекта)."><code>Function.prototype.apply()</code></a></li>
 <li><a href="/ru/docs/Web/JavaScript/Reference/Global_Objects/Function/call" title="Метод call() вызывает функцию с указанным значением this и индивидуально предоставленными аргументами."><code>Function.prototype.call()</code></a></li>
 <li><a href="/ru/docs/Web/JavaScript/Reference/Functions_and_function_scope" title="Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!">Функции и их область видимости</a></li>
</ul>

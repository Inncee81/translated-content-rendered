---
title: Использование шейдеров для задания цвета в WebGL
slug: Web/API/WebGL_API/Tutorial/Using_shaders_to_apply_color_in_WebGL
tags:
  - WebGL
translation_of: Web/API/WebGL_API/Tutorial/Using_shaders_to_apply_color_in_WebGL
---
<p></p><section id="Quick_Links">
 <ol>
  <li><a href="/ru/docs/Web/API/WebGL_API"><strong>WebGL API</strong></a></li>
  <li class="toggle">
    <details open>
      <summary>Руководство WebGL</summary>
      <ol>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL">Начало работы с WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Adding_2D_content_to_a_WebGL_context">Добавление двухмерного контента в контекст WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Using_shaders_to_apply_color_in_WebGL">Использование шейдеров для задания цвета в WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Animating_objects_with_WebGL">Оживление объектов при помощи WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Creating_3D_objects_using_WebGL">Создание 3D с помощью WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL">Использование текстур WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Lighting_in_WebGL">Освещение WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Animating_textures_in_WebGL">Анимация текстур WebGL</a></li>
      </ol>
    </details>
  </li>
  <li class="toggle">
    <details open>
      <summary>Примеры и статьи</summary>
      <ol>
        <li><a href="/ru/docs/Web/API/WebGL_API/Matrix_math_for_the_web">Математическая матрица для Веба</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/WebGL_model_view_projection">WebGL модель, представление, проекция</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/WebGL_best_practices">WebGL лучшие практики</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Using_Extensions">Использование расширений WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Basic_2D_animation_example">A basic 2D WebGL animation example</a></li>
      </ol>
    </details>
  </li>
  <li class="toggle">
    <details open>
      <summary>Интерфейсы</summary>
      <ol>
        <li><a href="/ru/docs/Web/API/WebGLRenderingContext"><code>WebGLRenderingContext</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGL2RenderingContext"><code>WebGL2RenderingContext</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLActiveInfo"><code>WebGLActiveInfo</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLBuffer"><code>WebGLBuffer</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLContextEvent"><code>WebGLContextEvent</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLFramebuffer"><code>WebGLFramebuffer</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLProgram"><code>WebGLProgram</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLQuery"><code>WebGLQuery</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLRenderbuffer"><code>WebGLRenderbuffer</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLSampler"><code>WebGLSampler</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLShader"><code>WebGLShader</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLShaderPrecisionFormat"><code>WebGLShaderPrecisionFormat</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLSync"><code>WebGLSync</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLTexture"><code>WebGLTexture</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLTransformFeedback"><code>WebGLTransformFeedback</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLUniformLocation"><code>WebGLUniformLocation</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLVertexArrayObject"><code>WebGLVertexArrayObject</code></a></li>
      </ol>
    </details>
  </li>

  <li><strong><a href="/ru/docs/MDN">Доментация:</a></strong></li>
  <li class="toggle">
    <details>
      <summary>Полезные списки</summary>
      <ol>
        <li><a href="/ru/docs/tag/WebGL">Страницы отмеченные &quot;WebGL&quot;</a></li>
      </ol>
    </details>
  </li>
  <li class="toggle">
    <details>
      <summary>Внести вклад</summary>
      <ol>
        <li><a href="/ru/docs/MDN/Doc_status/API/WebGL">Стутус документации WebGL</a></li>
        <li><a href="/ru/docs/MDN">Проект MDN</a></li>
      </ol>
    </details>
  </li>
 </ol>
</section> <div style="text-align: right;" class="prevnext">
    <p><a style="float: left;" href="/ru/docs/Web/API/WebGL_API/Tutorial/Adding_2D_content_to_a_WebGL_context" class="button">« Предыдущая статья</a><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Animating_objects_with_WebGL" class="button">Следующая статья  »</a></p>
</div><p></p>

<p>В <a href="/ru/docs/Web/WebGL/Adding_2D_content_to_a_WebGL_context" title="en/WebGL/Adding 2D content to a WebGL context">предыдущей статье</a> мы создали квадрат, следующим шагом будет добавление ему цвета. Мы можем сделать это, используя шейдеры.</p>

<h2 id="Задание_цвета_вершинам">Задание цвета вершинам</h2>

<p>В GL, объекты строятся с использованием наборов вершин, для каждой из которых задается положение в пространстве и цвет. По умолчанию, цвета всех остальных пикселей (и все их другие атрибуты, включая положение в пространстве) вычисляются с использованием линейной интерполяции, автоматически создавая плавный градиент. В прошлый раз наш вершинный шейдер не задавал определенных цветов вершинам, а фрагментный шейдер назначил фиксированный белый цвет каждому пикселю, поэтому квадрат целиком был отрисован белым цветом.</p>

<p>Предположим, что мы хотим отрисовать градиент, в котором каждый угол квадрата разного цвета: красного, синего, зеленого и белый. Первое, что необходимо сделать - назначить эти цвета четырем вершинам. Чтобы сделать это, нам сначала необходимо создать массив цветов вершин, а затем сохранить его в WebGL буфер. Мы сделаем это, добавив следующий код в нашу функцию <code>initBuffers()</code>:</p>

<pre class="brush: js">  var colors = [
    1.0,  1.0,  1.0,  1.0,    // белый
    1.0,  0.0,  0.0,  1.0,    // красный
    0.0,  1.0,  0.0,  1.0,    // зеленый
    0.0,  0.0,  1.0,  1.0     // синий
  ];

  squareVerticesColorBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, squareVerticesColorBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
}
</pre>

<p>Этот код начинается с создания JavaScript массива, содержащего четыре вектора, содержащих по четыре значения каждый - по одному вектору для задания цвета каждой вершине. Затем новый WebGL буфер выделяет место в памяти для хранения этих цветов и массив приводится к вещественному формату WebGL и сохраняется в буфер.</p>

<p>Чтобы теперь использовать эти цвета, вершинному шейдеру необходимо обновиться, поместив соответствующий цвет из буфера цвета:</p>

<pre class="brush: html">    &lt;script id=&quot;shader-vs&quot; type=&quot;x-shader/x-vertex&quot;&gt;
      attribute vec3 aVertexPosition;
      attribute vec4 aVertexColor;

      uniform mat4 uMVMatrix;
      uniform mat4 uPMatrix;

      varying lowp vec4 vColor;

      void main(void) {
        gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        vColor = aVertexColor;
      }
    &lt;/script&gt;
</pre>

<p>Ключевым отличием здесь является то, что для каждой вершины, мы задаем цвет на соответствующее значение из массива цвета.</p>

<h2 id="Окраска_фрагментов">Окраска фрагментов</h2>

<p>Чтобы напомнить, как фрагментный шейдер выглядел ранее, ниже приведен его код:</p>

<pre class="brush: html">    &lt;script id=&quot;shader-fs&quot; type=&quot;x-shader/x-fragment&quot;&gt;
      void main(void) {
        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
      }
    &lt;/script&gt;
</pre>

<p>Для того, чтобы подобрать интерполируемый цвет каждому пикселю, нам просто необходимо изменить его, получив значение из переменной <code>vColor</code>:</p>

<pre class="brush: html">    &lt;script id=&quot;shader-fs&quot; type=&quot;x-shader/x-fragment&quot;&gt;
    	varying lowp vec4 vColor;

      void main(void) {
        gl_FragColor = vColor;
      }
    &lt;/script&gt;
</pre>

<p>Это простое изменение, но с помощью него каждый фрагмент вместо фиксированного значения получает значение интерполируемого цвета на основе его расположения относительно вершин.</p>

<h2 id="Отрисовка_с_использованием_цветов">Отрисовка с использованием цветов</h2>

<p>Далее, необходимо добавить код в процедуру <code>initShaders()</code> для задания значений атрибута цвета для шейдерной программы:</p>

<pre class="brush: js">  vertexColorAttribute = gl.getAttribLocation(shaderProgram, &quot;aVertexColor&quot;);
  gl.enableVertexAttribArray(vertexColorAttribute);
</pre>

<p>Затем, drawScene() может быть исправлен на фактическое использование этих цветов при отрисовке квадрата:</p>

<pre class="brush: js">  gl.bindBuffer(gl.ARRAY_BUFFER, squareVerticesColorBuffer);
  gl.vertexAttribPointer(vertexColorAttribute, 4, gl.FLOAT, false, 0, 0);
</pre>

<p>На этом этапе, вы можете посмотреть <a href="/samples/webgl/sample3/index.html" title="https://developer.mozilla.org/samples/webgl/sample3/index.html">результат работы написанного кода</a>, если используете браузер, поддерживающий WebGL. Вы увидете нечто похожее на следующий рисунок (расположенный по центру в большом черном поле):</p>

<p><img src="/@api/deki/files/4081/=screenshot.png" alt="screenshot.png" class="default internal"></p>

<p></p><div style="text-align: right;" class="prevnext">
    <p><a style="float: left;" href="/ru/docs/Web/API/WebGL_API/Tutorial/Adding_2D_content_to_a_WebGL_context" class="button">« Предыдущая статья</a><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Animating_objects_with_WebGL" class="button">Следующая статья  »</a></p>
</div><p></p>

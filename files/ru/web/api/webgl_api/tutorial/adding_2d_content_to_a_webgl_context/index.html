---
title: Добавление двухмерного контента в контекст WebGL
slug: Web/API/WebGL_API/Tutorial/Adding_2D_content_to_a_WebGL_context
tags:
  - WebGL
translation_of: Web/API/WebGL_API/Tutorial/Adding_2D_content_to_a_WebGL_context
---
<p></p><section id="Quick_Links">
 <ol>
  <li><a href="/ru/docs/Web/API/WebGL_API"><strong>WebGL API</strong></a></li>
  <li class="toggle">
    <details open>
      <summary>Руководство WebGL</summary>
      <ol>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL">Начало работы с WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Adding_2D_content_to_a_WebGL_context">Добавление двухмерного контента в контекст WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Using_shaders_to_apply_color_in_WebGL">Использование шейдеров для задания цвета в WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Animating_objects_with_WebGL">Оживление объектов при помощи WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Creating_3D_objects_using_WebGL">Создание 3D с помощью WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL">Использование текстур WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Lighting_in_WebGL">Освещение WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Animating_textures_in_WebGL">Анимация текстур WebGL</a></li>
      </ol>
    </details>
  </li>
  <li class="toggle">
    <details open>
      <summary>Примеры и статьи</summary>
      <ol>
        <li><a href="/ru/docs/Web/API/WebGL_API/Matrix_math_for_the_web">Математическая матрица для Веба</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/WebGL_model_view_projection">WebGL модель, представление, проекция</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/WebGL_best_practices">WebGL лучшие практики</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Using_Extensions">Использование расширений WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Basic_2D_animation_example">A basic 2D WebGL animation example</a></li>
      </ol>
    </details>
  </li>
  <li class="toggle">
    <details open>
      <summary>Интерфейсы</summary>
      <ol>
        <li><a href="/ru/docs/Web/API/WebGLRenderingContext"><code>WebGLRenderingContext</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGL2RenderingContext"><code>WebGL2RenderingContext</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLActiveInfo"><code>WebGLActiveInfo</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLBuffer"><code>WebGLBuffer</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLContextEvent"><code>WebGLContextEvent</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLFramebuffer"><code>WebGLFramebuffer</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLProgram"><code>WebGLProgram</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLQuery"><code>WebGLQuery</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLRenderbuffer"><code>WebGLRenderbuffer</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLSampler"><code>WebGLSampler</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLShader"><code>WebGLShader</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLShaderPrecisionFormat"><code>WebGLShaderPrecisionFormat</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLSync"><code>WebGLSync</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLTexture"><code>WebGLTexture</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLTransformFeedback"><code>WebGLTransformFeedback</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLUniformLocation"><code>WebGLUniformLocation</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLVertexArrayObject"><code>WebGLVertexArrayObject</code></a></li>
      </ol>
    </details>
  </li>

  <li><strong><a href="/ru/docs/MDN">Доментация:</a></strong></li>
  <li class="toggle">
    <details>
      <summary>Полезные списки</summary>
      <ol>
        <li><a href="/ru/docs/tag/WebGL">Страницы отмеченные &quot;WebGL&quot;</a></li>
      </ol>
    </details>
  </li>
  <li class="toggle">
    <details>
      <summary>Внести вклад</summary>
      <ol>
        <li><a href="/ru/docs/MDN/Doc_status/API/WebGL">Стутус документации WebGL</a></li>
        <li><a href="/ru/docs/MDN">Проект MDN</a></li>
      </ol>
    </details>
  </li>
 </ol>
</section> <div style="text-align: right;" class="prevnext">
    <p><a style="float: left;" href="/ru/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL" class="button">« Предыдущая статья</a><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Using_shaders_to_apply_color_in_WebGL" class="button">Следующая статья  »</a></p>
</div><p></p>

<p>После того, как вы успешно <a href="/ru/docs/Web/WebGL/Getting_started_with_WebGL" title="en/WebGL/Getting started with WebGL">создали контекст WebGL</a>, вы можете начинать отображать в нем графические объекты. Простейшая вещь, которую вы можете сделать - отрисовать простой квадрат без текстуры. Итак, начнём построение кода для отрисовки квадрата.</p>

<h2 id="Отрисовка_сцены">Отрисовка сцены</h2>

<p>На данном этапе очень важно понять одну вещь: не смотря на то, что мы в этом примере отрисовываем двухмерный объект, мы по-прежнему отрисовываем его в трехмерном пространстве. По существу, нам по-прежнему необходимо создать шейдеры, которые будут освещать нашу простую сцену,  и отрисовать наш объект. На данном шаге определим как квадрат будет освещаться.</p>

<h3 id="Инициализация_шейдеров">Инициализация шейдеров</h3>

<p>Шейдеры задаются при помощи языка высокого уровня для программирования шейдеров - <a href="http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf" class="external" title="http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf">OpenGL ES Shading Language</a>. Для того, чтобы сделать проще процесс поддержки и обновления нашего контента, мы можем фактически написать наш код, загружающий шейдеры и помещающий их в HTML документ, вместо того, чтобы встраивать его весь в JavaScript. Давайте рассмотрим нашу процедуру <code>initShaders()</code>, которая выполнит эту задачу:</p>

<pre class="brush: js">function initShaders() {
  var fragmentShader = getShader(gl, &quot;shader-fs&quot;);
  var vertexShader = getShader(gl, &quot;shader-vs&quot;);

  // создать шейдерную программу

  shaderProgram = gl.createProgram();
  gl.attachShader(shaderProgram, vertexShader);
  gl.attachShader(shaderProgram, fragmentShader);
  gl.linkProgram(shaderProgram);

  // Если создать шейдерную программу не удалось, вывести предупреждение

  if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
    alert(&quot;Unable to initialize the shader program.&quot;);
  }

  gl.useProgram(shaderProgram);

  vertexPositionAttribute = gl.getAttribLocation(shaderProgram, &quot;aVertexPosition&quot;);
  gl.enableVertexAttribArray(vertexPositionAttribute);
}

</pre>

<p>Этой процедурой загружаются две шейдерные программы. Первая - фрагментный шейдер, загружается из элемента <a href="/en/HTML/Element/Script" title="En/HTML/Element/Script"><code>script</code></a> с ID &quot;shader-fs&quot;. Вторая - вершинный шейдер, загружается из элемента <a href="/en/HTML/Element/Script" title="En/HTML/Element/Script"><code>script</code></a> с ID &quot;shader-vs&quot;. Мы рассмотрим функцию <code>getShader()</code> чуть ниже. Эта процедура фактически отвечает за извлечение шейдерных программ из DOM.</p>

<p>Затем мы создаем шейдерную программу, вызывая функцию <code>createProgram()</code> объекта WebGL, присоединяя два шейдера к нему, и связывая шейдерную программу. После выполнения этого, проверяется значение параметра <code>LINK_STATUS</code> объекта <code>gl</code> для того, чтобы убедиться, что программа успешно скомпанована. Если это так, мы активируем новую шейдерную программу.</p>

<h3 id="Загрузка_шейдеров_из_DOM">Загрузка шейдеров из DOM</h3>

<p>Функция <code>getShader()</code> получает из DOM шейдерную программу с определенным именем, возвращая скомпилированную шейдерную программу вызывающему, или значение null, если шейдерная программа не может быть загружена или скомпилирована.</p>

<pre class="brush: js">function getShader(gl, id) {
  var shaderScript, theSource, currentChild, shader;

  shaderScript = document.getElementById(id);

  if (!shaderScript) {
    return null;
  }

  theSource = &quot;&quot;;
  currentChild = shaderScript.firstChild;

  while(currentChild) {
    if (currentChild.nodeType == currentChild.TEXT_NODE) {
      theSource += currentChild.textContent;
    }

    currentChild = currentChild.nextSibling;
  }
</pre>

<p>Как только элемент с указанным ID найден, его текст помещается в переменную <code>theSource</code>.</p>

<pre class="brush: js">  if (shaderScript.type == &quot;x-shader/x-fragment&quot;) {
    shader = gl.createShader(gl.FRAGMENT_SHADER);
  } else if (shaderScript.type == &quot;x-shader/x-vertex&quot;) {
    shader = gl.createShader(gl.VERTEX_SHADER);
  } else {
     // неизвестный тип шейдера
     return null;
  }</pre>

<p>После того, как код для шейдера считан, мы проверяем MIME тип шейдерного объекта, чтобы определить является он вершинным (MIME type &quot;x-shader/x-vertex&quot;) или фрагментным (MIME type &quot;x-shader/x-fragment&quot;) шейдером, а затем создаем соответствующий тип шейдера из полученного исходного кода.</p>

<pre class="brush: js">  gl.shaderSource(shader, theSource);

  // скомпилировать шейдерную программу
  gl.compileShader(shader);

  // Проверить успешное завершение компиляции
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      alert(&quot;An error occurred compiling the shaders: &quot; + gl.getShaderInfoLog(shader));
      return null;
  }

  return shader;
}
</pre>

<p>В результате, исходный код, передан в переменную shader и скомпилирован. Если произошли ошибки во время компиляции кода шейдера, мы отображаем окно с предупреждением и возвращаем значение null; Иначе, возвращается новый скомпилированный шейдер.</p>

<h3 id="Шейдеры">Шейдеры</h3>

<p>После этого нам необходимо добавить шейдерные программы в HTML описывающий наш документ. Подробная информация о том, как работают шейдеры выходит за рамки этой статьи, как и впрочем описание синтаксиса языка программирования шейдеров.</p>

<h4 id="Фрагментный_шейдер">Фрагментный шейдер</h4>

<p>Каждый пиксель в полигоне называется <strong>фрагментом</strong> в языке GL. Фрагментные шейдеры необходимы для назначения цвета для каждого пикселя. В данном случае, мы просто назначаем белый цвет каждому пикселю.</p>

<p><code>gl_FragColor</code> - встроенная переменная GL, используемая для управления цветом фрагментов. Устанавливая ее значение назначаем цвет пикселям. Ниже приведен пример этого.</p>

<pre class="brush: html">&lt;script id=&quot;shader-fs&quot; type=&quot;x-shader/x-fragment&quot;&gt;
  void main(void) {
    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
  }
&lt;/script&gt;
</pre>

<h4 id="Вершинный_шейдер">Вершинный шейдер</h4>

<p>Вершинный шейдер определяет положение и форму каждой вершины.</p>

<pre class="brush: html">&lt;script id=&quot;shader-vs&quot; type=&quot;x-shader/x-vertex&quot;&gt;
  attribute vec3 aVertexPosition;

  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;

  void main(void) {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
  }
&lt;/script&gt;
</pre>

<h2 id="Создание_объекта">Создание объекта</h2>

<p>Перед тем, как мы отрисуем наш квадрат, нам необходимо создать буфер, который содержит его вершины. Мы сделаем это,  вызвав функцию <code>initBuffers().</code> По мере ознакомления с другими концепциями WebGL, эта функция будет усложняться при создании более сложных трехмерных объектов.</p>

<pre class="brush: js">var horizAspect = 480.0/640.0;

function initBuffers() {
  squareVerticesBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, squareVerticesBuffer);

  var vertices = [
    1.0,  1.0,  0.0,
    -1.0, 1.0,  0.0,
    1.0,  -1.0, 0.0,
    -1.0, -1.0, 0.0
  ];

  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
}
</pre>

<p>В этом примере эта функция упрощена и дает оценить основную суть сцены. Она начинает работу с вызова метода <code>createBuffer()</code> объекта <code>gl</code> для получения буфера, в котором мы будем хранить вершины. Затем он привязывается к контексту, вызовом метода <code>bindBuffer()</code>.</p>

<p>После того, как мы это сделали, мы создаем JavaScript массив, содержащий координаты для каждой вершины квадрата. Затем этот массив преобразуется в массив вещественных чисел WebGL и передается в метод <code>bufferData()</code> объекта <code>gl</code> для назначения вершин объекту.</p>

<h2 id="Отрисовка_сцены_2">Отрисовка сцены</h2>

<p>Как только шейдеры установлены и объект создан, мы можем действительно отрисовать сцену. Поскольку в этом примере нет какой-либо анимации, наша функция <code>drawScene()</code> имеет очень простой вид. Она использует несколько утилитарных процедур, которые мы кратко рассмотрим ниже.</p>

<pre class="brush: js">function drawScene() {
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  perspectiveMatrix = makePerspective(45, 640.0/480.0, 0.1, 100.0);

  loadIdentity();
  mvTranslate([-0.0, 0.0, -6.0]);

  gl.bindBuffer(gl.ARRAY_BUFFER, squareVerticesBuffer);
  gl.vertexAttribPointer(vertexPositionAttribute, 3, gl.FLOAT, false, 0, 0);
  setMatrixUniforms();
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}
</pre>

<p>Первый шаг - очистка цветом фона сцены контекста. Затем мы устанавливаем перспективу камеры. Мы устанавливаем угол обзора в 45°, с соотношением ширины к высоте равным 640/480 (размеры нашего объекта canvas). Мы также определяем, что мы хотим видеть отрисованными объекты на расстоянии от 0.1 до 100 единиц от камеры.</p>

<p>Затем мы устанавливаем позицию квадрата, загружая определенную позицию и размещая ее от камеры на 6 единиц. После этого, мы привязываем буфер, содержащий вершины квадрата к контексту, настраиваем его, и отрисовываем объект, вызывая метод <code>drawArrays()</code>.</p>

<p>Вы можете <a href="/samples/webgl/sample2" title="https://developer.mozilla.org/samples/webgl/sample2">посмотреть как это работает щелкнув по этой ссылке</a>. Но это только в том случае, если используемый браузер осуществляет поддержку WebGL.</p>

<h2 id="Операции_над_матрицами">Операции над матрицами</h2>

<p>Операции над матрицами достаточно сложны. Никому бы не хотелось самому писать весь код для работы с ними. К счастью, есть <a href="http://sylvester.jcoglan.com/" class="external" title="http://sylvester.jcoglan.com/">Sylvester</a> - очень удобная библиотека для выполнения операций над векторами и матрицами, написанная на JavaScript.</p>

<p>Файл <code>glUtils.js</code>, используемый в этом примере, используется большинством примеров на WebGL, размещенных в сети интернет. Никто не знает точно откуда он появился. Он просто используется Sylvester и он даже пополняется методами для построения специальных типов матриц, а также вывода HTML для их отображения.</p>

<p>Также, этот пример определяет несколько полезных процедур взаимодействия с этими библиотеками для выполнения определенных задач. Пояснения относительно того, что делает каждая из приведенных функций, выходят за рамки этого примера, но в сети есть много хороших материалов об операциях над матрицами. Чуть <a href="#ниже">ниже</a> есть список некоторых из них.</p>

<pre class="brush: js">function loadIdentity() {
  mvMatrix = Matrix.I(4);
}

function multMatrix(m) {
  mvMatrix = mvMatrix.x(m);
}

function mvTranslate(v) {
  multMatrix(Matrix.Translation($V([v[0], v[1], v[2]])).ensure4x4());
}

function setMatrixUniforms() {
  var pUniform = gl.getUniformLocation(shaderProgram, &quot;uPMatrix&quot;);
  gl.uniformMatrix4fv(pUniform, false, new Float32Array(perspectiveMatrix.flatten()));

  var mvUniform = gl.getUniformLocation(shaderProgram, &quot;uMVMatrix&quot;);
  gl.uniformMatrix4fv(mvUniform, false, new Float32Array(mvMatrix.flatten()));
}
</pre>

<h2 id="Смотрите_также">Смотрите также</h2>

<ul>
 <li><a href="http://mathworld.wolfram.com/Matrix.html" class="external" title="http://mathworld.wolfram.com/Matrix.html">Матрицы</a> на Wolfram MathWorld</li>
 <li><a href="http://en.wikipedia.org/wiki/Matrix_(mathematics)" class="external" title="http://en.wikipedia.org/wiki/Matrix_(mathematics)">Матрица</a> (Wikipedia)</li>
</ul>

<p></p><div style="text-align: right;" class="prevnext">
    <p><a style="float: left;" href="/ru/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL" class="button">« Предыдущая статья</a><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Using_shaders_to_apply_color_in_WebGL" class="button">Следующая статья  »</a></p>
</div><p></p>

---
title: Using textures in WebGL
slug: Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL
translation_of: Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL
---
<section id="Quick_Links">
 <ol>
  <li><a href="/ru/docs/Web/API/WebGL_API"><strong>WebGL API</strong></a></li>
  <li class="toggle">
    <details open>
      <summary>Руководство WebGL</summary>
      <ol>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL">Начало работы с WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Adding_2D_content_to_a_WebGL_context">Добавление двухмерного контента в контекст WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Using_shaders_to_apply_color_in_WebGL">Использование шейдеров для задания цвета в WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Animating_objects_with_WebGL">Оживление объектов при помощи WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Creating_3D_objects_using_WebGL">Создание 3D с помощью WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL">Использование текстур WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Lighting_in_WebGL">Освещение WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Animating_textures_in_WebGL">Анимация текстур WebGL</a></li>
      </ol>
    </details>
  </li>
  <li class="toggle">
    <details open>
      <summary>Примеры и статьи</summary>
      <ol>
        <li><a href="/ru/docs/Web/API/WebGL_API/Matrix_math_for_the_web">Математическая матрица для Веба</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/WebGL_model_view_projection">WebGL модель, представление, проекция</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/WebGL_best_practices">WebGL лучшие практики</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Using_Extensions">Использование расширений WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Basic_2D_animation_example">A basic 2D WebGL animation example</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/By_example">WebGL by example</a></li>
      </ol>
    </details>
  </li>
  <li class="toggle">
    <details open>
      <summary>Интерфейсы</summary>
      <ol>
        <li><a href="/ru/docs/Web/API/WebGLRenderingContext"><code>WebGLRenderingContext</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGL2RenderingContext"><code>WebGL2RenderingContext</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLActiveInfo"><code>WebGLActiveInfo</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLBuffer"><code>WebGLBuffer</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLContextEvent"><code>WebGLContextEvent</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLFramebuffer"><code>WebGLFramebuffer</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLProgram"><code>WebGLProgram</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLQuery"><code>WebGLQuery</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLRenderbuffer"><code>WebGLRenderbuffer</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLSampler"><code>WebGLSampler</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLShader"><code>WebGLShader</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLShaderPrecisionFormat"><code>WebGLShaderPrecisionFormat</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLSync"><code>WebGLSync</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLTexture"><code>WebGLTexture</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLTransformFeedback"><code>WebGLTransformFeedback</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLUniformLocation"><code>WebGLUniformLocation</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLVertexArrayObject"><code>WebGLVertexArrayObject</code></a></li>
      </ol>
    </details>
  </li>

  <li><strong><a href="/ru/docs/MDN">Доментация:</a></strong></li>
  <li class="toggle">
    <details>
      <summary>Полезные списки</summary>
      <ol>
        <li><a href="/ru/docs/tag/WebGL">Страницы отмеченные &quot;WebGL&quot;</a></li>
      </ol>
    </details>
  </li>
  <li class="toggle">
    <details>
      <summary>Внести вклад</summary>
      <ol>
        <li><a href="/ru/docs/MDN/Doc_status/API/WebGL">Стутус документации WebGL</a></li>
        <li><a href="/ru/docs/MDN">Проект MDN</a></li>
      </ol>
    </details>
  </li>
 </ol>
</section> <div class="prevnext" style="text-align: right;">
    <p><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Creating_3D_objects_using_WebGL" style="float: left;" class="button">« Предыдущая статья</a><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Lighting_in_WebGL" class="button">Следующая статья  »</a></p>
</div>

<p>Сейчас наша программа рисует вращающийся объемный куб - давайте натянем на него текстуру вместо заливки граней одним цветом.</p>

<h2 id="Загрузка_текстур">Загрузка текстур</h2>

<p>Сначала нужно добавить код для загрузки текстур. В нашем случае мы будем использовать одну текстуру, натянутую на все шесть граней вращающегося куба, но этот подход может быть использован для загрузки любого количества текстур.</p>

<div class="note notecard">
<p><strong>Обратите внимание:</strong> Важно помнить, что загрузка текстур следует <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS">правилам кросс-доменности</a>, что означает, что вы можете загружать текстуры только с сайтов, для которых ваш контент является CORS доверенным. См. подробности в секции &quot;Кросс-доменные текстуры&quot; ниже.</p>
</div>

<p>Код для загрузки текстур выглядит так::</p>

<pre><code>//
// Инициализация текстуры и загрузка изображения.
// Когда загрузка изображения завершена - копируем его в текстуру.
//
function loadTexture(gl, url) {
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);

  // Так как изображение будет загружено из интернета,
  // может потребоваться время для полной загрузки.
  // Поэтому сначала мы </code>помещаем <code>в текстуру единственный пиксель, чтобы
  // её можно было использовать сразу. После завершения загрузки
  // изображения мы обновим текстуру.
  const level = 0;
  const internalFormat = gl.RGBA;
  const width = 1;
  const height = 1;
  const border = 0;
  const srcFormat = gl.RGBA;
  const srcType = gl.UNSIGNED_BYTE;
  const pixel = new Uint8Array([0, 0, 255, 255]);  // непрозрачный синий
  gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                width, height, border, srcFormat, srcType,
                pixel);

  const image = new Image();
  image.onload = function() {
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, level, internalFormat,
                  srcFormat, srcType, image);

    // У WebGL1 иные требования к изображениям, имеющим размер степени 2,
    // и к не имеющим размер степени 2, поэтому проверяем, что изображение
    // имеет размер степени 2 в обеих измерениях.
    if (isPowerOf2(image.width) &amp;&amp; isPowerOf2(image.height)) {
       // Размер соответствует степени 2. Создаем MIP&apos;ы.
       gl.generateMipmap(gl.TEXTURE_2D);
    } else {
       // Размер не соответствует степени 2.
       // Отключаем MIP&apos;ы и устанавливаем натяжение по краям
       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
       gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    }
  };
  image.src = url;

  return texture;
}

function isPowerOf2(value) {
  return (value &amp; (value - 1)) == 0;
}</code></pre>

<p>Функция <code>loadTexture()</code> начинается с создания объекта WebGL <code>texture</code> вызовом функции <a href="/ru/docs/Web/API/WebGLRenderingContext/createTexture" title="Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!"><code>createTexture()</code></a>. Сначала функция создает текстуру из единственного голубого пикселя, используя <a href="/ru/docs/Web/API/WebGLRenderingContext/texImage2D" title="Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!"><code>texImage2D()</code></a>. Таким образом текстура может быть использована сразу (как сплошной голубой цвет) при том, что загрузка изображения может занять некоторое время.</p>

<p>Чтобы загрузить текстуру из файла изображения, функция создает объект <code>Image</code> и присваивает атрибуту <code>src</code> адрес, с которого мы хотим загрузить текстуру. Функция, которую мы назначили на событие <code>image.onload</code>,будет вызвана после завершения загрузки изображения. В этот момент мы вызываем <a href="/ru/docs/Web/API/WebGLRenderingContext/texImage2D" title="Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!"><code>texImage2D()</code></a>, используя загруженное изображение как исходник для текстуры. Затем мы устанавливаем фильтрацию и натяжение, исходя из того, является ли размер изображения степенью 2 или нет.</p>

<p>В WebGL1 изображения размера, не являющегося степенью 2, могут использовать только <code>NEAREST</code> или <code>LINEAR</code> фильтрацию, и для них нельзя создать mipmap. Также для таких изображений мы должны установить натяжение <code>CLAMP_TO_EDGE</code>. С другой стороны, если изображение имеет размер степени 2 по обеим осям, WebGL может производить более качественную фильтрацию, использовать mipmap и режимы натяжения <code>REPEAT</code> или <code>MIRRORED_REPEAT</code>.</p>

<p>Примером повторяющейся текстуры является изображение нескольких кирпичей, которое размножается для покрытия поверхности и создания изображения кирпичной стены.</p>

<p>Мипмаппинг и UV-повторение могут быть отключены с помощью <a href="/ru/docs/Web/API/WebGLRenderingContext/texParameter" title="Документация об этом ещё не написана; пожалуйста, поспособствуйте её написанию!"><code>texParameteri()</code></a>. Так вы сможете использовать текстуры с размером, не являющимся степенью 2 (NPOT - non-power-of-two), ценой отключения мипмаппинга, UV-натяжения, UV-повторения, и вам самому придется контролировать, как именно устройство будет обрабатывать текстуру.</p>

<pre><code>// также разрешено gl.NEAREST вместо gl.LINEAR, но не mipmap.
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
// Не допускаем повторения по s-координате.
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
// Не допускаем повторения по t-координате.
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);</code></pre>

<p>Повторим, что с этими параметрами совместимые WebGL устройства будут допускать использование текстур с любым разрешением (вплоть до максимального). Без подобной настройки WebGL потерпит неудачу при загрузке NPOT-текстур, и вернёт прозрачный черный цвет <code>rgba(0,0,0,0)</code>.</p>

<p>Для загрузки изображения добавим вызов <code>loadTexture()</code> в функцию <code>main()</code>. Код можно разместить после вызова <code>initBuffers(gl)</code>.</p>

<pre><code>// Загрузка текстуры
const texture = loadTexture(gl, &apos;cubetexture.png&apos;);</code></pre>

<h2 id="Отображение_текстуры_на_гранях">Отображение текстуры на гранях</h2>

<p>Сейчас текстура загружена и готова к использованию. Но сначала мы должны установить соответствие между координатами текстуры и гранями нашего куба. Нужно заменить весь предыдущий код, который устанавливал цвета граней в <code>initBuffers()</code>.</p>

<pre><code>  const textureCoordBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordBuffer);

  const textureCoordinates = [
    // Front
    0.0,  0.0,
    1.0,  0.0,
    1.0,  1.0,
    0.0,  1.0,
    // Back
    0.0,  0.0,
    1.0,  0.0,
    1.0,  1.0,
    0.0,  1.0,
    // Top
    0.0,  0.0,
    1.0,  0.0,
    1.0,  1.0,
    0.0,  1.0,
    // Bottom
    0.0,  0.0,
    1.0,  0.0,
    1.0,  1.0,
    0.0,  1.0,
    // Right
    0.0,  0.0,
    1.0,  0.0,
    1.0,  1.0,
    0.0,  1.0,
    // Left
    0.0,  0.0,
    1.0,  0.0,
    1.0,  1.0,
    0.0,  1.0,
  ];

  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates),
                gl.STATIC_DRAW);

...
  return {
    position: positionBuffer,
    textureCoord: textureCoordBuffer,
    indices: indexBuffer,
  };</code></pre>

<p>Сначала мы создаем WebGL буфер, в котором сохраняем координаты текстуры для каждой грани, затем связываем его с массивом, в который будем записывать значения.</p>

<p>Массив <code>textureCoordinates</code> определяет координаты текстуры, соответствующие каждой вершине каждой грани. Заметьте, что координаты текстуры лежат в промежутке между 0.0 и 1.0. Размерность текстуры нормализуется в пределах между 0.0 и 1.0, независимо от реального размера изображения.</p>

<p>После опредения массива координат текстуры, мы копируем его в буфер, и теперь WebGL имеет данные для отрисовки.</p>

<h2 id="Обновление_шейдеров">Обновление шейдеров</h2>

<p>Мы должны обновить шейдерную программу, чтобы она использовала текстуру, а не цвета.</p>

<h3 id="Вершинный_шейдер">Вершинный шейдер</h3>

<p>Заменяем вершинный шейдер, чтобы он получал координаты текстуры вместо цвета.</p>

<pre><code>  const vsSource = `
    attribute vec4 aVertexPosition;
    attribute vec2 aTextureCoord;

    uniform mat4 uModelViewMatrix;
    uniform mat4 uProjectionMatrix;

    varying highp vec2 vTextureCoord;

    void main(void) {
      gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
      vTextureCoord = aTextureCoord;
    }
  `;</code></pre>

<p>Ключевое изменение в том, что вместо получения цвета вершины, мы получаем координаты текстуры и передаем их в вершинный шейдер, сообщая положение точки внутри текстуры, которая соответствует вершине.</p>

<h3 id="Фрагментный_шейдер">Фрагментный шейдер</h3>

<p>Также нужно обновить фрагментный шейдер:</p>

<pre><code>  const fsSource = `
    varying highp vec2 vTextureCoord;

    uniform sampler2D uSampler;

    void main(void) {
      gl_FragColor = texture2D(uSampler, vTextureCoord);
    }
  `;</code></pre>

<p>Вместо задания цветового значения цвету фрагмента, цвет фрагмента рассчитывается из <strong>текселя</strong> (пикселя внутри текстуры), основываясь на значении <code>vTextureCoord</code>, которое интерполируется между вершинами (как ранее интерполировалось значение цвета).</p>

<h3 id="Атрибуты_и_uniform-переменные">Атрибуты и uniform-переменные</h3>

<p>Так как мы изменили атрибуты и добавили uniform-переменные, нам нужно получить их расположение</p>

<pre><code>  const programInfo = {
    program: shaderProgram,
    attribLocations: {
      vertexPosition: gl.getAttribLocation(shaderProgram, &apos;aVertexPosition&apos;),
      textureCoord: gl.getAttribLocation(shaderProgram, &apos;aTextureCoord&apos;),
    },
    uniformLocations: {
      projectionMatrix: gl.getUniformLocation(shaderProgram, &apos;uProjectionMatrix&apos;),
      modelViewMatrix: gl.getUniformLocation(shaderProgram, &apos;uModelViewMatrix&apos;),
      uSampler: gl.getUniformLocation(shaderProgram, &apos;uSampler&apos;),
    },
  };</code></pre>

<h2 id="Рисование_текстурированного_куба">Рисование текстурированного куба</h2>

<p>Сделаем несколько простых изменений в функции <code>drawScene()</code>.</p>

<p>Во-первых, удаляем код, который определял цветовые буферы, и заменяем его на:</p>

<pre><code>// Указываем WebGL, как извлечь текстурные координаты из буффера
{
    const num = 2; // каждая координата состоит из 2 значений
    const type = gl.FLOAT; // данные в буфере имеют тип 32 bit float
    const normalize = false; // не нормализуем
    const stride = 0; // сколько байт между одним набором данных и следующим
    const offset = 0; // стартовая позиция в байтах внутри набора данных
    gl.bindBuffer(gl.ARRAY_BUFFER, buffers.textureCoord);
    gl.vertexAttribPointer(programInfo.attribLocations.textureCoord, num, type, normalize, stride, offset);
    gl.enableVertexAttribArray(programInfo.attribLocations.textureCoord);
}</code></pre>

<p>Затем добавляем код, который отображает текстуру на гранях, прямо перед отрисовкой:</p>

<pre><code>  // Указываем WebGL, что мы используем текстурный регистр 0
  gl.activeTexture(gl.TEXTURE0);

  // Связываем текстуру с регистром 0
  gl.bindTexture(gl.TEXTURE_2D, texture);

  // Указываем шейдеру, что мы связали текстуру с текстурным регистром 0
  gl.uniform1i(programInfo.uniformLocations.uSampler, 0);</code></pre>

<p>WebGL имеет минимум 8 текстурных регистров; первый из них <code>gl.TEXTURE0</code>. Мы указываем, что хотим использовать регистр 0. Затем мы вызываем функцию <a href="/ru/docs/Web/API/WebGLRenderingContext/bindTexture" title="WebGLRenderingContext.bindTexture() метод WebGL API связывает WebGLTexture с target."><code>bindTexture()</code></a>, которая связывает текстуру с <code>TEXTURE_2D</code> регистра 0. Наконец мы сообщаем шейдеру, что для <code>uSampler</code> используется текстурный регистр 0.</p>

<p>В завершение, добавляем аргумент <code>texture</code> в функцию <code>drawScene()</code>.</p>

<pre><code>drawScene(gl, programInfo, buffers, texture, deltaTime);
...
function drawScene(gl, programInfo, buffers, texture, deltaTime) {</code></pre>

<p>Сейчас вращающийся куб должен именть текстуру на гранях.</p>



<p><iframe class="live-sample-frame" frameborder="0" height="510" src="https://mdn.github.io/webgl-examples/tutorial/sample6/index.html" width="670"></iframe></p>

<p><a href="https://github.com/mdn/webgl-examples/tree/gh-pages/tutorial/sample6">Посмотреть код примера полностью</a> | <a href="http://mdn.github.io/webgl-examples/tutorial/sample6/">Открыть демо в новом окне</a></p>

<h2 id="Кросс-доменные_текстуры">Кросс-доменные текстуры</h2>

<p>Загрузка кросс-доменных текстур контролируется правилами кросс-доменного доступа. Чтобы загрузить текстуру с другого домена, она должна быть CORS доверенной. См. детали в статье <a href="https://developer.mozilla.org/ru/docs/Web/HTTP/CORS">HTTP access control</a>.</p>

<p><a href="http://hacks.mozilla.org/2011/11/using-cors-to-load-webgl-textures-from-cross-domain-images/">В статье на hacks.mozilla.org</a> есть объяснение с <a href="http://people.mozilla.org/~bjacob/webgltexture-cors-js.html">примером</a>, как использовать изображения CORS для создания WebGL текстур.</p>

<div class="note notecard">
<p><strong>Обратите внимание:</strong> Поддержка CORS для текстур WebGL и атрибут <code>crossOrigin</code> для элементов изображений реализованы в <span title="(Firefox 8.0 / Thunderbird 8.0 / SeaMonkey 2.5)">Gecko 8.0</span>.</p>
</div>

<p>Tainted (только-для-записи) 2D canvas нельзя использовать в качестве текстур WebGL. Например, 2D <a href="/ru/docs/Web/HTML/Element/canvas" title="HTML &lt;canvas&gt; Элемент может быть использован для отрисовки графики через скрипты (обычно используется JavaScript). На пример, его можно использовать для отрисовки графиков, делать композиции фото или даже выполнять анимации. Вы можете (и должны) дать альтернативное содержание внури блока &lt;canvas&gt;. Этот контент будет рендерится в обоих браузерах, в старых которые не поддерживают canvas и в браузерах с отключённым JavaScript."><code>&lt;canvas&gt;</code></a> становится &quot;tainted&quot;, когда на ней отрисовано кросс-доменное изображение.</p>

<div class="note notecard">
<p><strong>Обратите внимание:</strong> Поддержка CORS для Canvas 2D <code>drawImage</code> реализована в  <span title="(Firefox 9.0 / Thunderbird 9.0 / SeaMonkey 2.6)">Gecko 9.0</span>. Это значит, что использование CORS доверенных кросс-доменных изображений больше не делает 2D canvas &quot;tained&quot; (только-для-записи),  и вы можете использовать такую 2D canvas как исходник для текстур WebGL.</p>
</div>

<div class="note notecard">
<p><strong>Обратите внимание:</strong> Поддрежка CORS для кросс-доменного видео и атрибут <code>crossorigin</code> для HTML-элемента <a href="/ru/docs/Web/HTML/Element/video" title="Для встраивания видео контента в документ используйте элемент HTML &lt;video&gt;. Видео элемент может содержать один или несколько источников видео. Чтобы указать источник видео, необходимо использовать атрибут src или элемент &lt;source&gt;; браузер сам определит наиболее подходящий источник."><code>&lt;video&gt;</code></a> реализованы в <span title="(Firefox 12.0 / Thunderbird 12.0 / SeaMonkey 2.9)">Gecko 12.0</span>.</p>
</div>

<div class="prevnext" style="text-align: right;">
    <p><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Creating_3D_objects_using_WebGL" style="float: left;" class="button">« Предыдущая статья</a><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Lighting_in_WebGL" class="button">Следующая статья  »</a></p>
</div>

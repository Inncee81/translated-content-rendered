---
title: Лучшие практики WebGL
slug: Web/API/WebGL_API/WebGL_best_practices
translation_of: Web/API/WebGL_API/WebGL_best_practices
---
<p></p><section id="Quick_Links">
 <ol>
  <li><a href="/ru/docs/Web/API/WebGL_API"><strong>WebGL API</strong></a></li>
  <li class="toggle">
    <details open>
      <summary>Руководство WebGL</summary>
      <ol>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Getting_started_with_WebGL">Начало работы с WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Adding_2D_content_to_a_WebGL_context">Добавление двухмерного контента в контекст WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Using_shaders_to_apply_color_in_WebGL">Использование шейдеров для задания цвета в WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Animating_objects_with_WebGL">Оживление объектов при помощи WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Creating_3D_objects_using_WebGL">Создание 3D с помощью WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL">Использование текстур WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Lighting_in_WebGL">Освещение WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Tutorial/Animating_textures_in_WebGL">Анимация текстур WebGL</a></li>
      </ol>
    </details>
  </li>
  <li class="toggle">
    <details open>
      <summary>Примеры и статьи</summary>
      <ol>
        <li><a href="/ru/docs/Web/API/WebGL_API/Matrix_math_for_the_web">Математическая матрица для Веба</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/WebGL_model_view_projection">WebGL модель, представление, проекция</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/WebGL_best_practices">WebGL лучшие практики</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Using_Extensions">Использование расширений WebGL</a></li>
        <li><a href="/ru/docs/Web/API/WebGL_API/Basic_2D_animation_example">A basic 2D WebGL animation example</a></li>
      </ol>
    </details>
  </li>
  <li class="toggle">
    <details open>
      <summary>Интерфейсы</summary>
      <ol>
        <li><a href="/ru/docs/Web/API/WebGLRenderingContext"><code>WebGLRenderingContext</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGL2RenderingContext"><code>WebGL2RenderingContext</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLActiveInfo"><code>WebGLActiveInfo</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLBuffer"><code>WebGLBuffer</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLContextEvent"><code>WebGLContextEvent</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLFramebuffer"><code>WebGLFramebuffer</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLProgram"><code>WebGLProgram</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLQuery"><code>WebGLQuery</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLRenderbuffer"><code>WebGLRenderbuffer</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLSampler"><code>WebGLSampler</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLShader"><code>WebGLShader</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLShaderPrecisionFormat"><code>WebGLShaderPrecisionFormat</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLSync"><code>WebGLSync</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLTexture"><code>WebGLTexture</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLTransformFeedback"><code>WebGLTransformFeedback</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLUniformLocation"><code>WebGLUniformLocation</code></a></li>
        <li><a href="/ru/docs/Web/API/WebGLVertexArrayObject"><code>WebGLVertexArrayObject</code></a></li>
      </ol>
    </details>
  </li>

  <li><strong><a href="/ru/docs/MDN">Доментация:</a></strong></li>
  <li class="toggle">
    <details>
      <summary>Полезные списки</summary>
      <ol>
        <li><a href="/ru/docs/tag/WebGL">Страницы отмеченные &quot;WebGL&quot;</a></li>
      </ol>
    </details>
  </li>
  <li class="toggle">
    <details>
      <summary>Внести вклад</summary>
      <ol>
        <li><a href="/ru/docs/MDN/Doc_status/API/WebGL">Стутус документации WebGL</a></li>
        <li><a href="/ru/docs/MDN">Проект MDN</a></li>
      </ol>
    </details>
  </li>
 </ol>
</section><p></p>

<p>Эта статья содержит советы и рекомендации по улучшению качества ваших WebGL приложений. Следование данным советам поможет улучшить совместимость ваших веб-приложений с большим количеством устройств и браузеров, а также увеличить их производительность.</p>

<h2 id="Чего_следует_избегать">Чего следует избегать</h2>

<ul>
 <li>Убедитесь, что ваше приложение не выдает какие-либо ошибки WebGL, возвращаемые функцией <code>getError(). В Firefox при каждой ошибке (до определенного предела) или при любой другой проблеме в работе WebGL выводится JavaScript предупреждение с подробным описанием. Вам же не хочется, что бы ваше приложение выдавало множество ошибок в консоль, не так ли?</code></li>
 <li>Не следует использовать <code>#ifdef GL_ES в шейдерах WebGL. Несмотря на то что в некоторых ранних примерах используются эти директивы, это не обязательно в том случае, если проверяемое условие всегда истинно.</code></li>
 <li>Использование высокой точности (<code>highp</code> precision) во фрагментных шейдерах может приводить к несовместимости вашего приложения с некоторыми устаревшими мобильными устройствами. Вы можете использовать среднюю точность (<code>mediump), но помните, что это может привести к некорректному результату отрисовки из-за потери данных на большинстве мобильных устройств, причем этот некорректный результат не будет заметен на обычном компьютере. В общем, только использование высокой точности (highp) в вершинном и фрагментном шейдерах является более надежными решением, если нет возможности тщательно проверить работу шейдеров на различных платформах. В Firefox версии 11 и выше реализована функция WebGL getShaderPrecisionFormat(), которая позволяет проверить, поддерживается ли высокая точность и, более того, запросить реальную точность всех поддерживаемых квалификаторов точности. </code></li>
</ul>

<h2 id="О_чем_следует_помнить.">О чем следует помнить.</h2>

<ul>
 <li>Некоторые возможности WebGL зависят от клиента. Перед тем как задействовать ту или иную возможность, используйте функцию WebGL <code>getParameter() чтобы определить, какие возможности поддерживаются на клиенте. Например, максимально допустимый размер двухмерной текстуры можно узнать с помощью вызова webgl.getParameter(webgl.MAX_TEXTURE_SIZE). В Firefox версии 10 и выше реализован параметр webgl.min_capability_mode, позволяющий имитировать минимальные значения возможностей WebGL для проверки переносимости приложения.</code></li>
 <li>В частности, использование текстур в вершинном шейдере возможно только если значение <code>webgl.getParameter(webgl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) больше ноля. Как правило, эта возможность не поддерживается на текущих мобильных устройствах.</code></li>
 <li>Доступность большинства расширений WebGL зависит от клиента. Если это возможно, проектируйте приложение так, чтобы оно оставалось работоспособным даже в случае, когда используемое расширение недоступно. В Firefox версии 10 и выше есть настройка<code> webgl.disable-extensions, позволяющая сымитировать отсутствие всех расширений для проверки переносимости приложения.</code></li>
 <li>Рендеринг в floating-point текстуру может не выполняться даже если расширение <code>OES_texture_float поддерживается. Обычно это случается на современных мобильных устройствах. Проверить эту возможность можно с помощью функции WebGL checkFramebufferStatus().</code></li>
 <li>Вы можете выполнять отрисовку на холсте, реальные размеры которого отличается от значений, определенных в таблице стилей. При проблемах с производительностью рассмотрите возможность рендеринга в более низком разрешении. (<em>Уменьшение области рендеринга ускорит обработку пиксельных шейдеров, например, эффектов постобработки</em>, <em>однако, на скорость работы вершинных шейдеров это не повлияет.</em> <span style="word-wrap: break-word;" class="forum_post_content med1"><span class="ln_height" id="post_text_1166974"><em>прим. перев.).</em></span></span></li>
</ul>

<h2 id="Общие_советы_по_повышению_производительности">Общие советы по повышению производительности</h2>

<ul>
 <li>Все, что требует синхронизации ЦП и ГП потенциально приводит в уменьшению производительности. Поэтому избегайте в цикле отрисовки следующих вызовов функций WebGL: <code>getError()</code>, <code>readPixels()</code> и <code>finish()</code>. Вызовы функций, получающих значения, такие как <code>getParameter()</code> и <code>getUniformLocation() тоже должны рассматриваться как медленные и их значения следует сохраняться в переменных JavaScript.</code></li>
 <li>Несколько больших операций отрисовки выполняются быстрее, чем много мелких. Если вам нужно нарисовать 1000 спрайтов, попробуйте реализовать это одним вызовом функции<code> drawArrays()</code> или <code>drawElements(). Вы также можете использовать вырожденные (плоские) треугольники для рисования нескольких объектов за один вызов drawArrays().</code></li>
 <li>Уменьшение переключений состояний также увеличивает производительность. В частности, если есть возможность упаковать несколько изображений в одну текстуру <em>(т.н. текстурный атлас, прим. перев.)</em> и отображать требуемое изображение с помощью поправок текстурных координат, то это приведет к уменьшению переключений между текстурами, что увеличит производительность.
  <ul>
   <li>В некоторых редких случаях разные одноцветные изображения можно упаковать в разные цветовые каналы текстуры.</li>
  </ul>
 </li>
 <li>Маленькие текстуры обрабатываются быстрее, чем большие. Используйте mipmapping для ускорения отрисовки.</li>
 <li>Простые шейдеры выполняются быстрее, чем сложные. В частности, условия (if) замедляют работу. Операции деления и математические функции, например, <code>log() должны также рассматриваться как дорогие.</code>
  <ul>
   <li>Однако сегодня даже мобильные устройства обладают мощными графическими процессорами которые способны быстро обрабатывать относительно сложные шейдерные программы. Более того, шейдеры компилируются в машинные коды, которые могут быть оптимизированы под конкретный процессор. Может оказаться, что дорогой вызов функции может быть скомпилирован в несколько (или даже в одну) процессорную инструкцию. Частично это справедливо для функций <a href="/ru/docs/Glossary/GLSL" class="glossaryLink" title="Определение термина «GLSL» ещё не написано; может быть, вы напишете?">GLSL</a>, выполняющих операции над векторами, таких как <code>normalize()</code>, <code>dot()</code> и <code>mix()</code>. Лучшим советом будет использовать встроенные функции, нежели пытаться реализовать, например, собственную версию скалярного произведения или линейной интерполяции, которые будут скомпилированы в набор сложных и неоптимальных инструкций процессора.</li>
  </ul>
 </li>
 <li>Выносите как можно больше операций в вершинный шейдер. Из-за того, что в процессе отрисовки фрагментные шейдеры выполняются гораздо чаще, чем вершинные, любые вычисления, которые можно выполнить с вершинами и интерполировать между пикселями, будут работать быстрее (интерполяция будет &quot;бесплатна&quot;, т.к. это этап конвеера WebGL). Например, простая анимация текстурированной поверхности может быть реализована с помощью преобразований текстурных координат (простейший вариант - прибавлять значение uniform-вектора к attribute-вектору текстурных координат). Если результат будет визуально приемлем, то такой вариант будет работать быстрее, чем реализация во фрагментном шейдере.</li>
 <li>Всегда задействуйте атрибут вершин c нулевым индексом. Отрисовка с неактивным вершинным атрибутом с индексом 0 вынуждает браузер выполнять сложную эмуляцию настольного OpenGL (например, как на Mac OSX). Вызывайте функцию <code>bindAttribLocation()</code> чтобы вершинный атрибут использовал нулевой индекс и активируйте сам атрибут с помощью функции<code> enableVertexAttribArray().</code></li>
</ul>

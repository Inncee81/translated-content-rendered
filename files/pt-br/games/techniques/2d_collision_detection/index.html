---
title: Detecção de Colisão 2D
slug: Games/Techniques/2D_collision_detection
translation_of: Games/Techniques/2D_collision_detection
---
<div><section class="Quick_links" id="Quick_Links">
  <ol>
    <li class="toggle">
        <details>
            <summary>Introdução</summary>
            <ol>
              <li><a href="/pt-BR/docs/Games/Introduction">Introdução</a></li>
              <li><a href="/pt-BR/docs/Games/Anatomy">Anatomia de um video game</a></li>
              <li><a href="/pt-BR/docs/Games/Examples">Exemplos</a></li>
            </ol>
        </details>
    </li>
    <li class="toggle">
        <details>
            <summary>APIs para desenvolvimento de jogos</summary>
            <ol>
              <li><a href="/pt-BR/docs/Web/API/Canvas_API">Canvas</a></li>
              <li><a href="/pt-BR/docs/Web/CSS">CSS</a></li>
              <li><a href="/pt-BR/docs/Web/Apps/Fundamentals/User_notifications/Full_screen_api">Full screen</a></li>
              <li><a href="/pt-BR/docs/Web/API/Gamepad_API">Gamepad</a></li>
              <li><a href="/pt-BR/docs/Web/API/IndexedDB_API">IndexedDB</a></li>
              <li><a href="/pt-BR/docs/Web/JavaScript">JavaScript</a></li>
              <li><a href="/pt-BR/docs/Web/API/Pointer_Lock_API">Pointer Lock</a></li>
              <li><a href="/pt-BR/docs/Web/SVG">SVG</a></li>
              <li><a href="/pt-BR/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">Typed Arrays</a></li>
              <li><a href="/pt-BR/docs/Web/API/Web_Audio_API">Web Audio</a></li>
              <li><a href="/pt-BR/docs/Web/API/WebGL_API">WebGL</a></li>
              <li><a href="/pt-BR/docs/Web/API/WebRTC_API">WebRTC</a></li>
              <li><a href="/pt-BR/docs/Web/API/WebSockets_API">WebSockets</a></li>
              <li><a href="/pt-BR/docs/Web/API/WebVR_API">WebVR</a></li>
              <li><a href="/pt-BR/docs/Web/API/Web_Workers_API">Web Workers</a></li>
              <li><a href="/pt-BR/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a></li>
            </ol>
        </details>
    </li>
    <li class="toggle">
        <details>
            <summary>Técnicas</summary>
            <ol>
              <li><a href="/pt-BR/docs/Games/Techniques/Async_scripts">Usando async scripts para&amp;nbsp;asm.js</a></li>
              <li><a href="/pt-BR/docs/Web/Apps/Developing/Optimizing_startup_performance">Otimizando a performance de startup</a></li>
              <li><a href="/pt-BR/docs/Games/Techniques/WebRTC_data_channels">Usando canais de dados WebRTC peer-to-peer</a></li>
              <li><a href="/pt-BR/docs/Games/Techniques/Efficient_animation_for_web_games">Animação eficiente para jogos web</a></li>
              <li><a href="/pt-BR/docs/Games/Techniques/Audio_for_Web_Games">Audio para Jogos Web</a></li>
              <li><a href="/pt-BR/docs/Games/Techniques/2D_collision_detection">Detecção de colisão 2D</a></li>
              <li><a href="/pt-BR/docs/Games/Techniques/Tilemaps">Visão geral de Tiles e tilemaps</a></li>
            </ol>
        </details>
    </li>
    <li class="toggle">
        <details>
            <summary>Visão geral de jogos 3D na Web</summary>
            <ol>
              <li><a href="/pt-BR/docs/Games/Techniques/3D_on_the_web">Visão geral de jogos 3D na Web</a></li>
              <li><a href="/pt-BR/docs/Games/Techniques/3D_on_the_web/Basic_theory">Explicando teoria básica 3D</a></li>
              <li><a href="/pt-BR/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_A-Frame">Desenvolvendo um demo básico com A-Frame</a></li>
              <li><a href="/pt-BR/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Babylon.js">Desenvolvendo um demo básico com Babylon.js</a></li>
              <li><a href="/pt-BR/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_PlayCanvas">Desenvolvendo um demo básico com PlayCanvas</a></li>
              <li><a href="/pt-BR/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Three.js">Desenvolvendo um demo básico com Three.js</a></li>
              <li><a href="/pt-BR/docs/Games/Techniques/3D_on_the_web/WebVR">WebVR</a></li>
              <li><a href="/pt-BR/docs/Games/Techniques/3D_collision_detection">Detecção de colisão 3D</a></li>
              <li><a href="/pt-BR/docs/Games/Techniques/3D_collision_detection/Bounding_volume_collision_detection_with_THREE.js">BDetecção da quantidade de&amp;nbsp;choque de colisão com THREE.js</a></li>
            </ol>
        </details>
    </li>
    <li class="toggle">
        <details>
            <summary>Implementando mecanismos de controle de jogo</summary>
            <ol>
              <li><a href="/pt-BR/docs/Games/Techniques/Control_mechanisms">Visão geral de mecanismos de controle de jogo</a></li>
              <li><a href="/pt-BR/docs/Games/Techniques/Control_mechanisms/Mobile_touch">Controles de toque Mobile</a></li>
              <li><a href="/pt-BR/docs/Games/Techniques/Control_mechanisms/Desktop_with_mouse_and_keyboard">Controles de rato e teclado em Desktop</a></li>
              <li><a href="/pt-BR/docs/Games/Techniques/Control_mechanisms/Desktop_with_gamepad">Controle de gamepad em Desktop</a></li>
              <li><a href="/pt-BR/docs/Games/Techniques/Control_mechanisms/Other">Other</a></li>
            </ol>
        </details>
    </li>
    <li class="toggle">
        <details>
            <summary>Tutoriais</summary>
            <ol>
              <li><a href="/pt-BR/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript">Jogo 2D usando JavaScript puro</a></li>
              <li><a href="/pt-BR/docs/Games/Tutorials/2D_breakout_game_Phaser">Jogo 2D usando Phaser</a></li>
              <li><a href="/pt-BR/docs/Games/Tutorials/HTML5_Gamedev_Phaser_Device_Orientation">Jogo labirinto 2D com device orientation</a></li>
              <li><a href="https://mozdevs.github.io/html5-games-workshop/en/guides/platformer/start-here/">Plataforma de jogo 2D usando Phaser</a></li>
            </ol>
        </details>
    </li>
    <li class="toggle">
        <details>
            <summary>Publicando jogos</summary>
            <ol>
              <li><a href="/pt-BR/docs/Games/Publishing_games">Visão geral sobre publicação de jogos</a></li>
              <li><a href="/pt-BR/docs/Games/Publishing_games/Game_distribution">Distribuição de Jogos</a></li>
              <li><a href="/pt-BR/docs/Games/Publishing_games/Game_promotion">Promoção de Jogos</a></li>
              <li><a href="/pt-BR/docs/Games/Publishing_games/Game_monetization">Monetização de Jogos</a></li>
            </ol>
        </details>
    </li>
  </ol>
</section></div>



<div class="summary">
<p>Algoritmos para detectar colisões em jogos 2D dependem do tipo de formas que podem colidir (por exemplo, retângulo para retângulo, retângulo para círculo, círculo para círculo). Geralmente, você terá uma forma genérica simples que abrange a entidade conhecida como &quot;hitbox&quot;, portanto, mesmo que a colisão não seja perfeita, ela terá boa aparência e terá bom desempenho em várias entidades. Este artigo fornece uma revisão das técnicas mais comuns usadas para fornecer detecção de colisão em jogos 2D.</p>
</div>

<h2 id="Caixa_delimitadora_alinhada_por_eixo">Caixa delimitadora alinhada por eixo</h2>

<p>Uma das formas mais simples de detecção de colisão é entre dois retângulos alinhados no eixo — ou seja, sem rotação. O algoritmo funciona garantindo que não haja nenhum espaço entre os 4 lados dos retângulos. Qualquer lacuna significa que uma colisão não existe.</p>

<pre class="brush: js notranslate">var rect1 = {x: 5, y: 5, width: 50, height: 50}
var rect2 = {x: 20, y: 10, width: 10, height: 10}

if (rect1.x &lt; rect2.x + rect2.width &amp;&amp;
   rect1.x + rect1.width &gt; rect2.x &amp;&amp;
   rect1.y &lt; rect2.y + rect2.height &amp;&amp;
   rect1.y + rect1.height &gt; rect2.y) {
    // collision detected!
}

// filling in the values =&gt;

if (5 &lt; 30 &amp;&amp;
    55 &gt; 20 &amp;&amp;
    5 &lt; 20 &amp;&amp;
    55 &gt; 10) {
    // collision detected!
}
</pre>

<div class="hidden">
<h5 id="Rect_code">Rect code</h5>

<pre class="brush: html notranslate">&lt;div id=&quot;cr-stage&quot;&gt;&lt;/div&gt;
&lt;p&gt;Mova o retângulo com as setas do teclado. Verde significa colisão, azul significa não-colisão.&lt;/p&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/crafty/0.5.4/crafty-min.js&quot;&gt;&lt;/script&gt;
</pre>

<pre class="brush: js notranslate">Crafty.init(200, 200);

var dim1 = {x: 5, y: 5, w: 50, h: 50}
var dim2 = {x: 20, y: 10, w: 60, h: 40}

var rect1 = Crafty.e(&quot;2D, Canvas, Color&quot;).attr(dim1).color(&quot;red&quot;);

var rect2 = Crafty.e(&quot;2D, Canvas, Color, Keyboard, Fourway&quot;).fourway(2).attr(dim2).color(&quot;blue&quot;);

rect2.bind(&quot;EnterFrame&quot;, function () {
    if (rect1.x &lt; rect2.x + rect2.w &amp;&amp;
        rect1.x + rect1.w &gt; rect2.x &amp;&amp;
        rect1.y &lt; rect2.y + rect2.h &amp;&amp;
        rect1.h + rect1.y &gt; rect2.y) {
        // collision detected!
        this.color(&quot;green&quot;);
    } else {
        // no collision
        this.color(&quot;blue&quot;);
    }
});

</pre>
</div>

<p><iframe class="live-sample-frame sample-code-frame" frameborder="0" height="300" id="frame_Rect_code" src="https://mdn.mozillademos.org/pt-BR/docs/Games/Techniques/2D_collision_detection$samples/Rect_code?revision=1631403" width="700"></iframe></p>

<div class="note notecard">
<p><strong>Nota</strong>: <a href="https://jsfiddle.net/jlr7245/217jrozd/3/">Outro exemplo sem o Canvas ou bibliotecas externas.</a></p>
</div>

<h2 id="Colisão_Circular">Colisão Circular</h2>

<p>Outra forma simples para detecção de colisão é entre dois círculos. Esse algoritmo funciona tomando os pontos centrais dos dois círculos e garantindo que a distância entre os pontos centrais seja menor que os dois raios somados.</p>

<div class="hidden">
<h6 id="Playable_code">Playable code</h6>

<pre class="brush: html notranslate">&lt;div id=&quot;cr-stage&quot;&gt;&lt;/div&gt;
&lt;p&gt;Move the circle with arrow keys. Green means collision, blue means no collision.&lt;/p&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdnjs.cloudflare.com/ajax/libs/crafty/0.5.4/crafty-min.js&quot;&gt;&lt;/script&gt;
</pre>

<pre class="brush: css notranslate">#cr-stage {
    position: static !important;
    height: 200px !important;
}
</pre>

<pre class="brush: js notranslate">Crafty.init(200, 200);

var dim1 = {x: 5, y: 5}
var dim2 = {x: 20, y: 20}

Crafty.c(&quot;Circle&quot;, {
   circle: function(radius, color) {
        this.radius = radius;
        this.w = this.h = radius * 2;
        this.color = color || &quot;#000000&quot;;

        this.bind(&quot;Move&quot;, Crafty.DrawManager.drawAll)
        return this;
   },

   draw: function() {
       var ctx = Crafty.canvas.context;
       ctx.save();
       ctx.fillStyle = this.color;
       ctx.beginPath();
       ctx.arc(
           this.x + this.radius,
           this.y + this.radius,
           this.radius,
           0,
           Math.PI * 2
       );
       ctx.closePath();
       ctx.fill();
       ctx.restore();
    }
});

var circle1 = Crafty.e(&quot;2D, Canvas, Circle&quot;).attr(dim1).circle(15, &quot;red&quot;);

var circle2 = Crafty.e(&quot;2D, Canvas, Circle, Fourway&quot;).fourway(2).attr(dim2).circle(20, &quot;blue&quot;);

circle2.bind(&quot;EnterFrame&quot;, function () {
    var dx = (circle1.x + circle1.radius) - (circle2.x + circle2.radius);
    var dy = (circle1.y + circle1.radius) - (circle2.y + circle2.radius);
    var distance = Math.sqrt(dx * dx + dy * dy);

    if (distance &lt; circle1.radius + circle2.radius) {
        // collision detected!
        this.color = &quot;green&quot;;
    } else {
        // no collision
        this.color = &quot;blue&quot;;
    }
});


</pre>
</div>

<pre class="brush: js notranslate"><code>var circle1 = {radius: 20, x: 5, y: 5};
var circle2 = {radius: 12, x: 10, y: 5};

var dx = circle1.x - circle2.x;
var dy = circle1.y - circle2.y;
var distance = Math.sqrt(dx * dx + dy * dy);

if (distance &lt; circle1.radius + circle2.radius) {
    // collision detected!
}</code>
</pre>

<p><iframe class="live-sample-frame sample-code-frame" frameborder="0" height="300" id="frame_Playable_code" src="https://mdn.mozillademos.org/pt-BR/docs/Games/Techniques/2D_collision_detection$samples/Playable_code?revision=1631403" width="700"></iframe></p>

<div class="note notecard">
<p><strong>Nota</strong>:  <a href="https://jsfiddle.net/jlr7245/teb4znk0/20/" rel="noopener"><font><font>Aqui é outro exemplo sem o Canvas ou bibliotecas externas.</font></font></a></p>
</div>

<h2 id="Teorema_do_eixo_de_separação">Teorema do eixo de separação</h2>

<p>Este é um algoritmo de colisão que pode detectar uma colisão entre quaisquer dois polígonos *convexos*. É mais complicado implementar do que os métodos acima, mas é mais poderoso. A complexidade de um algoritmo como esse significa que precisaremos considerar a otimização de desempenho, abordada na próxima seção.</p>

<p>A implementação do SAT está fora do escopo desta página, portanto, veja os tutoriais recomendados abaixo:</p>

<ol>
 <li><a href="http://www.sevenson.com.au/actionscript/sat/">Separating Axis Theorem (SAT) explanation</a></li>
 <li><a href="http://www.metanetsoftware.com/technique/tutorialA.html">Collision detection and response</a></li>
 <li><a href="http://gamedevelopment.tutsplus.com/tutorials/collision-detection-using-the-separating-axis-theorem--gamedev-169">Collision detection Using the Separating Axis Theorem</a></li>
 <li><a href="http://www.codezealot.org/archives/55">SAT (Separating Axis Theorem)</a></li>
 <li><a href="http://rocketmandevelopment.com/blog/separation-of-axis-theorem-for-collision-detection/">Separation of Axis Theorem (SAT) for Collision DDetection</a></li>
</ol>

<h2 id="Performance_de_Colisão">Performance de Colisão</h2>

<p>Embora alguns desses algoritmos para detecção de colisão sejam simples o suficiente para serem calculados, pode ser um desperdício de ciclos testar todas as entidades com todas as outras entidades. Normalmente os jogos dividem a colisão em duas fases, ampla e estreita.</p>

<h3 id="Fase_Larga">Fase Larga</h3>

<p>A fase ampla deve fornecer uma lista de entidades que *podem* estar colidindo. Isso pode ser implementado com uma estrutura de dados espacial que lhe dará uma ideia aproximada de onde a entidade existe e o que existe em torno dela. Alguns exemplos de estruturas de dados espaciais são Quad Trees, R-Trees ou um Spash Hashmap.</p>

<h3 id="Fase_estreita">Fase estreita</h3>

<p>Quando você tem uma pequena lista de entidades para verificar, você vai querer usar um algoritmo de fase estreita (como os listados acima) para fornecer uma resposta certa sobre se há uma colisão ou não.</p>

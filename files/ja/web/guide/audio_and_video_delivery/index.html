---
title: 音声と動画の配信
slug: Web/Guide/Audio_and_video_delivery
tags:
  - Audio
  - HTML5
  - Media
  - NeedsTranslation
  - Video
translation_of: Web/Guide/Audio_and_video_delivery
---
<div class="summary">
<p>「静的」メディアファイルからアダプティブライブストリームまで、さまざまな方法で Web 上にオーディオとビデオを配信できます。この記事は、Web ベースのメディアのさまざまな配信メカニズムおよび一般的なブラウザとの互換性を探るための出発点として意図されています。</p>
</div>

<h2 id="The_Audio_and_Video_Elements">The Audio and Video Elements</h2>

<p>Whether we are dealing with pre-recorded audio files or live streams, the mechanism for making them available through the browser&apos;s <a href="/ja/docs/Web/HTML/Element/audio" title="この項目についての文書はまだ書かれていません。書いてみませんか？"><code>&lt;audio&gt;</code></a> and <a href="/ja/docs/Web/HTML/Element/video" title="HTML の映像要素 (&lt;video&gt;) は、文書中に映像再生に対応するメディアプレイヤーを埋め込みます。"><code>&lt;video&gt;</code></a> elements remains pretty much the same. Currently, to support all browsers we need to specify two formats, although with the adoption of MP3 and MP4 formats in Firefox and Opera, this is changing fast. You can find compatibility information in the following places:</p>

<ul>
 <li><a href="/en-US/Apps/Build/Manipulating_media/Cross-browser_audio_basics#Audio_Codec_Support">Audio Codec Compatibility Table</a></li>
 <li><a href="/en-US/docs/Web/HTML/Supported_media_formats#Browser_compatibility">Audio/Video Codec Compatibility Table</a></li>
</ul>

<p>To deliver video and audio, the general workflow is usually something like this:</p>

<ol>
 <li>Check what format the browser supports via feature detection (usually a choice of two, as stated above.)</li>
 <li>If the browser doesn&apos;t support playback of any of the provided formats natively, provide a fallback (such as a Flash movie.)</li>
 <li>Identify how you want to play/instantiate the media (e.g. a <a href="/ja/docs/Web/HTML/Element/video" title="HTML の映像要素 (&lt;video&gt;) は、文書中に映像再生に対応するメディアプレイヤーを埋め込みます。"><code>&lt;video&gt;</code></a> element, or <code>document.createElement(&apos;video&apos;)</code> perhaps?)</li>
 <li>Deliver the media file to the player.</li>
</ol>

<h3 id="HTML_Audio">HTML Audio</h3>

<pre class="brush: html">&lt;audio controls preload=&quot;auto&quot;&gt;
  &lt;source src=&quot;audiofile.mp3&quot; type=&quot;audio/mpeg&quot;&gt;

  &lt;!-- fallback for browsers that don&apos;t suppport mp3 --&gt;
  &lt;source src=&quot;audiofile.ogg&quot; type=&quot;audio/ogg&quot;&gt;

  &lt;!-- fallback for browsers that don&apos;t support audio tag --&gt;
  &lt;a href=&quot;audiofile.mp3&quot;&gt;download audio&lt;/a&gt;
&lt;/audio&gt;</pre>

<p>The code above will create an audio player that attempts to preload as much audio as possible for smooth playback.</p>

<div class="note notecard">
<p><strong>Note</strong>: The preload attribute may be ignored by some mobile browsers.</p>
</div>

<p>For further info see <a href="/en-US/Apps/Build/Manipulating_media/Cross-browser_audio_basics#HTML5_audio_in_detail">Cross Browser Audio Basics (HTML5 Audio In Detail)</a></p>

<h3 id="HTML_Video">HTML Video</h3>

<pre class="brush: html">&lt;video controls width=&quot;640&quot; height=&quot;480&quot; poster=&quot;initialimage.png&quot; autoplay muted&gt;
  &lt;source src=&quot;videofile.mp4&quot; type=&quot;video/mp4&quot;&gt;

  &lt;!-- fallback for browsers that don&apos;t suppport mp4 --&gt;
  &lt;source src=&quot;videofile.webm&quot; type=&quot;video/webm&quot;&gt;

  &lt;!-- specifying subtitle files --&gt;
  &lt;track src=&quot;subtitles_en.vtt&quot; kind=&quot;subtitles&quot; srclang=&quot;en&quot; label=&quot;English&quot;&gt;
  &lt;track src=&quot;subtitles_no.vtt&quot; kind=&quot;subtitles&quot; srclang=&quot;no&quot; label=&quot;Norwegian&quot;&gt;

  &lt;!-- fallback for browsers that don&apos;t support video tag --&gt;
  &lt;a href=&quot;videofile.mp4&quot;&gt;download video&lt;/a&gt;
&lt;/video&gt;</pre>

<p>The code above creates a video player of dimensions 640x480 pixels, displaying a poster image until the video is played. We instruct the video to autoplay but to be muted by default.</p>

<div class="note notecard">
<p><strong>Note</strong>: The autoplay attribute may be ignored by some mobile browsers.</p>
</div>

<p>For further info see <a href="https://developer.mozilla.org/en/docs/Web/HTML/Element/video">&lt;video&gt; element</a> and <a href="/en-US/Apps/Build/Manipulating_media/cross_browser_video_player">Creating a cross-browser video player</a>.</p>

<h3 id="Audio_and_Video_Fallback">Audio and Video Fallback</h3>

<p>You can create a more comprehensive Fallback using Flash. <a href="https://github.com/johndyer/mediaelement/blob/master/build/flashmediaelement.swf">Using flashmediaelement.swf</a> is one way.</p>

<pre class="brush: html">&lt;audio controls&gt;
  &lt;source src=&quot;audiofile.mp3&quot; type=&quot;audio/mpeg&quot;&gt;
  &lt;source src=&quot;audiofile.ogg&quot; type=&quot;audio/ogg&quot;&gt;
  &lt;!-- fallback for non supporting browsers goes here --&gt;
  &lt;a href=&quot;audiofile.mp3&quot;&gt;download audio&lt;/a&gt;
  &lt;object width=&quot;320&quot; height=&quot;30&quot; type=&quot;application/x-shockwave-flash&quot; data=&quot;flashmediaelement.swf&quot;&gt;
    &lt;param name=&quot;movie&quot; value=&quot;flashmediaelement.swf&quot; /&gt;
    &lt;param name=&quot;flashvars&quot; value=&quot;controls=true&amp;isvideo=false&amp;file=audiofile.mp3&quot; /&gt;
  &lt;/object&gt;
&lt;/audio&gt;</pre>

<p>The process is very similar with video — just remember to set <code>isvideo=true</code> in the <code>flashvars value</code> parameters.<br>
 <br>
 <a href="/en-US/Apps/Build/Manipulating_media/Cross-browser_audio_basics#Fallbacks">More options for Fallbacks</a>.</p>

<h3 id="JavaScript_Audio">JavaScript Audio</h3>

<pre class="brush: js">var myAudio = document.createElement(&apos;audio&apos;);

if (myAudio.canPlayType(&apos;audio/mpeg&apos;)) {
  myAudio.setAttribute(&apos;src&apos;,&apos;audiofile.mp3&apos;);
} else if (myAudio.canPlayType(&apos;audio/ogg&apos;)) {
  myAudio.setAttribute(&apos;src&apos;,&apos;audiofile.ogg&apos;);
}

myAudio.currentTime = 5;
myAudio.play();</pre>

<p>We set the source of the audio depending on the type of audio file the browser supports, then set the play-head 5 seconds in and attempt to play it.</p>

<div class="note notecard">
<p><strong>Note</strong>: Play will be ignored by some mobile browsers unless issued by a user-initiated event.</p>
</div>

<p>It&apos;s also possible to feed an <a href="/ja/docs/Web/HTML/Element/audio" title="この項目についての文書はまだ書かれていません。書いてみませんか？"><code>&lt;audio&gt;</code></a> element a base64 encoded WAV file, allowing to generate audio on the fly:</p>

<pre class="brush: html">&lt;audio id=&quot;player&quot; src=&quot;data:audio/x-wav;base64,UklGRvC...&quot;&gt;&lt;/audio&gt;</pre>

<p><a href="https://github.com/kripken/speak.js/">Speak.js</a> employs this technique. <a href="http://speak-demo.herokuapp.com">Try the demo</a>.</p>

<h3 id="JavaScript_Video">JavaScript Video</h3>

<pre class="brush: js">var myVideo = document.createElement(&apos;video&apos;);

if (myVideo.canPlayType(&apos;video/mp4&apos;)) {
  myVideo.setAttribute(&apos;src&apos;,&apos;videofile.mp4&apos;);
} else if (myVideo.canPlayType(&apos;video/webm&apos;)) {
  myVideo.setAttribute(&apos;src&apos;,&apos;videofile.webm&apos;);
}

myVideo.width = 480;
myVideo.height = 320;</pre>

<p>We set the source of the video depending on the type of video file the browser supports we then set the width and height of the video.</p>

<h2 id="Web_Audio_API">Web Audio API</h2>

<pre class="brush: js">  var context;
  var request;
  var source;

  try {
    context = new AudioContext();
    request = new XMLHttpRequest();
    request.open(&quot;GET&quot;,&quot;http://jplayer.org/audio/mp3/RioMez-01-Sleep_together.mp3&quot;,true);
    request.responseType = &quot;arraybuffer&quot;;

    request.onload = function() {
      context.decodeAudioData(request.response, function(buffer) {
        source = context.createBufferSource();
        source.buffer = buffer;
        source.connect(context.destination);
        // auto play
        source.start(0); // start was previously noteOn
      });
    };

    request.send();

  } catch(e) {
    alert(&apos;web audio api not supported&apos;);
  }</pre>

<p>In this example we retrieve an MP3 file via XHR, load it into a source and play it (<a href="http://jsbin.com/facutone/1/edit?js">Try it for yourself</a>). Find more about Web Audio API basics in <a href="/en-US/docs/Web/API/Web_Audio_API/Using_Web_Audio_API">Using the Web Audio API</a>.</p>

<h2 id="getUserMedia_Stream_API">getUserMedia / Stream API</h2>

<p>It&apos;s also possible to retrieve a live stream from a webcam and/or microphone using <code>getUserMedia</code> and the Stream API. This makes up part of a wider technology known as WebRTC (Web Real-Time Communications) and is compatible with the latest versions of Chrome, Firefox and Opera.</p>

<p>To grab the stream from your webcam, first set up a <a href="/ja/docs/Web/HTML/Element/video" title="HTML の映像要素 (&lt;video&gt;) は、文書中に映像再生に対応するメディアプレイヤーを埋め込みます。"><code>&lt;video&gt;</code></a> element:</p>

<pre class="brush: html">&lt;video id=&quot;webcam&quot; width=&quot;480&quot; height=&quot;360&quot;&gt;&lt;/video&gt;</pre>

<p>Next, if supported connect the webcam source to the video element:</p>

<pre class="brush: js">if (navigator.mediaDevices) {
  navigator.mediaDevices.getUserMedia({ video: true, audio: false })
  .then(function onSuccess(stream) {
    var video = document.getElementById(&apos;webcam&apos;);
    video.autoplay = true;
    video.srcObject = stream;
  })
  .catch(function onError() {
    alert(&apos;There has been a problem retreiving the streams - are you running on file:/// or did you disallow access?&apos;);
  });
} else {
  alert(&apos;getUserMedia is not supported in this browser.&apos;);
}
</pre>

<p>To find out more, read our <a href="/ja/docs/Web/API/MediaDevices/getUserMedia" title="MediaDevices.getUserMedia() メソッドは、要求された種類のメディアを含むトラックを持つ MediaStream を生成するメディア入力を使用する許可をユーザーに求めます。このストリームには、例えば、動画トラック (カメラ、ビデオ録画機器、スクリーン共有サービスなどのような、ハードウェアまたは仮想ビデオソースによって生み出される)、音声トラック (同様に、マイク、A/D 変換器などの物理的または仮想オーディオソースによって生み出される)、その他の可能な種別を含めることができます。"><code>MediaDevices.getUserMedia</code></a> page.</p>

<h2 id="Mediastream_Recording">Mediastream Recording</h2>

<p>New standards are being rolled out to allow your browser to grab media from your mic or camera using <code>getUserMedia</code> and record it instantly using the new MediaRecorder API. You take the stream you receive from <code>getUserMedia</code>, pass it to a <code>MediaRecorder</code> object, take the resulting output and feed it to your audio or video source*.<br>
 <br>
 The main mechanism is outlined below:</p>

<pre class="brush: js">navigator.mediaDevices.getUserMedia({audio:true})
  .then(function onSuccess(stream) {
    var recorder = new MediaRecorder(stream);

    var data = [];
    recorder.ondataavailable = function(e) {
      data.push(e.data);
    };
    recorder.start();
    recorder.onerror = function(e) {
      throw e.error || new Error(e.name); // e.name is FF non-spec
    }
    recorder.onstop = function(e) {
      var audio = document.createElement(&apos;audio&apos;);
      audio.src = window.URL.createObjectURL(new Blob(data));
    }
    setTimeout(function() {
      rec.stop();
    }, 5000);
  })
  .catch(function onError(error) {
    console.log(error.message);
  });
</pre>

<p>See <a href="/en-US/docs/Web/API/MediaRecorder_API">MediaRecorder API</a> for more details.</p>

<h2 id="Media_Source_Extensions_(MSE)">Media Source Extensions (MSE)</h2>

<p><a href="https://dvcs.w3.org/hg/html-media/raw-file/tip/media-source/media-source.html">Media Source Extensions</a> is a W3C working draft that plans to extend <a href="/ja/docs/Web/API/HTMLMediaElement" title="HTMLMediaElement インターフェイスは、 HTMLElement に音声や動画で一般的なメディアに関する基本的な能力の対応に必要なプロパティやメソッドを追加します。"><code>HTMLMediaElement</code></a> to allow JavaScript to generate media streams for playback. Allowing JavaScript to generate streams facilitates a variety of use cases like adaptive streaming and time shifting live streams.</p>

<h3 id="Encrypted_Media_Extensions_(EME)">Encrypted Media Extensions (EME)</h3>

<p><a href="https://dvcs.w3.org/hg/html-media/raw-file/tip/encrypted-media/encrypted-media.html">Encrypted Media Extensions</a> is a W3C proposal to extend <code>HTMLMediaElement</code>, providing APIs to control playback of protected content.<br>
 <br>
 The API supports use cases ranging from simple clear key decryption to high value video (given an appropriate user agent implementation). License/key exchange is controlled by the application, facilitating the development of robust playback applications supporting a range of content decryption and protection technologies.<br>
 <br>
 One of the principle uses of EME is to allow browsers to implement DRM (<a href="http://en.wikipedia.org/wiki/Digital_rights_management">Digital Rights Management</a>), which helps to prevent web-based content (especially video) from being copied.</p>

<h3 id="Adaptive_Streaming">Adaptive Streaming</h3>

<p>New formats and protocols are being rolled out to facilitate adaptive streaming. Adaptive streaming media means that the bandwidth and typically quality of the stream can change in real-time in reaction to the user&apos;s available bandwidth. Adaptive streaming is often used in conjunction with live streaming where smooth delivery of audio or video is paramount.</p>

<p>The main formats used for adaptive streaming are <a href="/en-US/Apps/Build/Manipulating_media/Live_streaming_web_audio_and_video#HLS">HLS</a> and <a href="/en-US/Apps/Build/Manipulating_media/Live_streaming_web_audio_and_video#MPEG-DASH">MPEG-DASH</a>. MSE has been designed with DASH in mind. MSE defines byte streams according to <a href="https://dvcs.w3.org/hg/html-media/raw-file/tip/media-source/isobmff-byte-stream-format.html">ISOBMFF</a> and <a href="http://en.wikipedia.org/wiki/M2ts">M2TS</a> (both supported in DASH, the latter supported in HLS). Generally speaking, if you are interested in standards, are looking for flexibility, or wish to support most modern browsers, you are probably better off with DASH.</p>

<div class="note notecard">
<p><strong>Note</strong>: Currently Safari does not support DASH although dash.js will work on newer versions of Safari scheduled for release with OSX Yosemite.</p>
</div>

<p>DASH also provides a number of profiles including simple onDemand profiles that no preprocessing and splitting up of media files. There are also a number of cloud based services that will convert your media to both HLS and DASH.<br>
 <br>
 For further information see <a href="/en-US/Apps/Build/Manipulating_media/Live_streaming_web_audio_and_video">Live streaming web audio and video</a>.</p>

<ul>
</ul>

<h2 id="Customising_Your_Media_Player">Customising Your Media Player</h2>

<p>You may decide that you want your audio or video player to have a consistent look across browsers, or just wish to tweak it to match your site. The general technique for achieving this is to omit the <code>controls</code> attribute so that the default browser controls are not displayed, create custom controls using HTML and CSS, then use JavaScript to link your controls to the audio/video API.</p>

<p>If you need something extra, it&apos;s possible to add features that are not currently present in default players, such as playback rate, quality stream switches or even audio spectrums. You can also choose how to make your player responsive — for example you might remove the progress bar under certain conditions.</p>

<p>You may detect click, touch and/or keyboard events to trigger actions such as play, pause and scrubbing. It&apos;s often important to remember keyboard controls for user convenience and accessibility.</p>

<p>A quick example — first set up your audio and custom controls in HTML:</p>

<pre class="brush: html">  &lt;audio id=&quot;my-audio&quot; src=&quot;http://jPlayer.org/audio/mp3/Miaow-01-Tempered-song.mp3&quot;&gt;&lt;/audio&gt;
  &lt;button id=&quot;my-control&quot;&gt;play&lt;/button&gt;</pre>

<p>add a bit of JavaScript to detect events to play and pause the audio:</p>

<pre class="brush: js">window.onload = function() {

  var myAudio = document.getElementById(&apos;my-audio&apos;);
  var myControl = document.getElementById(&apos;my-control&apos;);

  function switchState() {
    if (myAudio.paused == true) {
      myAudio.play();
      myControl.innerHTML = &quot;pause&quot;;
    } else {
      myAudio.pause();
      myControl.innerHTML = &quot;play&quot;;
    }
  }

  function checkKey(e) {
    if (e.keycode == 32 ) { //spacebar
      switchState();
    }
  }

  myControl.addEventListener(&apos;click&apos;, function() {
    switchState();
  }, false);

  window.addEventListener( &quot;keypress&quot;, checkKey, false );
}</pre>

<p>You can <a href="http://jsbin.com/jujeladu/2/edit">try this example out here</a>. For more information, see <a href="https://developer.mozilla.org/en-US/Apps/Build/Manipulating_media/Cross-browser_audio_basics#Creating_your_own_custom_audio_player">Creating your own custom audio player</a>.</p>

<h2 id="Other_tips_for_audiovideo">Other tips for audio/video</h2>

<h3 id="Stopping_the_download_of_media">Stopping the download of media</h3>

<p>While stopping the playback of media is as easy as calling the element&apos;s <code>pause()</code> method, the browser keeps downloading the media until the media element is disposed of through garbage collection.</p>

<p>Here&apos;s a trick that stops the download at once:</p>

<pre class="brush: js">var mediaElement = document.querySelector(&quot;#myMediaElementID&quot;);
mediaElement.<code>removeAttribute(&quot;src&quot;);</code>
mediaElement.<code>load();</code>
</pre>

<p>By removing the media element&apos;s <code>src</code> attribute and invoking the load() method, you release the resources associated with the video, which stops the network download. You must call <code>load()</code> after removing the attribute, because just removing the <code>src</code> attribute does not invoke the load algorithm. If the <code>&lt;video&gt;</code> element also has <code>&lt;source&gt;</code> element descendants, those should also be removed before calling <code>load()</code>.</p>

<p>Note that just setting the <code>src</code> attribute to an empty string will actually cause the browser to treat it as though you&apos;re setting a video source to a relative path. This causes the browser to attempt another download to something that is unlikely to be a valid video.</p>

<h3 id="Seeking_through_media">Seeking through media</h3>

<p>Media elements provide support for moving the current playback position to specific points in the media&apos;s content. This is done by setting the value of the <code>currentTime</code> property on the element; see <a href="/ja/docs/Web/API/HTMLMediaElement" title="HTMLMediaElement インターフェイスは、 HTMLElement に音声や動画で一般的なメディアに関する基本的な能力の対応に必要なプロパティやメソッドを追加します。"><code>HTMLMediaElement</code></a> for further details on the element&apos;s properties. Simply set the value to the time, in seconds, at which you want playback to continue.</p>

<p>You can use the element&apos;s <code>seekable</code> property to determine the ranges of the media that are currently available for seeking to. This returns a <a href="/ja/docs/Web/API/TimeRanges" title="この項目についての文書はまだ書かれていません。書いてみませんか？"><code>TimeRanges</code></a> object listing the ranges of times that you can seek to.</p>

<pre class="brush: js">var mediaElement = document.querySelector(&apos;#mediaElementID&apos;);
mediaElement.seekable.start(0);  // Returns the starting time (in seconds)
mediaElement.seekable.end(0);    // Returns the ending time (in seconds)
mediaElement.currentTime = 122; // Seek to 122 seconds
mediaElement.played.end(0);      // Returns the number of seconds the browser has played
</pre>

<h3 id="Specifying_playback_range">Specifying playback range</h3>

<p>When specifying the URI of media for an <a href="/ja/docs/Web/HTML/Element/audio" title="この項目についての文書はまだ書かれていません。書いてみませんか？"><code>&lt;audio&gt;</code></a> or <a href="/ja/docs/Web/HTML/Element/video" title="HTML の映像要素 (&lt;video&gt;) は、文書中に映像再生に対応するメディアプレイヤーを埋め込みます。"><code>&lt;video&gt;</code></a> element, you can optionally include additional information to specify the portion of the media to play. To do this, append a hash mark (&quot;#&quot;) followed by the media fragment description.</p>

<p>A time range is specified using the syntax:</p>

<pre>#t=[starttime][,endtime]</pre>

<p>The time can be specified as a number of seconds (as a floating-point value) or as an hours/minutes/seconds time separated with colons (such as 2:05:01 for 2 hours, 5 minutes, and 1 second).</p>

<p>A few examples:</p>

<dl>
 <dt><span class="nowiki">http://example.com/video.ogv#t=10,20</span></dt>
 <dd>Specifies that the video should play the range 10 seconds through 20 seconds.</dd>
 <dt><span class="nowiki">http://example.com/video.ogv#t=,10.5</span></dt>
 <dd>Specifies that the video should play from the beginning through 10.5 seconds.</dd>
 <dt><span class="nowiki">http://example.com/video.ogv#t=,02:00:00</span></dt>
 <dd>Specifies that the video should play from the beginning through two hours.</dd>
 <dt><span class="nowiki">http://example.com/video.ogv#t=60</span></dt>
 <dd>Specifies that the video should start playing at 60 seconds and play through the end of the video.</dd>
</dl>

<div class="note notecard">
<p><strong>Note</strong>: The playback range portion of the media element URI specification was added to Gecko 9.0 (Firefox 9.0 / Thunderbird 9.0 / SeaMonkey 2.6). At this time, this is the only part of the <a class="external" href="http://www.w3.org/TR/media-frags/" title="http://www.w3.org/TR/media-frags/">Media Fragments URI specification</a> implemented by Gecko, and it can only be used when specifying the source for media elements, and not in the address bar.</p>
</div>

<h2 id="Error_handling">Error handling</h2>

<p>Starting in Gecko 2.0 (Firefox 4 / Thunderbird 3.3 / SeaMonkey 2.1), error handling has been revised to match the latest version of the HTML5 specification. Instead of the <code>error</code> event being dispatched to the media element itself, it now gets delivered to the child <a href="/ja/docs/Web/HTML/Element/source" title="HTML の &lt;source&gt; 要素は、 &lt;picture&gt; 要素、 &lt;audio&gt; 要素、 &lt;video&gt; 要素に対し、複数のメディアリソースを指定します。この要素自体は空要素です。この要素は一般的に、同一のメディアコンテンツをそれぞれのブラウザーに対応した複数のメディア形式で提供する場合に用います。"><code>&lt;source&gt;</code></a> elements corresponding to the sources resulting in the error.</p>

<p>This lets you detect which sources failed to load, which may be useful. Consider this HTML:</p>

<pre class="brush: html">&lt;video&gt;
&lt;source id=&quot;mp4_src&quot;
  src=&quot;video.mp4&quot;
  type=&apos;video/mp4; codecs=&quot;avc1.42E01E, mp4a.40.2&quot;&apos;&gt;
&lt;/source&gt;
&lt;source id=&quot;3gp_src&quot;
  src=&quot;video.3gp&quot;
  type=&apos;video/3gpp; codecs=&quot;mp4v.20.8, samr&quot;&apos;&gt;
&lt;/source&gt;
&lt;source id=&quot;ogg_src&quot;
  src=&quot;video.ogv&quot;
  type=&apos;video/ogv; codecs=&quot;theora, vorbis&quot;&apos;&gt;
&lt;/source&gt;
&lt;/video&gt;</pre>

<p>Since Firefox doesn&apos;t support MP4 and 3GP on some platforms due to their patent-encumbered nature, the <a href="/ja/docs/Web/HTML/Element/source" title="HTML の &lt;source&gt; 要素は、 &lt;picture&gt; 要素、 &lt;audio&gt; 要素、 &lt;video&gt; 要素に対し、複数のメディアリソースを指定します。この要素自体は空要素です。この要素は一般的に、同一のメディアコンテンツをそれぞれのブラウザーに対応した複数のメディア形式で提供する場合に用います。"><code>&lt;source&gt;</code></a> elements with the IDs &quot;mp4_src&quot; and &quot;3gp_src&quot; will receive <code>error</code> events before the Ogg resource is loaded. The sources are tried in the order in which they appear, and once one loads successfully, the remaining sources aren&apos;t tried at all.</p>

<h3 id="Checking_whether_the_browser_supports_the_supplied_formats">Checking whether the browser supports the supplied formats</h3>

<p>Use the following verified sources within your audio and video elements to check support.</p>

<ul>
 <li>Audio MP3 (<code>type=&quot;audio/mpeg&quot;</code>): <a href="http://jPlayer.org/audio/mp3/Miaow-01-Tempered-song.mp3">http://jPlayer.org/audio/mp3/Miaow-01-Tempered-song.mp3</a> (<a href="http://jsbin.com/gekatoge/1/edit">play the MP3 audio live</a>.)</li>
 <li>Audio MP4 (<code>type=&quot;audio/mp4&quot;</code>): <a href="http://jPlayer.org/audio/m4a/Miaow-01-Tempered-song.m4a">http://jPlayer.org/audio/m4a/Miaow-01-Tempered-song.m4a</a> (<a href="http://jsbin.com/gekatoge/2/edit">play the MP4 audio live</a>.)</li>
 <li>Audio Ogg (<code>type=&quot;audio/ogg&quot;</code>): <a href="http://jPlayer.org/audio/ogg/Miaow-01-Tempered-song.ogg">http://jPlayer.org/audio/ogg/Miaow-01-Tempered-song.ogg</a> (<a href="http://jsbin.com/gekatoge/4/edit">play the OGG audio live</a>.)</li>
 <li>Video MP4 (<code>type=&quot;video/mp4&quot;</code>): <a href="http://jPlayer.org/video/m4v/Big_Buck_Bunny_Trailer.m4v">http://jPlayer.org/video/m4v/Big_Buck_Bunny_Trailer.m4v</a> (<a href="http://jsbin.com/gekatoge/5/edit">play the MP4 video live</a>.)</li>
 <li>Video WebM (<code>type=&quot;video/webm&quot;</code>): <a href="http://jPlayer.org/video/webm/Big_Buck_Bunny_Trailer.webm">http://jPlayer.org/video/webm/Big_Buck_Bunny_Trailer.webm</a> (<a href="http://jsbin.com/gekatoge/6/edit">play the WebM video live</a>.)</li>
 <li>Video Ogg (<code>type=&quot;video/ogg&quot;</code>): <a href="http://jPlayer.org/video/ogv/Big_Buck_Bunny_Trailer.ogv">http://jPlayer.org/video/ogv/Big_Buck_Bunny_Trailer.ogv</a> (<a href="http://jsbin.com/gekatoge/7/edit">play the OGG video live</a>.)</li>
</ul>

<p>If these don&apos;t play then the browser you are testing doesn&apos;t support the given format. Consider using a different format or using a fallback.<br>
 <br>
 If these work but the files you are supplying don&apos;t, there are two possible issues:</p>

<h4 id="1._The_media_server_is_not_delivering_the_correct_mime_types_with_the_file">1. The media server is not delivering the correct mime types with the file</h4>

<p>Although this is usually supported, you may need to add the following to your media server&apos;s <code>.htaccess</code> file.</p>

<pre># AddType TYPE/SUBTYPE EXTENSION

AddType audio/mpeg mp3
AddType audio/mp4 m4a
AddType audio/ogg ogg
AddType audio/ogg oga

AddType video/mp4 mp4
AddType video/mp4 m4v
AddType video/ogg ogv
AddType video/webm webm
AddType video/webm webmv</pre>

<h4 id="2._Your_files_have_been_encoded_incorrectly">2. Your files have been encoded incorrectly</h4>

<p>Your files may have been encoded incorrectly — try encoding using one of the following tools, which are proven to be pretty reliable:</p>

<ul>
 <li><a href="http://audacity.sourceforge.net/">Audacity</a> — Free Audio Editor and Recorder</li>
 <li><a href="http://www.getmiro.com/">Miro</a> — Free, open-source music and video player</li>
 <li><a href="http://handbrake.fr/">Handbrake</a> — Open Source Video Transcoder</li>
 <li><a href="http://firefogg.org/">Firefogg</a> — Video and Audio encoding for Firefox</li>
 <li><a href="https://www.ffmpeg.org/">FFmpeg2</a> — Comprehensive command line encoder</li>
 <li><a href="https://libav.org/">Libav</a> — Comprehensive command line encoder</li>
 <li><a href="http://m.vid.ly/">Vid.ly</a> — Video player,transcoding and delivery</li>
 <li><a href="https://archive.org/">Internet Archive</a> — Free transcoding and storage</li>
</ul>

<h3 id="Detecting_when_no_sources_have_loaded">Detecting when no sources have loaded</h3>

<p>To detect that all child <a href="/ja/docs/Web/HTML/Element/source" title="HTML の &lt;source&gt; 要素は、 &lt;picture&gt; 要素、 &lt;audio&gt; 要素、 &lt;video&gt; 要素に対し、複数のメディアリソースを指定します。この要素自体は空要素です。この要素は一般的に、同一のメディアコンテンツをそれぞれのブラウザーに対応した複数のメディア形式で提供する場合に用います。"><code>&lt;source&gt;</code></a> elements have failed to load, check the value of the media element&apos;s <code>networkState</code> attribute. If this is <code>HTMLMediaElement.NETWORK_NO_SOURCE</code>, you know that all the sources failed to load.</p>

<p>If at that point you add another source, by inserting a new <a href="/ja/docs/Web/HTML/Element/source" title="HTML の &lt;source&gt; 要素は、 &lt;picture&gt; 要素、 &lt;audio&gt; 要素、 &lt;video&gt; 要素に対し、複数のメディアリソースを指定します。この要素自体は空要素です。この要素は一般的に、同一のメディアコンテンツをそれぞれのブラウザーに対応した複数のメディア形式で提供する場合に用います。"><code>&lt;source&gt;</code></a> element as a child of the media element, Gecko attempts to load the specified resource.</p>

<h3 id="Showing_fallback_content_when_no_source_could_be_decoded">Showing fallback content when no source could be decoded</h3>

<p>Another way to show the fallback content of a video, when none of the sources could be decoded in the current browser, is to add an error handler on the last source element. Then you can replace the video with its fallback content:</p>

<pre class="brush: html">&lt;video controls&gt;
  &lt;source src=&quot;dynamicsearch.mp4&quot; type=&quot;video/mp4&quot;&gt;&lt;/source&gt;
  &lt;a href=&quot;dynamicsearch.mp4&quot;&gt;
    &lt;img src=&quot;dynamicsearch.jpg&quot; alt=&quot;Dynamic app search in Firefox OS&quot;&gt;
  &lt;/a&gt;
  &lt;p&gt;Click image to play a video demo of dynamic app search&lt;/p&gt;
&lt;/video&gt;

</pre>

<pre class="brush: js">var v = document.querySelector(&apos;video&apos;),
    sources = v.querySelectorAll(&apos;source&apos;),
    lastsource = sources[sources.length-1];
lastsource.addEventListener(&apos;error&apos;, function(ev) {
  var d = document.createElement(&apos;div&apos;);
  d.innerHTML = v.innerHTML;
  v.parentNode.replaceChild(d, v);
}, false);
</pre>

<h2 id="AudioVideo_JavaScript_Libraries">Audio/Video JavaScript Libraries</h2>

<p>A number of audio and video JavaScript libaries exist. The most popular libraries allow you to choose a consistent player design over all browsers and provide a fallback for browsers that don&apos;t support audio and video natively. Fallbacks often use Adobe Flash or Microsoft Silverlight plugins. Other functionality such as the track element for subtitles can also be provided through media libraries.</p>

<h3 id="Audio_only">Audio only</h3>

<ul>
 <li><a href="http://www.schillmania.com/projects/soundmanager2/">SoundManager</a></li>
 <li><a href="https://521dimensions.com/open-source/amplitudejs">AmplitudeJS</a></li>
 <li><a href="https://howlerjs.com/">HowlerJS</a></li>
</ul>

<h3 id="Video_only">Video only</h3>

<ul>
 <li><a href="https://flowplayer.org/">flowplayer</a>: Gratis with a flowplayer logo watermark. Open source (GPL licensed.)</li>
 <li><a href="http://www.jwplayer.com">JWPlayer</a>: Requires registration to download. Open Source Edition (Creative Commons License.)</li>
 <li><a href="http://www.sublimevideo.net/">SublimeVideo</a>: Requires registration. Form based set up with domain specific link to CDN hosted library.</li>
 <li><a href="http://www.videojs.com/">Video.js</a>: Gratis and Open Source (Apache 2 Licensed.)</li>
</ul>

<h3 id="Audio_and_Video">Audio and Video</h3>

<ul>
 <li><a href="http://jPlayer.org">jPlayer</a>: Gratis and Open Source (MIT Licensed.)</li>
 <li><a href="http://mediaelementjs.com/">mediaelement.js</a>: Gratis and Open Source (MIT Licensed.)</li>
</ul>

<h3 id="Web_Audio_API_2">Web Audio API</h3>

<ul>
 <li><a href="https://github.com/cwilso/AudioContext-MonkeyPatch">AudioContext monkeypatch</a>: A polyfill for older versions of the Web Audio API; Open Source (Apache 2 Licensed.)</li>
</ul>

<h2 id="Basic_tutorials">Basic tutorials</h2>

<dl>
 <dt><a href="/en-US/Apps/Build/Manipulating_media/cross_browser_video_player">Creating a cross-browser video player</a></dt>
 <dd>A guide to creating a basic cross browser video player using the <a href="/ja/docs/Web/HTML/Element/video" title="HTML の映像要素 (&lt;video&gt;) は、文書中に映像再生に対応するメディアプレイヤーを埋め込みます。"><code>&lt;video&gt;</code></a> element.</dd>
 <dt><a href="/en-US/Apps/Build/Manipulating_media/Video_player_styling_basics">Video player styling basics</a></dt>
 <dd>With the cross-browser video player put in place in the previous article, this article now looks at providing some basic, reponsive styling for the player.</dd>
 <dt><a href="/en-US/Apps/Build/Manipulating_media/Cross-browser_audio_basics">Cross-browser audio basics</a></dt>
 <dd>
 <div>
 <p>This article provides a basic guide to creating an HTML5 audio player that works cross browser, with all the associated attributes, properties and events explained, and a quick guide to custom controls created using the Media API.</p>
 </div>
 </dd>
 <dt><a href="/en-US/Apps/Build/Manipulating_media/buffering_seeking_time_ranges">Media buffering, seeking, and time ranges</a></dt>
 <dd>Sometimes it&apos;s useful to know how much <a href="/ja/docs/Web/HTML/Element/audio" title="この項目についての文書はまだ書かれていません。書いてみませんか？"><code>&lt;audio&gt;</code></a> or <a href="/ja/docs/Web/HTML/Element/video" title="HTML の映像要素 (&lt;video&gt;) は、文書中に映像再生に対応するメディアプレイヤーを埋め込みます。"><code>&lt;video&gt;</code></a> has downloaded or is playable without delay — a good example of this is the buffered progress bar of an audio or video player. This article discusses how to build a buffer/seek bar using <a href="/en-US/docs/Web/API/TimeRanges">TimeRanges</a>, and other features of the media API.</dd>
 <dt><a href="/en-US/Apps/Build/Manipulating_media/HTML5_playbackRate_explained">HTML5 playbackRate explained</a></dt>
 <dd>The <code>playbackRate</code> property allows us to change the speed or rate at which a piece of web audio or video is playing. This article explains it in detail.</dd>
 <dt><a href="/en-US/docs/Web/API/Web_Audio_API/Using_Web_Audio_API">Using the Web Audio API</a></dt>
 <dd>Explains the basics of using the Web Audio API to grab, manipulate and play back an audio source.</dd>
</dl>

<h2 id="Streaming_media_tutorials">Streaming media tutorials</h2>

<dl>
 <dt><a href="/en-US/Apps/Build/Manipulating_media/Live_streaming_web_audio_and_video">Live streaming web audio and video</a></dt>
 <dd>Live streaming technology is often employed to relay live events such as sports, concerts and more generally TV and Radio programmes that are output live. Often shortened to just streaming, live streaming is the process of transmitting media &apos;live&apos; to computers and devices. This is a fairly complex and nascent subject with a lot of variables, so in this article we&apos;ll introduce you to the subject and let you know how you can get started.</dd>
 <dt><a href="/en-US/Apps/Build/Manipulating_media/Setting_up_adaptive_streaming_media_sources">Setting up adaptive streaming media sources</a></dt>
 <dd>Let&apos;s say you want to set up an adaptive streaming media source on a server, to be consumed inside an HTML5 media element. How would you do that? This article explains how, looking at two of the most common formats: MPEG-DASH and HLS (HTTP Live Streaming.)</dd>
 <dt><a href="/en-US/docs/Web/HTML/DASH_Adaptive_Streaming_for_HTML_5_Video">DASH Adaptive Streaming for HTML 5 Video</a></dt>
 <dd>Details how to set up adaptive streaming using DASH and WebM.</dd>
</dl>

<h2 id="Advanced_tutorials">Advanced tutorials</h2>

<dl>
 <dt><a href="/en-US/Apps/Build/Manipulating_media/Adding_captions_and_subtitles_to_HTML5_video">Adding captions and subtitles to HTML5 video</a></dt>
 <dd>This article explains how to add captions and subtitles to HTML5 <a href="/ja/docs/Web/HTML/Element/video" title="HTML の映像要素 (&lt;video&gt;) は、文書中に映像再生に対応するメディアプレイヤーを埋め込みます。"><code>&lt;video&gt;</code></a>, using <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Video_Text_Tracks_Format" title="WebVTT is a format for displaying timed text tracks (e.g. subtitles) with the &lt;track&gt; element. The primary purpose of WebVTT files is to add subtitles to a &lt;video&gt;.">Web_Video_Text_Tracks_Format</a> and the <a href="/ja/docs/Web/HTML/Element/track" title="HTML の &lt;track&gt; 要素はメディア要素 (&lt;audio&gt; および &lt;video&gt;) の子として使用します。この要素は自動的に処理される字幕など、時間指定されたテキストトラック（または時系列データ）を指定できます。トラックは WebVTT (Web Video Text Tracks) 形式 (.vtt ファイル) 又は Timed Text Markup Language (TTML) で整形します。"><code>&lt;track&gt;</code></a> element.</dd>
 <dt><a href="/en-US/docs/Web/Apps/Developing/Manipulating_media/Web_Audio_API_cross_browser" title="/en-US/docs/Web/Apps/Developing/Manipulating_media/Web_Audio_API_cross_browser">Writing Web Audio API code that works in every browser</a></dt>
 <dd>A guide to writing cross browser Web Audio API code.</dd>
 <dt><a href="/en-US/Apps/Developing/Manipulating_media/H.264_support_in_Firefox">H.264 support in Firefox</a></dt>
 <dd>This article explains the state of support for the H.264 video format in Firefox/Firefox OS, including code examples, tips and tricks.</dd>
 <dt><a href="https://hacks.mozilla.org/2014/06/easy-audio-capture-with-the-mediarecorder-api/">Easy audio capture with the MediaRecorder API</a></dt>
 <dd>Explains the basics of using the MediaRecorder API to directly record a media stream.</dd>
</dl>

<div class="note notecard">
<p><strong>Note</strong>: Firefox OS versions 1.3 and above support the <a href="http://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol" title="http://en.wikipedia.org/wiki/Real_Time_Streaming_Protocol">RTSP</a> protocol for streaming video delivery. A fallback solution for older versions would be to use <code>&lt;video&gt;</code> along with a suitable format for Gecko (such as WebM) to serve fallback content. More information will be published on this in good time.</p>
</div>

<h2 id="References">References</h2>

<ul>
 <li><a href="/en-US/docs/Web/HTML/Element/video">The video element</a></li>
 <li><a href="/en-US/docs/Web/Guide/Events/Media_events">Media events API</a></li>
 <li><a href="/en-US/docs/Web/API/HTMLVideoElement">HTMLVideoElement API</a></li>
 <li><a href="/en-US/docs/Web/API/MediaSource">MediaSource API</a></li>
 <li><a href="/en-US/docs/Web/API/Web_Audio_API">Web Audio API</a></li>
 <li><a href="/en-US/docs/Web/API/MediaRecorder_API">MediaRecorder API</a></li>
 <li><a href="/en-US/docs/Web/API/MediaDevices/getUserMedia">getUserMedia</a></li>
</ul>

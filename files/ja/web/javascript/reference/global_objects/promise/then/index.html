---
title: Promise.prototype.then()
slug: Web/JavaScript/Reference/Global_Objects/Promise/then
tags:
  - ECMAScript 2015
  - JavaScript
  - Method
  - Promise
  - Prototype
translation_of: Web/JavaScript/Reference/Global_Objects/Promise/then
---
<div><section class="Quick_links" id="Quick_Links"><ol><li><strong><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects">Standard built-in objects</a></strong></li><li><strong><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a></strong></li><li data-default-state="open"><a href="#"><strong>メソッド</strong></a><ol><li><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"><code>Promise.all()</code></a></li><li><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled"><code>Promise.allSettled()</code></a></li><li><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise/any"><code>Promise.any()</code></a></li><li><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch"><code>Promise.prototype.catch()</code></a></li><li><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally"><code>Promise.prototype.finally()</code></a></li><li><em><code>Promise.prototype.then()</code></em></li><li><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise/race"><code>Promise.race()</code></a></li><li><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise/reject"><code>Promise.reject()</code></a></li><li><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve"><code>Promise.resolve()</code></a></li></ol></li><li><strong>継承</strong></li><li><strong><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Function"><code>Function</code></a></strong></li><li><a href="#"><strong>プロパティ</strong></a><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="これは非推奨 API です。未だ動作しているかも知れませんが、将来的に削除される可能性があります。"><i class="icon-thumbs-down-alt"> </i></span></span><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments"><code>Function.arguments</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="これは非推奨 API です。未だ動作しているかも知れませんが、将来的に削除される可能性があります。"><i class="icon-thumbs-down-alt"> </i></span></span><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Function/caller"><code>Function.caller</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="この API は標準化されていません。"><i class="icon-warning-sign"> </i></span></span><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Function/displayName"><code>Function.displayName</code></a></li><li><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Function/length"><code>Function.length</code></a></li><li><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Function/name"><code>Function.name</code></a></li></ol></li><li><a href="#"><strong>メソッド</strong></a><ol><li><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"><code>Function.prototype.apply()</code></a></li><li><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"><code>Function.prototype.bind()</code></a></li><li><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Function/call"><code>Function.prototype.call()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="この API は標準化されていません。"><i class="icon-warning-sign"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="これは廃止されたAPIであり、今後の動作は保障されていません。ご注意下さい。"><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Function/toSource"><code>Function.prototype.toSource()</code></a></s></li><li><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Function/toString"><code>Function.prototype.toString()</code></a></li></ol></li><li><strong><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Object"><code>Object</code></a></strong></li><li><a href="#"><strong>プロパティ</strong></a><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="これは非推奨 API です。未だ動作しているかも知れませんが、将来的に削除される可能性があります。"><i class="icon-thumbs-down-alt"> </i></span></span><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"><code>Object.prototype.__proto__</code></a></li><li><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor"><code>Object.prototype.constructor</code></a></li></ol></li><li><a href="#"><strong>メソッド</strong></a><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="これは非推奨 API です。未だ動作しているかも知れませんが、将来的に削除される可能性があります。"><i class="icon-thumbs-down-alt"> </i></span></span><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__"><code>Object.prototype.__defineGetter__()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="これは非推奨 API です。未だ動作しているかも知れませんが、将来的に削除される可能性があります。"><i class="icon-thumbs-down-alt"> </i></span></span><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineSetter__"><code>Object.prototype.__defineSetter__()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="これは非推奨 API です。未だ動作しているかも知れませんが、将来的に削除される可能性があります。"><i class="icon-thumbs-down-alt"> </i></span></span><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupGetter__"><code>Object.prototype.__lookupGetter__()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="これは非推奨 API です。未だ動作しているかも知れませんが、将来的に削除される可能性があります。"><i class="icon-thumbs-down-alt"> </i></span></span><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupSetter__"><code>Object.prototype.__lookupSetter__()</code></a></li><li><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty"><code>Object.prototype.hasOwnProperty()</code></a></li><li><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf"><code>Object.prototype.isPrototypeOf()</code></a></li><li><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable"><code>Object.prototype.propertyIsEnumerable()</code></a></li><li><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString"><code>Object.prototype.toLocaleString()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="この API は標準化されていません。"><i class="icon-warning-sign"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="これは廃止されたAPIであり、今後の動作は保障されていません。ご注意下さい。"><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/toSource"><code>Object.prototype.toSource()</code></a></s></li><li><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/toString"><code>Object.prototype.toString()</code></a></li><li><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf"><code>Object.prototype.valueOf()</code></a></li><li><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"><code>Object.setPrototypeOf()</code></a></li></ol></li></ol></section></div>

<p><code><strong>then()</strong></code> メソッドは <a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a> を返します。最大2つの引数、 <code>Promise</code> が成功した場合と失敗した場合のコールバック関数を取ります。</p>

<div><iframe class="interactive interactive-js" frameborder="0" height="250" src="https://interactive-examples.mdn.mozilla.net/pages/js/promise-then.html" title="MDN Web Docs Interactive Example" width="100%"></iframe></div>

<p class="hidden">このデモのソースファイルは GitHub リポジトリに格納されています。デモプロジェクトに協力したい場合は、 <a href="https://github.com/mdn/interactive-examples">https://github.com/mdn/interactive-examples</a> をクローンしてプルリクエストを送信してください。</p>

<div class="note">
<p>片方または両方の引数が省略されたり、関数ではないものが渡されたりした場合、 <code>then</code> にはハンドラーが不足しますが、エラーは発生しません。 <code>Promise</code> が状態 (<code>fulfillment</code> (完了) または <code>rejection</code> (拒否)) を受け入れるに当たって <code>then</code> が呼び出された際に、 <code>then</code> がハンドラーを持たない場合は、 <code>then</code> が呼び出された元の <code>Promise</code> の最後の状態を受け入れた、追加のハンドラーのない新しい <code>Promise</code> が生成されます。</p>
</div>

<h2 id="Syntax" name="Syntax">構文</h2>

<pre class="syntaxbox notranslate"><var>p.then(onFulfilled[, onRejected])</var>;

p.then(value =&gt; {
  // fulfillment
}, reason =&gt; {
  // rejection
});
</pre>

<h3 id="Parameters" name="Parameters">引数</h3>

<dl>
 <dt><code>onFulfilled</code> <span class="optional optionalInline notecard inline">Optional</span></dt>
 <dd><code>Promise</code> が成功したときに呼び出される <a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Function"><code>Function</code></a> です。この関数は1つの引数、 <code>fulfillment value</code> を持ちます。これが関数ではない場合は、内部的に &quot;Identity&quot; 関数 (受け取った引数を返す関数) に置き換えられます。</dd>
 <dt><code>onRejected</code> <span class="optional optionalInline notecard inline">Optional</span></dt>
 <dd><code>Promise</code> が拒絶されたときに呼び出される <a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Function"><code>Function</code></a> です。この関数は1つの引数、 <code>rejection reason</code> を持ちます。これが関数ではない場合は、内部的に &quot;Thrower&quot; 関数 (引数として受け取ったエラーを投げる関数) に置き換えられます。</dd>
</dl>

<h3 id="Return_value" name="Return_value">返値</h3>

<p><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a> が完了するか拒否されると、それぞれのハンドラー関数 (<code>onFulfilled</code> または <code>onRejected</code>) が<strong>非同期に</strong>呼び出されます (現在のスレッドループにスケジュールされます)。ハンドラー関数のこの動作は特定の一連の規則に従います。もしハンドラー関数が・・・</p>

<ul>
 <li>値を返した場合、 <code>then</code> によって返される Promise は返値をその値として解決します。</li>
 <li>何も返さなかった場合、 <code>then</code> によって返される Promise は <code>undefined</code> の値で解決します。</li>
 <li>エラーを投げた場合、 <code>then</code> によって返される Promise は、その値としてエラーを投げて拒絶されます。</li>
 <li>すでに解決している Promise を返した場合、 <code>then</code> によって返される Promise は、その Promise の値をその値として返します。</li>
 <li>すでに拒絶された Promise を返した場合、 <code>then</code> によって返される Promise は、その Promise の値をその値として拒絶されます。</li>
 <li>他の <strong>pending</strong> 状態の Promise オブジェクトを返した場合、 <code>then</code> によって返された Promise の解決/拒絶は、ハンドラーによって返された Promise の解決/拒絶結果に依存します。また、 <code>then</code> によって返された Promise の解決値は、ハンドラーによって返された Promise の解決値と同じになります。</li>
</ul>

<p>以下は、 <code>then</code> メソッドの非同期性を示す例です。</p>

<pre class="brush: js notranslate">// using a resolved promise, the &apos;then&apos; block will be triggered instantly,
// but its handlers will be triggered asynchronously as demonstrated by the console.logs
const resolvedProm = Promise.resolve(33);

let thenProm = resolvedProm.then(value =&gt; {
    console.log(&quot;this gets called after the end of the main stack. the value received and returned is: &quot; + value);
    return value;
});
// instantly logging the value of thenProm
console.log(thenProm);

// using setTimeout we can postpone the execution of a function to the moment the stack is empty
setTimeout(() =&gt; {
    console.log(thenProm);
});


// logs, in order:
// Promise {[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined}
// &quot;this gets called after the end of the main stack. the value received and returned is: 33&quot;
// Promise {[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 33}</pre>

<h2 id="Description" name="Description">説明</h2>

<p><code>then</code> メソッドや <a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch"><code>Promise.prototype.catch()</code></a> メソッドは <code>Promise</code> を返すので、<a href="/ja/docs/Web/JavaScript/Guide/Using_promises#Chaining">チェーン可能</a>です。 — これは <em>composition</em> と呼ばれる操作です。</p>

<h2 id="Examples" name="Examples">例</h2>

<h3 id="Using_the_then_method" name="Using_the_then_method"><code>then</code> メソッドの使用</h3>

<pre class="brush: js notranslate">var p1 = new Promise((resolve, reject) =&gt; {
  resolve(&apos;Success!&apos;);
  // or
  // reject(new Error(&quot;Error!&quot;));
});

p1.then(value =&gt; {
  console.log(value); // Success!
}, reason =&gt; {
  console.error(reason); // Error!
} );
</pre>

<h3 id="Chaining" name="Chaining">チェーン</h3>

<p><code>then</code> メソッドは <code>Promise</code> を返すので、メソッドチェーンができます。</p>

<p>関数が <code>then</code> にハンドラーとして渡されると <code>Promise</code> を返します。同じ <code>Promise</code> がメソッドチェーンの次の <code>then</code> に現れます。次のスニペットは、非同期実行をシミュレートする、 <code>setTimeout()</code> 関数付きのコードです。</p>

<pre class="brush: js notranslate">Promise.resolve(&apos;foo&apos;)
  // 1. Receive &quot;foo&quot;, concatenate &quot;bar&quot; to it, and resolve that to the next then
  .then(function(string) {
    return new Promise(function(resolve, reject) {
      setTimeout(function() {
        string += &apos;bar&apos;;
        resolve(string);
      }, 1);
    });
  })
  // 2. receive &quot;foobar&quot;, register a callback function to work on that string
  // and print it to the console, but not before returning the unworked on
  // string to the next then
  .then(function(string) {
    setTimeout(function() {
      string += &apos;baz&apos;;
      console.log(string); // foobarbaz
    }, 1)
    return string;
  })
  // 3. print helpful messages about how the code in this section will be run
  // before the string is actually processed by the mocked asynchronous code in the
  // previous then block.
  .then(function(string) {
    console.log(&quot;Last Then:  oops... didn&apos;t bother to instantiate and return &quot; +
                &quot;a promise in the prior then so the sequence may be a bit &quot; +
                &quot;surprising&quot;);

    // Note that `string` will not have the &apos;baz&apos; bit of it at this point. This
    // is because we mocked that to happen asynchronously with a setTimeout function
    console.log(string); // foobar
  });

// logs, in order:
// Last Then: oops... didn&apos;t bother to instantiate and return a promise in the prior then so the sequence may be a bit surprising
// foobar
// foobarbaz</pre>

<p><code>then()</code> の引数として渡された関数(ハンドラ)が値を返した場合は、 <code>Promise.resolve (&lt;ハンドラーが呼ばれて返された値&gt;) </code>によって、返値を自動的に <code>Promise</code> でラップします。</p>

<pre class="brush: js notranslate">var p2 = new Promise(function(resolve, reject) {
  resolve(1);
});

p2.then(function(value) {
  console.log(value); // 1
  return value + 1;
}).then(function(value) {
  console.log(value + &apos; - A synchronous value works&apos;); // 2 - A synchronous value works
});

p2.then(function(value) {
  console.log(value); // 1
});
</pre>

<p><code>then</code> の引数として渡した関数が拒絶された Promise が返した場合や、例外 (エラー) が発生した場合は、拒絶された Promise を返します。</p>

<pre class="brush: js notranslate">Promise.resolve()
  .then(() =&gt; {
    // Makes .then() return a rejected promise
    throw new Error(&apos;Oh no!&apos;);
  })
  .then(() =&gt; {
    console.log(&apos;Not called.&apos;);
  }, error =&gt; {
    console.error(&apos;onRejected function called: &apos; + error.message);
  });</pre>

<p>その他の場合はすべて、<ruby>解決中<rp> (</rp><rt>resolving</rt><rp>) </rp></ruby>の Promise が返されます。次の例では、チェーン上の以前の Promise が拒絶されていても、最初の <code>then()</code> は解決中の Promise に含まれた <code>42</code> を返します。</p>

<pre class="brush: js notranslate">Promise.reject()
  .then(() =&gt; 99, () =&gt; 42) // onRejected returns 42 which is wrapped in a resolving Promise
  .then(solution =&gt; console.log(&apos;Resolved with &apos; + solution)); // Resolved with 42</pre>

<p>多くの場合、 <code>catch</code> を使って失敗状態の Promise を補足する方が、 <code>then</code> の 2 つのハンドラーを使って処理するよりも現実的です。下記の例を見てください。</p>

<pre class="brush: js notranslate">Promise.resolve()
  .then(() =&gt; {
    // Makes .then() return a rejected promise
    throw new Error(&apos;Oh no!&apos;);
  })
  .catch(error =&gt; {
    console.error(&apos;onRejected function called: &apos; + error.message);
  })
  .then(() =&gt; {
    console.log(&quot;I am always called even if the prior then&apos;s promise rejects&quot;);
  });</pre>

<p>Promise ベースの API を持った関数同士であれば、別の関数上に他の関数を実装することでチェーンを使うこともできます。</p>

<pre class="brush: js notranslate">function fetch_current_data() {
  // The <a href="/en-US/docs/Web/API/GlobalFetch/fetch">fetch</a>() API returns a Promise.  This function
  // exposes a similar API, except the fulfillment
  // value of this function&apos;s Promise has had more
  // work done on it.
  return fetch(&apos;current-data.json&apos;).then(response =&gt; {
    if (response.headers.get(&apos;content-type&apos;) != &apos;application/json&apos;) {
      throw new TypeError();
    }
    var j = response.json();
    // maybe do something with j
    return j; // fulfillment value given to user of
              // fetch_current_data().then()
  });
}
</pre>

<p><code>onFulfilled</code> がプロミスを返した場合、 <code>then</code> の返値はプロミスによって解決／拒否されます。</p>

<pre class="brush: js notranslate">function resolveLater(resolve, reject) {
  setTimeout(function() {
    resolve(10);
  }, 1000);
}
function rejectLater(resolve, reject) {
  setTimeout(function() {
    reject(new Error(&apos;Error&apos;));
  }, 1000);
}

var p1 = Promise.resolve(&apos;foo&apos;);
var p2 = p1.then(function() {
  // Return promise here, that will be resolved to 10 after 1 second
  return new Promise(resolveLater);
});
p2.then(function(v) {
  console.log(&apos;resolved&apos;, v);  // &quot;resolved&quot;, 10
}, function(e) {
  // not called
  console.error(&apos;rejected&apos;, e);
});

var p3 = p1.then(function() {
  // Return promise here, that will be rejected with &apos;Error&apos; after 1 second
  return new Promise(rejectLater);
});
p3.then(function(v) {
  // not called
  console.log(&apos;resolved&apos;, v);
}, function(e) {
  console.error(&apos;rejected&apos;, e); // &quot;rejected&quot;, &apos;Error&apos;
});
</pre>

<h3 id="window.setImmediate_style_promise-based_polyfill" name="window.setImmediate_style_promise-based_polyfill">window.setImmediate 形式のプロミスベースの代替処理</h3>

<p><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"><code>Function.prototype.bind()</code></a> を使用して、 <code>Reflect.apply</code> (<a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Reflect/apply"><code>Reflect.apply()</code></a>) メソッドは (キャンセルできない) <a href="/ja/docs/Web/API/Window/setImmediate"><code>window.setImmediate</code></a> 形式の関数を作成することができます。</p>

<pre class="brush: js notranslate">const nextTick = (() =&gt; {
  const noop = () =&gt; {}; // literally
  const nextTickPromise = () =&gt; Promise.resolve().then(noop);

  const rfab = Reflect.apply.bind; // (thisArg, fn, thisArg, [...args])
  const nextTick = (fn, ...args) =&gt; (
    fn !== undefined
    ? Promise.resolve(args).then(rfab(null, fn, null))
    : nextTickPromise(),
    undefined
  );
  nextTick.ntp = nextTickPromise;

  return nextTick;
})();
</pre>

<h2 id="Specifications" name="Specifications">仕様書</h2>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col">仕様書</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><a class="external" href="https://tc39.es/ecma262/#sec-promise.prototype.then" hreflang="en" lang="en">ECMAScript (ECMA-262)<br><small lang="ja">Promise.prototype.then の定義</small></a></td>
  </tr>
 </tbody>
</table>

<h2 id="Browser_compatibility" name="Browser_compatibility">ブラウザーの互換性</h2>

<div class="hidden">互換性データに協力していただけるのであれば、 <a class="external" href="https://github.com/mdn/browser-compat-data">https://github.com/mdn/browser-compat-data</a> に対してプルリクエストを書いてください。</div>

<div class="bc-data" id="bcd:javascript.builtins.Promise.then"></div>

<h2 id="See_also" name="See_also">関連情報</h2>

<ul>
 <li><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a></li>
 <li><a href="/ja/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch"><code>Promise.prototype.catch()</code></a></li>
</ul>

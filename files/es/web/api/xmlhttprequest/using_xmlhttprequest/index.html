---
title: Using XMLHttpRequest
slug: Web/API/XMLHttpRequest/Using_XMLHttpRequest
translation_of: Web/API/XMLHttpRequest/Using_XMLHttpRequest
---
<section class="Quick_links" id="Quick_Links"><ol><li><strong><a href="/es/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a></strong></li><li class="toggle"><details open><summary>Constructor</summary><ol><li><a href="/es/docs/Web/API/XMLHttpRequest/XMLHttpRequest"><code>XMLHttpRequest()</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/XMLHttpRequest$translate" style="opacity: 0.5;">[Traducir]</a></li></ol></details></li><li class="toggle"><details open><summary>Propiedades</summary><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><a href="/es/docs/Web/API/XMLHttpRequest/channel"><code>channel</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/channel$translate" style="opacity: 0.5;">[Traducir]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><a href="/es/docs/Web/API/XMLHttpRequest/mozAnon"><code>mozAnon</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/mozAnon$translate" style="opacity: 0.5;">[Traducir]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><a href="/es/docs/Web/API/XMLHttpRequest/mozBackgroundRequest"><code>mozBackgroundRequest</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/mozBackgroundRequest$translate" style="opacity: 0.5;">[Traducir]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><a href="/es/docs/Web/API/XMLHttpRequest/mozResponseArrayBuffer"><code>mozResponseArrayBuffer</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/mozResponseArrayBuffer$translate" style="opacity: 0.5;">[Traducir]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><a href="/es/docs/Web/API/XMLHttpRequest/mozSystem"><code>mozSystem</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/mozSystem$translate" style="opacity: 0.5;">[Traducir]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="This is an obsolete API and is no longer guaranteed to work."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/es/docs/Web/API/XMLHttpRequest/multipart"><code>multipart</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/multipart$translate" style="opacity: 0.5;">[Traducir]</a></s></li><li><a href="/es/docs/Web/API/XMLHttpRequest/onreadystatechange"><code>onreadystatechange</code></a></li><li><a href="/es/docs/Web/API/XMLHttpRequest/readyState"><code>readyState</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/readyState$translate" style="opacity: 0.5;">[Traducir]</a></li><li><a href="/es/docs/Web/API/XMLHttpRequest/response"><code>response</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/response$translate" style="opacity: 0.5;">[Traducir]</a></li><li><a href="/es/docs/Web/API/XMLHttpRequest/responseText"><code>responseText</code></a></li><li><a href="/es/docs/Web/API/XMLHttpRequest/responseType"><code>responseType</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/responseType$translate" style="opacity: 0.5;">[Traducir]</a></li><li><a href="/es/docs/Web/API/XMLHttpRequest/responseURL"><code>responseURL</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/responseURL$translate" style="opacity: 0.5;">[Traducir]</a></li><li><a href="/es/docs/Web/API/XMLHttpRequest/responseXML"><code>responseXML</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/responseXML$translate" style="opacity: 0.5;">[Traducir]</a></li><li><a href="/es/docs/Web/API/XMLHttpRequest/status"><code>status</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/status$translate" style="opacity: 0.5;">[Traducir]</a></li><li><a href="/es/docs/Web/API/XMLHttpRequest/statusText"><code>statusText</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/statusText$translate" style="opacity: 0.5;">[Traducir]</a></li><li><a href="/es/docs/Web/API/XMLHttpRequest/timeout"><code>timeout</code></a></li><li><a href="/es/docs/Web/API/XMLHttpRequest/upload"><code>upload</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/upload$translate" style="opacity: 0.5;">[Traducir]</a></li><li><a href="/es/docs/Web/API/XMLHttpRequest/withCredentials"><code>withCredentials</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/withCredentials$translate" style="opacity: 0.5;">[Traducir]</a></li></ol></details></li><li class="toggle"><details open><summary>Métodos</summary><ol><li><a href="/es/docs/Web/API/XMLHttpRequest/abort"><code>abort()</code></a></li><li><a href="/es/docs/Web/API/XMLHttpRequest/getAllResponseHeaders"><code>getAllResponseHeaders()</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/getAllResponseHeaders$translate" style="opacity: 0.5;">[Traducir]</a></li><li><a href="/es/docs/Web/API/XMLHttpRequest/getResponseHeader"><code>getResponseHeader()</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/getResponseHeader$translate" style="opacity: 0.5;">[Traducir]</a></li><li><a href="/es/docs/Web/API/XMLHttpRequest/open"><code>open()</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/open$translate" style="opacity: 0.5;">[Traducir]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><a href="/es/docs/Web/API/XMLHttpRequest/openRequest"><code>openRequest()</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/openRequest$translate" style="opacity: 0.5;">[Traducir]</a></li><li><a href="/es/docs/Web/API/XMLHttpRequest/overrideMimeType"><code>overrideMimeType()</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/overrideMimeType$translate" style="opacity: 0.5;">[Traducir]</a></li><li><a href="/es/docs/Web/API/XMLHttpRequest/send"><code>send()</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/send$translate" style="opacity: 0.5;">[Traducir]</a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="This is an obsolete API and is no longer guaranteed to work."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/es/docs/Web/API/XMLHttpRequest/sendAsBinary"><code>sendAsBinary()</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/sendAsBinary$translate" style="opacity: 0.5;">[Traducir]</a></s></li><li><a href="/es/docs/Web/API/XMLHttpRequest/setRequestHeader"><code>setRequestHeader()</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/setRequestHeader$translate" style="opacity: 0.5;">[Traducir]</a></li></ol></details></li><li class="toggle"><details open><summary>Eventos</summary><ol><li><a href="/es/docs/Web/API/XMLHttpRequest/onreadystatechange"><code>onreadystatechange</code></a></li><li><a href="/es/docs/Web/API/XMLHttpRequest/abort_event"><code>abort</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/abort_event$translate" style="opacity: 0.5;">[Traducir]</a></li><li><a href="/es/docs/Web/API/XMLHttpRequest/error_event"><code>error</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/error_event$translate" style="opacity: 0.5;">[Traducir]</a></li><li><a href="/es/docs/Web/API/XMLHttpRequest/load_event"><code>load</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/load_event$translate" style="opacity: 0.5;">[Traducir]</a></li><li><a href="/es/docs/Web/Events/loadend"><code>loadend</code></a></li><li><a href="/es/docs/Web/API/XMLHttpRequest/loadstart_event"><code>loadstart</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/loadstart_event$translate" style="opacity: 0.5;">[Traducir]</a></li><li><a href="/es/docs/Web/API/XMLHttpRequest/progress_event"><code>progress</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/progress_event$translate" style="opacity: 0.5;">[Traducir]</a></li><li><a href="/es/docs/Web/API/XMLHttpRequest/timeout_event"><code>timeout</code></a> <a href="/es/docs/Web/API/XMLHttpRequest/timeout_event$translate" style="opacity: 0.5;">[Traducir]</a></li></ol></details></li><li class="toggle"><details open><summary>Herencia</summary><ol><li><a href="/es/docs/Web/API/XMLHttpRequestEventTarget"><code>XMLHttpRequestEventTarget</code></a></li><li><a href="/es/docs/Web/API/EventTarget"><code>EventTarget</code></a></li></ol></details></li><li class="toggle"><details open><summary>Páginas relacionadas a XMLHttpRequest</summary><ol><li><a href="/es/docs/Web/API/FormData"><code>FormData</code></a></li><li><a href="/es/docs/Web/API/XMLHttpRequestEventTarget"><code>XMLHttpRequestEventTarget</code></a></li><li><a href="/es/docs/Web/API/XMLHttpRequestUpload"><code>XMLHttpRequestUpload</code></a></li></ol></details></li></ol></section>

<p><span class="seoSummary">En esta guía le echaremos un vistazo a cómo usar <a href="/es/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code></a> para enviar solicitudes <a href="https://wiki.developer.mozilla.org/en-US/docs/Web/HTTP">HTTP</a> con el objetivo de intercambiar datos entre el sitio web y el servidor.</span> Se incluyen ejemplos, tanto para los casos de uso comunes de <code>XMLHttpRequest</code>, como para los más inusuales.</p>

<p>Para enviar una solicitud HTTP, cree un objeto <code>XMLHttpRequest</code>, abra una URL y envíe la solicitud. Una vez que la transacción haya sido completada, el objeto contendrá información útil tal como el cuerpo de la respuesta y el estado <a href="/en-US/docs/Web/HTTP/Status">HTTP</a> del resultado.</p>

<pre class="brush: js">function reqListener () {
  console.log(this.responseText);
}

var oReq = new XMLHttpRequest();
oReq.addEventListener(&quot;load&quot;, reqListener);
oReq.open(&quot;GET&quot;, &quot;http://www.example.org/example.txt&quot;);
oReq.send();</pre>

<h2 id="Solicitudes_Síncronas_y_Asíncronas">Solicitudes Síncronas y Asíncronas</h2>

<p><code>XMLHttpRequest</code> soporta tanto comunicaciones síncronas como asíncronas.</p>

<div class="note notecard"><strong>Nota:</strong> No deberias usar <code>XMLHttpRequests</code> síncronas porque, dada la naturaleza inherentemente asíncrona del intercambio de datos en las redes, hay multiples formas en que la memoria y eventos se puedan perder usando solicitudes síncronas.</div>

<p>En versiones de Firefox anteriores a Firefox 3, (solicitudes) <code>XMLHttpRequest</code> síncronas bloqueaban la interfaz de usuario.  Con tal de permitirle al usuario terminar solicitudes congeladas, Firefox 3 ya no lo hace.</p>

<h3 id="Ejemplo_Solicitud_síncrona">Ejemplo: Solicitud síncrona</h3>

<p>Este ejemplo demuestra como hacer una solicitud síncrona.</p>

<pre class="script deki-transform">var req = new XMLHttpRequest();
req.open(&apos;GET&apos;, &apos;http://www.mozilla.org/&apos;, false);
req.send(null);
if (req.status == 200)
  dump(req.responseText);</pre>

<p>En la línea 1 se instancia un objeto <code>XMLHttpRequest</code>.  Después en la línea 2 se abre una nueva solicitud, especificando que una solicitud <code>GET</code> se utilizará para extraer la pagina de inicio de Mozilla.org, y que la operación no debe ser asíncrona.</p>

<p>En la línea 3 se envía la solicitud.  El parámetro <code>null</code> indica que la solicitud <code>GET</code> no necesita contenido en el cuerpo.</p>

<p>En la línea 4 se verifica el código de estatus después de que la transacción se completa.  Si el resultado es 200 -- El código HTTP para resultado &quot;OK&quot;-- el contenido de texto del documento se escribe en la consola.</p>

<h3 id="Ejemplo_Solicitudes_síncronas_no-HTTP">Ejemplo: Solicitudes síncronas no-HTTP</h3>

<p>A pesar de su nombre, <code>XMLHttpRequest</code> se puede usar para hacer solicitudes que no sean de HTTP.  Este ejemplo muestra como usarlo para extraer un archivo del sistemas de archivos local.</p>

<pre class="script">var req = new XMLHttpRequest();
req.open(&apos;GET&apos;, &apos;<a class="linkification-ext" title="Linkification: file:///home/user/file.json">file:///home/user/file.json</a>&apos;, false);
req.send(null);
if(req.status == 0)
  dump(req.responseText);</pre>

<p>La clave aqui es notar que el estado del resultado se compara con 0 en lugar de 200.  Esto es porque los esquemas <code>file</code> y <code>ftp</code> no usan los codigos de resultado de HTTP.</p>

<h3 id="Ejemplo_Solicitudes_asíncronas">Ejemplo: Solicitudes asíncronas</h3>

<p>Si usas <code>XMLHttpRequest</code> desde una extensión, deberias usarla asíncronamente.  En este caso, recibiras una llamada de regreso cuando se hallan recibido los datos, lo cual permite al navegador continuar trabajando con normalidad mientras se maneja tu solicitud.</p>

<pre class="script">var req = new XMLHttpRequest();
req.open(&apos;GET&apos;, &apos;http://www.mozilla.org/&apos;, true);
req.onreadystatechange = function (aEvt) {
  if (req.readyState == 4) {
     if(req.status == 200)
      dump(req.responseText);
     else
      dump(&quot;Error loading page\n&quot;);
  }
};
req.send(null); </pre>

<p>La linea 2 especifica <code>true</code> en su tercer parametro indicando que la solicitud debe manejarse asíncronamente.</p>

<p>Line 3 crea un objeto función para manejar eventos y lo asigna al atributo de la solicitud <code>onreadystatechange</code>.  Este manejador observa el <code>readyState</code> de la solicitud verificando si la transacción se ha completado en la linea 4, si así es, y el estatus HTTP es 200, imprime el contenido recibido.  Si ocurrió un error, se muestra un mensaje de error.</p>

<p>La linea 11 de hecho inicia la solicitud.  La función onreadystatechange es llamada siempre que el estado de una solicitud cambia.</p>

<h2 id="Analizando_y_Manipulando_el_Texto_de_Respuesta_HTML">Analizando y Manipulando el Texto de Respuesta HTML</h2>

<p>Si usas <code>XMLHttpRequest para obtener el contenido de una página</code> HTML remota, el <code>responseText </code>(texto de la respuesta) sera una cadena que contenga una &quot;sopa&quot; de etiquetas HTML, lo que puede ser dificil de analizar y manipular. Existen tres maneras principales de analizar estas cadenas HTML</p>

<ol>
 <li><a href="/en/Code_snippets/HTML_to_DOM#Safely_parsing_simple_HTML.c2.a0to_DOM" title="https://developer.mozilla.org/en/Code_snippets/HTML_to_DOM#Safely_parsing_simple_HTML.c2.a0to_DOM">Analizar con nsIScriptableUnescapeHTML </a>repidamente convertira la cadena HTML en DOM, al mismo tiempo que tira javascript y otros elementos avanzados, incluyendo la etiqueta <code>&lt;head&gt;</code> de la página.</li>
 <li><a href="/es/Referencia_de_JavaScript_1.5/Objetos_globales/RegExp" title="es/Referencia de JavaScript 1.5/Objetos globales/RegExp">RegExp </a>se puede usar si de antemano conoces el HTML que vendra en el <code>responseText</code>. Quizas quieras remover los saltos de linea, si usas RegExp para escanear considerandolos. Sin embargo, este metodo es un &quot;ultimo recurso&quot; ya que si el HTML cambia ligeramente, posiblemente fallara.</li>
 <li><a href="/en/Code_snippets/HTML_to_DOM#Using_a_hidden_iframe_element_to_parse_HTML_to_a_window%27s_DOM" title="https://developer.mozilla.org/en/Code_snippets/HTML_to_DOM#Using_a_hidden_iframe_element_to_parse_HTML_to_a_window&apos;s_DOM">Usar un hidden chrome o un content-level iframe</a> para cargar toda la pagina también se puede hacer para manipularla luego como DOM, sin embargo existen <a href="/En/Displaying_web_content_in_an_extension_without_security_issues" title="En/Displaying_web_content_in_an_extension_without_security_issues">riesgos de seguridad al dar a código remoto este nivel de acceso privilegiado</a>, que puede causar <a class="link-https" href="https://addons.mozilla.org/en-US/developers/docs/policies/reviews" title="https://addons.mozilla.org/en-US/developers/docs/policies/reviews">problemas </a>en la revisión de tu addon. Por ejemplo, si una pagina ejecuta el comando común &quot;<code>document.location = redirecttothispage.html</code>&quot; para cargar, esto se interpretara como cambiar la locación del navegador (<code>document.location</code> en una extensión) en contraposición a la locación de una página web (<code>content.document.location</code> en una extensión), y en consecuecia destruir todos los componentes del navegador. Alternativamente, y de algun modo mas seguro, una cadena <code>responseText adquirida mediante</code> <code>XMLHttpRequest se puede analizar con</code> RegExp para remover problemas de javascript, luego cargada en un iframe oculto previamente  establecido:</li>
</ol>

<pre>document.getElementById(&apos;hiddenXULiframe&apos;).contentWindow.document.body.innerHTML = req.responseText
</pre>

<h2 id="Using_FormData_objects">Using FormData objects</h2>



<p>The <a href="/en/XMLHttpRequest/FormData" title="en/XMLHttpRequest/FormData"><code>FormData</code></a> object lets you compile a set of key/value pairs to send using <code>XMLHttpRequest</code>. It&apos;s primarily intended for use in sending form data, but can be used independently from forms in order to transmit keyed data. The transmitted data is in the same format that the form&apos;s <code>submit()</code> method would use to send the data if the form&apos;s encoding type were set to &quot;multipart/form-data&quot;.</p>

<h3 id="Creating_a_FormData_object_from_scratch">Creating a FormData object from scratch</h3>

<p>You can build a <code>FormData</code> object yourself, instantiating it then appending fields to it by calling its <a href="/en/XMLHttpRequest/FormData#append()" title="en/XMLHttpRequest/FormData#append()"><code>append()</code></a> method, like this:</p>

<pre class="deki-transform">var formData = new FormData();

formData.append(&quot;username&quot;, &quot;Groucho&quot;);
formData.append(&quot;accountnum&quot;, 123456);
formData.append(&quot;afile&quot;, fileInputElement.files[0]);

var xhr = new XMLHttpRequest();
xhr.open(&quot;POST&quot;, &quot;http://foo.com/submitform.php&quot;);
xhr.send(formData);
</pre>

<p>This example builds a <code>FormData</code> object containing values for fields named &quot;username&quot; and &quot;accountnum&quot;, then uses the <code>XMLHttpRequest</code> method <a href="/en/XMLHttpRequest#send()" title="en/XMLHttpRequest#send()"><code>send()</code></a> to send the form&apos;s data.</p>

<h3 id="Retrieving_a_FormData_object_from_an_HTML_form">Retrieving a FormData object from an HTML form</h3>

<p>To construct a <code>FormData</code> object that contains the data from an existing <a href="/es/docs/Web/HTML/Elemento/form" title="El elemento HTML form (&lt;form&gt;) representa una sección de un documento que contiene controles interactivos que permiten a un usuario enviar información a un servidor web."><code>&lt;form&gt;</code></a>, specify that form element when creating the <code>FormData</code> object:</p>

<pre>newFormData = new FormData(someFormElement);
</pre>

<p>For example:</p>

<pre class="deki-transform">var formElement = document.getElementById(&quot;myFormElement&quot;);
var xhr = new XMLHttpRequest();
xhr.open(&quot;POST&quot;, &quot;submitform.php&quot;);
xhr.send(new FormData(formElement));
</pre>

<p>You can also add data to the <code>FormData</code> object between retrieving it from a form and sending it, like this:</p>

<pre class="deki-transform">var formElement = document.getElementById(&quot;myFormElement&quot;);
formData = new FormData(formElement);
formData.append(&quot;serialnumber&quot;, serialNumber++);
xhr.send(formData);
</pre>

<p>This lets you augment the form&apos;s data before sending it along, to include additional information that&apos;s not necessarily user editable on the form.</p>

<h3 id="Sending_files_using_a_FormData_object">Sending files using a FormData object</h3>

<p>You can also send files using <code>FormData</code>. Simply include an <a href="/es/docs/Web/HTML/Elemento/input" title="El elemento HTML &lt;input&gt; se usa para crear controles interactivos para formularios basados en la web, que reciban datos del usuario. La forma en que &lt;input&gt; funciona varía considerablemente dependiendo del valor de su atributo type."><code>&lt;input&gt;</code></a> element of type &quot;file&quot;:</p>

<pre class="deki-transform">&lt;form enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; name=&quot;fileinfo&quot; id=&quot;fileinfo&quot;&gt;
  &lt;label&gt;Your email address:&lt;/label&gt;
  &lt;input type=&quot;email&quot; autocomplete=&quot;on&quot; autofocus name=&quot;userid&quot; placeholder=&quot;email&quot; required size=&quot;32&quot; maxlength=&quot;64&quot;&gt;&lt;br /&gt;
  &lt;label&gt;Custom file ID:&lt;/label&gt;
  &lt;input type=&quot;text&quot; name=&quot;fileid&quot; size=&quot;12&quot; maxlength=&quot;32&quot;&gt;&lt;br /&gt;
  &lt;label&gt;File to stash:&lt;/label&gt;
  &lt;input type=&quot;file&quot; name=&quot;file&quot; required&gt;
&lt;/form&gt;
&lt;div id=&quot;output&quot;&gt;&lt;/div&gt;
&lt;a href=&quot;javascript:sendForm()&quot;&gt;Stash the file!&lt;/a&gt;
</pre>

<p>Then you can send it using code like the following:</p>

<pre class="deki-transform">function sendForm() {
  var output = document.getElementById(&quot;output&quot;);
  var data = new FormData(document.getElementById(&quot;fileinfo&quot;));

  data.append(&quot;CustomField&quot;, &quot;This is some extra data&quot;);

  var xhr = new XMLHttpRequest();
  xhr.open(&quot;POST&quot;, &quot;stash.pl&quot;, false)
  xhr.send(data);
  if (xhr.status == 200) {
    output.innerHTML += &quot;Uploaded!&lt;br /&gt;&quot;;
  } else {
    output.innerHTML += &quot;Error &quot; + xhr.status + &quot; occurred uploading your file.&lt;br /&gt;&quot;;
  }
}
</pre>

<p>Note that this example is directing the output to a Perl CGI script running on the server, and handles HTTP errors, although not prettily.</p>

<h2 id="Handling_binary_data">Handling binary data</h2>

<p>Although <code>XMLHttpRequest</code> is most commonly used to send and receive textual data, it can be used to send and receive binary content.</p>

<h3 id="Receiving_binary_data">Receiving binary data</h3>

<p>The <code>load_binary_resource()</code> function shown below loads binary data from the specified URL, returning it to the caller.</p>

<pre class="script">function load_binary_resource(url) {
  var req = new XMLHttpRequest();
  req.open(&apos;GET&apos;, url, false);
  //XHR binary charset opt by Marcus Granado 2006 [http://mgran.blogspot.com]
  req.overrideMimeType(&apos;text/plain; charset=x-user-defined&apos;);
  req.send(null);
  if (req.status != 200) return &apos;&apos;;
  return req.responseText;
}
</pre>

<p>The magic happens in line 5, which overrides the MIME type, forcing Firefox to treat it as plain text, using a user-defined character set.  This tells Firefox not to parse it, and to let the bytes pass through unprocessed.</p>

<pre class="script">var filestream = load_binary_resource(url);
var abyte = filestream.charCodeAt(x) &amp; 0xff; // throw away high-order byte (f7)</pre>

<p>The example above fetches the byte at offset <code>x</code> within the loaded binary data.  The valid range for <code>x</code> is from 0 to <code>filestream.length-1</code>.</p>

<p>See <a class="external" href="http://mgran.blogspot.com/2006/08/downloading-binary-streams-with.html">downloading binary streams with XMLHttpRequest</a> for a detailed explanation. See also <a href="/en/Code_snippets/Downloading_Files" title="en/Code_snippets/Downloading_Files">downloading files</a>.</p>

<h3 id="Receiving_binary_data_using_JavaScript_typed_arrays">Receiving binary data using JavaScript typed arrays</h3>



<p>Gecko 2.0 (Firefox 4 / Thunderbird 3.3 / SeaMonkey 2.1) adds a Gecko-specific <code>mozResponseArrayBuffer</code> property to the XMLHttpRequest object, which contains a <a href="/en/JavaScript_typed_arrays" title="en/JavaScript typed arrays">JavaScript typed array</a> representing the raw binary contents of the response from the server. This lets you read the binary data without taking any special steps.</p>

<pre class="deki-transform">var xhr = new XMLHttpRequest();
xhr.open(&quot;GET&quot;, &quot;binary_file&quot;, false);
xhr.send(null);

buffer = xhr.mozResponseArrayBuffer;
if (buffer) {
  var byteArray = new UInt8Array(buffer);
  for (var i=0; i&lt;byteArray.byteLength; i++) {
    // do something with each byte in the array
  }
}
</pre>

<p>This example reads a binary file and interprets it as 8-bit unsigned integers.</p>

<h3 id="Sending_binary_data">Sending binary data</h3>

<p>This example transmits binary content asynchronously, using the <code>POST</code> method.</p>

<pre class="script">var req = new XMLHttpRequest();
req.open(&quot;POST&quot;, url, true);
// set headers and mime-type appropriately
req.setRequestHeader(&quot;Content-Length&quot;, 741);
req.sendAsBinary(aBody);</pre>

<p>Line 4 sets the Content-Length header to 741, indicating that the data is 741 bytes long.  Obviously you need to change this value based on the actual size of the data being sent.</p>

<p>Line 5 uses the <code>sendAsBinary()</code> method to initiate the request.</p>

<p>You can also send binary content by passing an instance of the <code><a href="/es/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIFileInputStream" title>nsIFileInputStream</a></code> to <a class="internal" href="/en/XMLHttpRequest#send()" title="/En/XMLHttpRequest#send()"><code>send()</code></a>.  In that case, you don&apos;t have to set the Content-Length header yourself, as the information is fetched from the stream automatically:</p>

<pre class="script">// Make a stream from a file.
var stream = Components.classes[&quot;@mozilla.org/network/file-input-stream;1&quot;]
                       .createInstance(Components.interfaces.nsIFileInputStream);
stream.init(file, 0x04 | 0x08, 0644, 0x04); // file is an nsIFile instance

// Try to determine the MIME type of the file
var mimeType = &quot;text/plain&quot;;
try {
  var mimeService = Components.classes[&quot;@mozilla.org/mime;1&quot;]
          .getService(Components.interfaces.nsIMIMEService);
  mimeType = mimeService.getTypeFromFile(file); // file is an nsIFile instance
}
catch(e) { /* eat it; just use text/plain */ }

// Send
var req = Components.classes[&quot;@mozilla.org/xmlextras/xmlhttprequest;1&quot;]
                    .createInstance(Components.interfaces.nsIXMLHttpRequest);
req.open(&apos;PUT&apos;, url, false); /* synchronous! */
req.setRequestHeader(&apos;Content-Type&apos;, mimeType);
req.send(stream);
</pre>

<h2 id="Monitoring_progress">Monitoring progress</h2>

<p><code>XMLHttpRequest</code> provides the ability to listen to various events that can occur while the request is being processed. This includes periodic progress notifications, error notifications, and so forth.</p>

<h3 id="In_Firefox_3.5_and_later">In Firefox 3.5 and later</h3>

<p>Firefox 3.5 adds support for DOM progress event monitoring of <code>XMLHttpRequest</code> transfers; this follows the Web API <a class="external" href="http://dev.w3.org/2006/webapi/progress/Progress.html" title="http://dev.w3.org/2006/webapi/progress/Progress.html">specification for progress events</a>.</p>

<pre class="script">var req = new XMLHttpRequest();

req.addEventListener(&quot;progress&quot;, updateProgress, false);
req.addEventListener(&quot;load&quot;, transferComplete, false);
req.addEventListener(&quot;error&quot;, transferFailed, false);
req.addEventListener(&quot;abort&quot;, transferCanceled, false);

req.open();

...

// progress on transfers from the server to the client (downloads)
function updateProgress(evt) {
  if (evt.lengthComputable) {
    var percentComplete = evt.loaded / evt.total;
    ...
  } else {
    // Unable to compute progress information since the total size is unknown
  }
}

function transferComplete(evt) {
  alert(&quot;The transfer is complete.&quot;);
}

function transferFailed(evt) {
  alert(&quot;An error occurred while transferring the file.&quot;);
}

function transferCanceled(evt) {
  alert(&quot;The transfer has been canceled by the user.&quot;);
}
</pre>

<p>Lines 3-6 add event listeners for the various events that are sent while performing a data transfer using <code>XMLHttpRequest</code>.  See <code><a href="/es/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIDOMProgressEvent" title>nsIDOMProgressEvent</a></code> and <code><a href="/es/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIXMLHttpRequestEventTarget" title>nsIXMLHttpRequestEventTarget</a></code> for details on these events.</p>

<div class="note notecard">Note: You need to add the event listeners before calling <code>open()</code> on the request.  Otherwise the progress events will not fire.</div>

<p>The progress event handler, specified by the <code>updateProgress()</code> function in this example, receives the total number of bytes to transfer as well as the number of bytes transferred so far in the event&apos;s <code>total</code> and <code>loaded</code> fields.  However, if the <code>lengthComputable</code> field is false, the total length is not known and will be zero.</p>

<p>Progress events exist for both download and upload transfers. The download events are fired on the <code>XMLHttpRequest</code> object itself, as shown in the above sample. The upload events are fired on the <code>XMLHttpRequest.upload</code> object, as shown below:</p>

<pre class="script">var req = new XMLHttpRequest();

req.upload.addEventListener(&quot;progress&quot;, updateProgress, false);
req.upload.addEventListener(&quot;load&quot;, transferComplete, false);
req.upload.addEventListener(&quot;error&quot;, transferFailed, false);
req.upload.addEventListener(&quot;abort&quot;, transferCanceled, false);

req.open();</pre>

<div class="note notecard"><strong>Note:</strong> Progress events are not available for the <code>file:</code> protocol.</div>

<h3 id="In_Firefox_3_and_earlier">In Firefox 3 and earlier</h3>

<p>If, for example, you wish to provide progress information to the user while the document is being received, you can use code like this:</p>

<pre class="script">function onProgress(e) {
  var percentComplete = (e.position / e.totalSize)*100;
  // ...
}

function onError(e) {
  alert(&quot;Error &quot; + e.target.status + &quot; occurred while receiving the document.&quot;);
}

function onLoad(e) {
  // ...
}
// ...
var req = new XMLHttpRequest();
req.onprogress = onProgress; // or req.addEventListener(&quot;progress&quot;, onProgress, false);
req.open(&quot;GET&quot;, url, true);
req.onload = onLoad; // or req.addEventListener(&quot;load&quot;, onLoad, false);
req.onerror = onError; // or req.addEventListener(&quot;error&quot;, onError, false);
req.send(null);
</pre>

<p>The <code>onprogress</code> event&apos;s attributes, <code>position</code> and <code>totalSize</code>, indicate the current number of bytes received and the total number of bytes expected, respectively.</p>

<p>All of these events have their <code>target</code> attribute set to the <code>XMLHttpRequest</code> they correspond to.</p>

<div class="note notecard"><strong>Note:</strong> <a href="/en/Firefox_3_for_developers" title="en/Firefox_3_for_developers">Firefox 3</a> properly ensures that the values of the <code>target</code>, <code>currentTarget</code>, and <code>this</code> fields of the event object are set to reference the correct objects when calling event handlers for XML documents represented by <code>XMLDocument</code>. See <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=198595">error 198595</a> for details.</div>

<h2 id="Cross-site_XMLHttpRequest">Cross-site XMLHttpRequest</h2>

<div class="geckoVersionNote">
<p>Este artículo cubre características introducidas en Firefox 3.5.</p>
</div>

<p>Firefox 3.5 supports cross-site requests by implementing the web applications working group&apos;s <a class="internal" href="/En/HTTP_access_control" title="en/HTTP access control">Access Control for Cross-Site Requests</a> standard.  As long as the server is configured to allow requests from your web application&apos;s origin, <code>XMLHttpRequest</code> will work.  Otherwise, an <code>INVALID_ACCESS_ERR</code> exception is thrown.</p>

<h2 id="Bypassing_the_cache">Bypassing the cache</h2>

<p>Normally, <code>XMLHttpRequest</code> tries to retrieve content from the cache, if it&apos;s available.  To bypass this, do the following:</p>

<pre class="script">var req = new XMLHttpRequest();
req.open(&apos;GET&apos;, url, false);
<strong>req.channel.loadFlags |= Components.interfaces.nsIRequest.LOAD_BYPASS_CACHE;</strong>
req.send(null);</pre>

<div class="note notecard"><strong>Note:</strong> This approach will only work in Gecko-based software, as the <code>channel</code> attribute is Gecko-specific.</div>

<p>An alternate, cross-browser compatible approach is to append a timestamp to the URL, being sure to include a &quot;?&quot; or &quot;&amp;&quot; as appropriate.  For example:</p>

<pre>http://foo.com/bar.html</pre>

<p>becomes</p>

<pre>http://foo.com/bar.html?12345</pre>

<p>and</p>

<pre>http://foo.com/bar.html?foobar=baz</pre>

<p>becomes</p>

<pre>http://foo.com/bar.html?foobar=baz&amp;12345</pre>

<p>Since the local cache is indexed by URL, this causes every request to be unique, thereby bypassing the cache.</p>

<p>You can automatically adjust URLs using the following code:</p>

<pre class="script">var req = new XMLHttpRequest();
req.open(&quot;GET&quot;, url += (url.match(/\?/) == null ? &quot;?&quot; : &quot;&amp;&quot;) + (new Date()).getTime(), false);
req.send(null); </pre>

<h2 id="Security">Security</h2>

<div class="standardNote notecard">
    <p><a href="https://developer.mozilla.org/es/docs/Mozilla/Firefox/Releases/3">Nota sobre Firefox 3</a></p>
    <p style="font-weight: 400;">Versions of Firefox prior to Firefox 3 allowed you to set the preference <code>capability.policy..XMLHttpRequest.open</code> to <code>allAccess</code> to give specific sites cross-site access.  This is no longer supported.</p>
</div>

<h2 id="Downloading_JSON_and_JavaScript_from_extensions">Downloading JSON and JavaScript from extensions</h2>

<p>For security reasons, extensions should never use <code><a href="/en/JavaScript/Reference/Global_Objects/eval" title="en/Core_JavaScript_1.5_Reference/Global_Functions/eval">eval()</a></code> to parse JSON or JavaScript code downloaded from the web.  See <a href="/en/Downloading_JSON_and_JavaScript_in_extensions" title="en/Downloading_JSON_and_JavaScript_in_extensions">Downloading JSON and JavaScript in extensions</a> for details.</p>

<h2 id="Using_XMLHttpRequest_from_JavaScript_modules_XPCOM_components">Using XMLHttpRequest from JavaScript modules / XPCOM components</h2>

<p>Instantiating <code>XMLHttpRequest</code> from a <a href="/en/JavaScript_code_modules/Using" title="https://developer.mozilla.org/en/JavaScript_code_modules/Using_JavaScript_code_modules">JavaScript module</a> or an XPCOM component works a little differently; it can&apos;t be instantiated using the <code>XMLHttpRequest()</code> constructor. The constructor is not defined inside components and the code results in an error. You&apos;ll need to create and use it using a different syntax.</p>

<p>Instead of this:</p>

<pre class="script">var req = new XMLHttpRequest();
req.onprogress = onProgress;
req.onload = onLoad;
req.onerror = onError;
req.open(&quot;GET&quot;, url, true);
req.send(null);
</pre>

<p>Do this:</p>

<pre class="script">var req = Components.classes[&quot;@mozilla.org/xmlextras/xmlhttprequest;1&quot;]
                    .createInstance(Components.interfaces.nsIXMLHttpRequest);
req.onprogress = onProgress;
req.onload = onLoad;
req.onerror = onError;
req.open(&quot;GET&quot;, url, true);
req.send(null);
</pre>

<p>For C++ code you would need to <code>QueryInterface</code> the component to an <code>nsIEventTarget</code> in order to add event listeners, but chances are in C++ using a channel directly would be better.</p>

<h2 id="See_also">See also</h2>

<ol>
 <li><a href="/en/AJAX/Getting_Started" title="en/AJAX/Getting_Started">MDC AJAX introduction</a></li>
 <li><a class="internal" href="/En/HTTP_access_control" title="En/HTTP access control">HTTP access control</a></li>
 <li><a class="internal" href="/En/How_to_check_the_security_state_of_an_XMLHTTPRequest_over_SSL" title="En/How to check the security state of an XMLHTTPRequest over SSL">How to check the security state of an XMLHTTPRequest over SSL</a></li>
 <li><a class="external" href="http://www.peej.co.uk/articles/rich-user-experience.html">XMLHttpRequest - REST and the Rich User Experience</a></li>
 <li><a class="external" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/xmlsdk/html/xmobjxmlhttprequest.asp">Microsoft documentation</a></li>
 <li><a class="external" href="http://developer.apple.com/internet/webcontent/xmlhttpreq.html">Apple developers&apos; reference</a></li>
 <li><a class="external" href="http://jibbering.com/2002/4/httprequest.html">&quot;Using the XMLHttpRequest Object&quot; (jibbering.com)</a></li>
 <li><a class="external" href="http://www.w3.org/TR/XMLHttpRequest/">The XMLHttpRequest Object: W3C Working Draft</a></li>
 <li><a class="external" href="http://dev.w3.org/2006/webapi/progress/Progress.html" title="http://dev.w3.org/2006/webapi/progress/Progress.html">Web Progress Events specification</a></li>
 <li><a class="external" href="http://www.bluishcoder.co.nz/2009/06/05/reading-ogg-files-with-javascript.html" title="http://www.bluishcoder.co.nz/2009/06/05/reading-ogg-files-with-javascript.html">Reading Ogg files with JavaScript (Chris Double)</a></li>
</ol>

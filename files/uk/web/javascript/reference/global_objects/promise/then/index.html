---
title: Promise.prototype.then()
slug: Web/JavaScript/Reference/Global_Objects/Promise/then
tags:
  - ECMAScript 2015
  - JavaScript
  - Promise
  - метод
translation_of: Web/JavaScript/Reference/Global_Objects/Promise/then
---
<div><section class="Quick_links" id="Quick_Links"><ol><li><strong><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects">Standard built-in objects</a></strong></li><li><strong><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a></strong></li><li data-default-state="open"><a href="#"><strong>Methods</strong></a><ol><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"><code>Promise.all()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled"><code>Promise.allSettled()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/any"><code>Promise.any()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch"><code>Promise.prototype.catch()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally"><code>Promise.prototype.finally()</code></a></li><li><em><code>Promise.prototype.then()</code></em></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/race"><code>Promise.race()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/%D0%B2%D1%96%D0%B4%D1%85%D0%B8%D0%BB%D0%B5%D0%BD%D0%BE"><code>Promise.reject()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve"><code>Promise.resolve()</code></a></li></ol></li><li><strong>Inheritance:</strong></li><li><strong><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function"><code>Function</code></a></strong></li><li><a href="#"><strong>Properties</strong></a><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments"><code>Function.arguments</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/caller"><code>Function.caller</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/displayName"><code>Function.displayName</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/length"><code>Function.length</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/name"><code>Function.name</code></a></li></ol></li><li><a href="#"><strong>Methods</strong></a><ol><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"><code>Function.prototype.apply()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"><code>Function.prototype.bind()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/call"><code>Function.prototype.call()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="This is an obsolete API and is no longer guaranteed to work."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/toSource"><code>Function.prototype.toSource()</code></a></s></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/toString"><code>Function.prototype.toString()</code></a></li></ol></li><li><strong><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object"><code>Object</code></a></strong></li><li><a href="#"><strong>Properties</strong></a><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"><code>Object.prototype.__proto__</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor"><code>Object.prototype.constructor</code></a></li></ol></li><li><a href="#"><strong>Methods</strong></a><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__"><code>Object.prototype.__defineGetter__()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineSetter__"><code>Object.prototype.__defineSetter__()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupGetter__"><code>Object.prototype.__lookupGetter__()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupSetter__"><code>Object.prototype.__lookupSetter__()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty"><code>Object.prototype.hasOwnProperty()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf"><code>Object.prototype.isPrototypeOf()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable"><code>Object.prototype.propertyIsEnumerable()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString"><code>Object.prototype.toLocaleString()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="This is an obsolete API and is no longer guaranteed to work."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/toSource"><code>Object.prototype.toSource()</code></a></s></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/toString"><code>Object.prototype.toString()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf"><code>Object.prototype.valueOf()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"><code>Object.setPrototypeOf()</code></a></li></ol></li></ol></section></div>

<p>Метод <code><strong>then()</strong></code> вертає об&apos;єкт <a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>. Він приймає два аргументи: функції зворотного виклику для випадків успішного та неуспішного проміса.</p>

<div><iframe class="interactive interactive-js" frameborder="0" height="250" src="https://interactive-examples.mdn.mozilla.net/pages/js/promise-then.html" title="MDN Web Docs Interactive Example" width="100%"></iframe></div>

<p class="hidden">The source for this interactive demo is stored in a GitHub repository. If you&apos;d like to contribute to the interactive demo project, please clone <a href="https://github.com/mdn/interactive-examples">https://github.com/mdn/interactive-examples</a> and send us a pull request.</p>

<div class="note notecard">
<p>Якщо один чи обидва аргументи пропущені, або надані не функції, тоді <code>then</code> не матиме обробників, але не згенерує помилок. Якщо <code>Promise</code>, на якому викликається <code>then</code>, приймає стан (<code>виконання</code> або <code>відхилення</code>), для якого <code>then</code> не має обробника, новий <code>Promise</code> створюється без додаткових обробників, просто приймаючи кінцевий стан оригінального проміса, на якому було викликано <code>then</code>.</p>
</div>

<h2 id="Синтаксис">Синтаксис</h2>

<pre class="syntaxbox notranslate"><var>p.then(onFulfilled[, onRejected])</var>;

p.then(value =&gt; {
  // виконання
}, reason =&gt; {
  // відхилення
});
</pre>

<h3 id="Параметри">Параметри</h3>

<dl>
 <dt><code>onFulfilled</code> <span class="optional optionalInline notecard inline">Optional</span></dt>
 <dd><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function"><code>Функція</code></a>, що викликається, якщо <code>Promise</code> виконано. Ця функція має один аргумент, <code>значення виконання</code>. Якщо це не функція, вона внутрішньо замінюється на функцію &quot;Identity&quot; (вона повертає отриманий аргумент).</dd>
 <dt><code>onRejected</code> <span class="optional optionalInline notecard inline">Optional</span></dt>
 <dd><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function"><code>Функція</code></a>, що викликається, якщо <code>Promise</code> відхилено. Ця функція має один аргумент, <code>причина відхилення</code>. Якщо це не функція, вона внутрішньо замінюється на функцію &quot;Thrower&quot; (вона викидає помилку, яку отримала в якості аргумента).</dd>
</dl>

<h3 id="Значення_що_повертається">Значення, що повертається</h3>

<p>Як тільки <a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>проміс</code></a> був виконаний або відхилений, відповідна функція-обробник (<code style="font-style: normal; font-weight: normal;">onFulfilled</code> або <code style="font-style: normal; font-weight: normal;">onRejected</code>) буде викликана <strong>асинхронно</strong> (запланована у активному циклі потоку). Поведінка функції-обробника відповідає спеціальному набору правил. Якщо функція-обробник:</p>

<ul>
 <li>вертає значення, проміс, повернений <code>then</code>, вирішується з поверненим значенням в якості його значення.</li>
 <li>не вертає нічого, проміс, повернений <code>then</code>, вирішується зі значенням <code>undefined</code>.</li>
 <li>викидає помилку, проміс, повернений <code>then</code>, відхиляється з викинутою помилкою в якості значення.</li>
 <li>вертає вже виконаний проміс, то проміс, повернений <code>then</code>, виконується зі значенням цього проміса в якості свого значення.</li>
 <li>вертає вже відхилений проміс, то проміс, повернений <code>then</code>, відхиляється зі значенням цього проміса в якості свого значення.</li>
 <li>вертає інший проміс <strong>у стані очікування</strong>, вирішення/відхилення проміса, поверненого <code>then</code>, буде результатом вирішення/відхилення проміса, поверненого обробником. Також, вирішене значення проміса, поверненого <code>then</code>, буде тим самим, що й вирішене значення проміса, поверненого обробником.</li>
</ul>

<p>Наступний приклад демонструє асинхронність методу <code>then</code>.</p>

<pre class="brush: js notranslate">// при використанні вирішеного проміса блок &apos;then&apos; буде негайно запущений,
// але його обробники запустяться асинхронно, як демонструє console.log
const resolvedProm = Promise.resolve(33);

let thenProm = resolvedProm.then(value =&gt; {
    console.log(&quot;Це запускається після завершення головного стеку. Отримане й повернене значення: &quot; + value);
    return value;
});
// негайне логування значення thenProm
console.log(thenProm);

// використовуючи setTimeout, ми можемо відкласти виконання функції, поки стек не стане порожнім
setTimeout(() =&gt; {
    console.log(thenProm);
});


// порядок логування:
// Promise {[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined}
// &quot;Це запускається після завершення головного стеку. Отримане й повернене значення: 33&quot;
// Promise {[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 33}</pre>

<h2 id="Опис">Опис</h2>

<p>Оскільки методи <code>then</code> та <a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch"><code>Promise.prototype.catch()</code></a> вертають проміси, їх <a href="/uk/docs/Web/JavaScript/Guide/Using_promises#Chaining">можна поєднувати в ланцюги</a> — ця операція зветься <em>композицією</em>.</p>

<h2 id="Приклади">Приклади</h2>

<h3 id="Використання_метода_then">Використання метода <code>then</code></h3>

<pre class="brush: js notranslate">var p1 = new Promise((resolve, reject) =&gt; {
  resolve(&apos;Успіх!&apos;);
  // або
  // reject(new Error(&quot;Помилка!&quot;));
});

p1.then(value =&gt; {
  console.log(value); // Успіх!
}, reason =&gt; {
  console.error(reason); // Помилка!
});
</pre>

<h3 id="Ланцюгування">Ланцюгування</h3>

<p>Метод <code>then</code> вертає об&apos;єкт <code>Promise</code>, що дозволяє використовувати ланцюгування.</p>

<p>Якщо функція, передана у <code>then</code> в якості обробника, вертає об&apos;єкт <code>Promise</code>, аналогічний об&apos;єкт <code>Promise</code> буде переданий у наступний <code>then</code> ланцюга методів. Наведений нижче фрагмент імітує асинхронний код функцією <code>setTimeout</code>. </p>

<pre class="brush: js notranslate">Promise.resolve(&apos;ква&apos;)
  // 1. Отримати &quot;ква&quot;, приєднати &quot;драт&quot; та вирішити це для наступного then
  .then(function(string) {
    return new Promise(function(resolve, reject) {
      setTimeout(function() {
        string += &apos;драт&apos;;
        resolve(string);
      }, 1);
    });
  })
  // 2. отримати &quot;квадрат&quot;, призначити функцію зворотного виклику для обробки цього рядка
  // та вивести його на консоль, але не раніше повернення необробленого рядка
  // string у наступний then
  .then(function(string) {
    setTimeout(function() {
      string += &apos;ура&apos;;
      console.log(string);
    }, 1)
    return string;
  })
  // 3. вивести допоміжні повідомлення щодо того, як виконується код в цьому розділі,
  // раніше, ніж рядок string буде оброблений імітованим асинхронним кодом у
  // попередньому блоці then.
  .then(function(string) {
    console.log(&quot;Останній Then:  йой... ми не створили та не повернули екземпляр проміса &quot; +
                &quot;у попередньому then, тому послідовність може бути трохи &quot; +
                &quot;несподіваною&quot;);

    // Зауважте, що `string` не матиме частини &apos;ура&apos; в цій точці. Це тому,
    // що ми імітували його асинхронне виконання за допомогою функції setTimeout
    console.log(string);
  });

// порядок виведення:
// Останній Then: йой... ми не створили та не повернули екземпляр проміса у попередньому then, тому послідовність може бути трохи несподіваною
// квадрат
// квадратура</pre>

<p>Коли значення просто повертається з обробника <code>then</code>, він поверне <code>Promise.resolve(&lt;значення, повернене обробником, що викликався&gt;)</code>.</p>

<pre class="brush: js notranslate">var p2 = new Promise(function(resolve, reject) {
  resolve(1);
});

p2.then(function(value) {
  console.log(value); // 1
  return value + 1;
}).then(function(value) {
  console.log(value + &apos; - Синхронне значення працює&apos;);
});

p2.then(function(value) {
  console.log(value); // 1
});
</pre>

<p>Виклик <code>then</code> поверне відхилений проміс, якщо функція викидає помилку або повертає відхилений проміс.</p>

<pre class="brush: js notranslate">Promise.resolve()
  .then(() =&gt; {
    // Змушує .then() повернути відхилений проміс
    throw new Error(&apos;О, ні!&apos;);
  })
  .then(() =&gt; {
    console.log(&apos;Не викликається.&apos;);
  }, error =&gt; {
    console.error(&apos;Викликано функцію onRejected: &apos; + error.message);
  });</pre>

<p>У всіх інших випадках повертається вирішений об&apos;єкт Promise. У наступному прикладі перший <code>then()</code> поверне значення <code>42</code>, загорнуте у вирішений проміс, незважаючи на те, що попередній проміс ланцюжка був відхилений.</p>

<pre class="brush: js notranslate">Promise.reject()
  .then(() =&gt; 99, () =&gt; 42) // onRejected вертає 42, обгорнуте у вирішений Promise
  .then(solution =&gt; console.log(&apos;Вирішений зі значенням &apos; + solution)); // Вирішений зі значенням 42</pre>

<p>На практиці часто бажано перехоплювати відхилені проміси, як продемонстровано нижче, а не використовувати синтаксис <code>then</code> для двох випадків.</p>

<pre class="brush: js notranslate">Promise.resolve()
  .then(() =&gt; {
    // Змушує .then() повернути відхилений проміс
    throw new Error(&apos;О, ні!&apos;);
  })
  .catch(error =&gt; {
    console.error(&apos;Викликано функцію onRejected: &apos; + error.message);
  })
  .then(() =&gt; {
    console.log(&quot;Мене завжди викликають, навіть якщо проміс попереднього then відхилено&quot;);
  });</pre>

<p>Ви також можете використати ланцюгування, щоб реалізувати функцію з API на промісах, на основі іншої такої функції.</p>

<pre class="brush: js notranslate">function fetch_current_data() {
  // API <a href="/uk/docs/Web/API/GlobalFetch/fetch">fetch</a>() вертає проміс. Ця функція
  // створює схожий API, крім того, що над значенням
  // виконанного проміса цієї функції виконується
  // більше дій.
  return fetch(&apos;current-data.json&apos;).then(response =&gt; {
    if (response.headers.get(&apos;content-type&apos;) != &apos;application/json&apos;) {
      throw new TypeError();
    }
    var j = response.json();
    // можливо, зробити щось із j
    return j; // значення виконання, що надається користувачу
              // fetch_current_data().then()
  });
}
</pre>

<p>Якщо <code>onFulfilled</code> вертає проміс, повернене значення <code>then</code> буде вирішене чи відхилене промісом.</p>

<pre class="brush: js notranslate">function resolveLater(resolve, reject) {
  setTimeout(function() {
    resolve(10);
  }, 1000);
}
function rejectLater(resolve, reject) {
  setTimeout(function() {
    reject(new Error(&apos;Помилка&apos;));
  }, 1000);
}

var p1 = Promise.resolve(&apos;ква&apos;);
var p2 = p1.then(function() {
  // Повернути тут проміс, який буде вирішений зі значенням 10 через 1 секунду
  return new Promise(resolveLater);
});
p2.then(function(v) {
  console.log(&apos;вирішений&apos;, v);  // &quot;вирішений&quot;, 10
}, function(e) {
  // не викликається
  console.error(&apos;відхилений&apos;, e);
});

var p3 = p1.then(function() {
  // Повернути тут проміс, що відхилятиметься з помилкою &apos;Помилка&apos; через 1 секунду
  return new Promise(rejectLater);
});
p3.then(function(v) {
  // не викликається
  console.log(&apos;вирішений&apos;, v);
}, function(e) {
  console.error(&apos;відхилений&apos;, e); // &quot;відхилений&quot;, &apos;Помилка&apos;
});
</pre>

<h3 id="Поліфіл_у_стилі_window.setImmediate_на_основі_промісів">Поліфіл у стилі <a href="/uk/docs/Web/API/Window/setImmediate" title="Цей метод використовується для розбиття довгих у виконанні операцій та запуску функції зворотного виклику негайно після того, як переглядач завершив інші операції, такі, як події та оновлення відображення">window.setImmediate</a> на основі промісів</h3>

<p>Використання методу <a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"><code>Function.prototype.bind()</code></a> <code>Reflect.apply</code> (<a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Reflect/apply"><code>Reflect.apply()</code></a>) для створення функції (що не скасовується) у стилі setImmediate.</p>

<pre class="brush: js notranslate">const nextTick = (() =&gt; {
  const noop = () =&gt; {}; // буквально
  const nextTickPromise = () =&gt; Promise.resolve().then(noop);

  const rfab = Reflect.apply.bind; // (thisArg, fn, thisArg, [...args])
  const nextTick = (fn, ...args) =&gt; (
    fn !== undefined
    ? Promise.resolve(args).then(rfab(null, fn, null))
    : nextTickPromise(),
    undefined
  );
  nextTick.ntp = nextTickPromise;

  return nextTick;
})();
</pre>

<h2 id="Специфікації">Специфікації</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Специфікація</th>
  </tr>
  <tr>
   <td><a class="external" href="https://tc39.es/ecma262/#sec-promise.prototype.then" hreflang="en" lang="en">ECMAScript (ECMA-262)<br><small lang="uk">The definition of &apos;Promise.prototype.then&apos; in that specification.</small></a></td>
  </tr>
 </tbody>
</table>

<h2 id="Сумісність_з_веб-переглядачами">Сумісність з веб-переглядачами</h2>

<p class="hidden">To contribute to this compatibility data, please write a pull request against this repository: <a href="https://github.com/mdn/browser-compat-data">https://github.com/mdn/browser-compat-data</a>.</p>

<div class="bc-data" id="bcd:javascript.builtins.Promise.then"></div>

<h2 id="Див._також">Див. також</h2>

<ul>
 <li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a></li>
 <li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch"><code>Promise.prototype.catch()</code></a></li>
</ul>

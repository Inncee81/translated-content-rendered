---
title: Promise
slug: Web/JavaScript/Reference/Global_Objects/Promise
tags:
  - ECMAScript 2015
  - JavaScript
  - Promise
translation_of: Web/JavaScript/Reference/Global_Objects/Promise
---
<div><section class="Quick_links" id="Quick_Links"><ol><li><strong><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects">Standard built-in objects</a></strong></li><li><strong><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a></strong></li><li data-default-state="open"><a href="#"><strong>Methods</strong></a><ol><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"><code>Promise.all()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled"><code>Promise.allSettled()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/any"><code>Promise.any()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch"><code>Promise.prototype.catch()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally"><code>Promise.prototype.finally()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/then"><code>Promise.prototype.then()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/race"><code>Promise.race()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/%D0%B2%D1%96%D0%B4%D1%85%D0%B8%D0%BB%D0%B5%D0%BD%D0%BE"><code>Promise.reject()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve"><code>Promise.resolve()</code></a></li></ol></li><li><strong>Inheritance:</strong></li><li><strong><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function"><code>Function</code></a></strong></li><li><a href="#"><strong>Properties</strong></a><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments"><code>Function.arguments</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/caller"><code>Function.caller</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/displayName"><code>Function.displayName</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/length"><code>Function.length</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/name"><code>Function.name</code></a></li></ol></li><li><a href="#"><strong>Methods</strong></a><ol><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"><code>Function.prototype.apply()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"><code>Function.prototype.bind()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/call"><code>Function.prototype.call()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="This is an obsolete API and is no longer guaranteed to work."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/toSource"><code>Function.prototype.toSource()</code></a></s></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/toString"><code>Function.prototype.toString()</code></a></li></ol></li><li><strong><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object"><code>Object</code></a></strong></li><li><a href="#"><strong>Properties</strong></a><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"><code>Object.prototype.__proto__</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor"><code>Object.prototype.constructor</code></a></li></ol></li><li><a href="#"><strong>Methods</strong></a><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__"><code>Object.prototype.__defineGetter__()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineSetter__"><code>Object.prototype.__defineSetter__()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupGetter__"><code>Object.prototype.__lookupGetter__()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupSetter__"><code>Object.prototype.__lookupSetter__()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty"><code>Object.prototype.hasOwnProperty()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf"><code>Object.prototype.isPrototypeOf()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable"><code>Object.prototype.propertyIsEnumerable()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString"><code>Object.prototype.toLocaleString()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="This is an obsolete API and is no longer guaranteed to work."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/toSource"><code>Object.prototype.toSource()</code></a></s></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/toString"><code>Object.prototype.toString()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf"><code>Object.prototype.valueOf()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"><code>Object.setPrototypeOf()</code></a></li></ol></li></ol></section></div>

<p>Об&apos;єкт <strong><code>Promise</code></strong> відображає остаточне завершення (або неуспіх) асинхронної операції та значення, яке вона повертає.</p>

<p>Щоб дізнатись, як працюють проміси та як їх можна використовувати, радимо вам спочатку прочитати статтю <a href="/uk/docs/Web/JavaScript/Guide/Using_promises">Використання промісів</a>.</p>

<h2 id="Опис">Опис</h2>

<p><code><strong>Promise</strong></code> - це проксі для значення, яке може бути невідомим на момент створення проміса. Це дозволяє зв&apos;язувати обробники з кінцевим успішним значенням чи причиною неуспіху асинхронних дій. Таким чином, асинхронні методи повертають значення, як синхронні методи: замість того, щоб негайно повернути кінцеве значення, асинхронний метод повертає <em>проміс</em>, щоб надати значення в певний момент у майбутньому.</p>

<p>Об&apos;єкт <code>Promise</code> може знаходитись в одному з цих станів:</p>

<ul>
 <li><em>pending (у стані очікування)</em>: початковий стан, ані виконаний, ані відхилений.</li>
 <li><em>fulfilled (виконаний)</em>: означає, що операція завершилася вдало.</li>
 <li><em>rejected (відхилений)</em>: означає, що операція була неуспішною.</li>
</ul>

<p>Проміс у стані очікування може стати або виконаним (<em>fulfilled</em>) з певним значенням, або відхиленим (<em>rejected</em>) з причиною відхилення (помилкою). Коли щось із цього відбувається, викликаються відповідні обробники, що ставляться в чергу методом об&apos;єкта <code>then</code>. (Якщо проміс вже був виконаний чи відхилений ще до моменту приєднання відповідного обробника, то обробник буде викликаний, таким чином не відбувається &quot;стану гонки&quot; між завершенням асинхронної операції та приєднанням її обробників)</p>

<p>Оскільки методи <code><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/then"><code>Promise.prototype.then()</code></a></code> та <code><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch"><code>Promise.prototype.catch()</code></a></code> повертають проміси, їх можна з&apos;єднувати в ланцюжки.</p>

<p><img alt src="https://mdn.mozillademos.org/files/17088/promises.png" style="height: 297px; width: 801px;"></p>

<div class="note notecard">
<p><strong>Не варто плутати з</strong><span lang="uk"><span><strong>:</strong> Декілька інших мов мають механізми лінивих обчислень та відкладених розрахунків, які також називаються &quot;promises&quot; - наприклад,</span> Scheme. <span>Проміси у JavaScript відображають процеси, які вже відбуваються і які можуть бути з&apos;єднані в ланцюги з функціями зворотного виклику.</span> <span>Якщо вам потрібне ліниве обчислення виразу, розгляньте </span></span><a href="/uk/docs/Web/JavaScript/Reference/Functions/Стрілкові_функції">стрілкові функції</a><span lang="uk"><span> без аргументів: <code>f = () =&gt; вираз</code> для створення лінивого виразу, та <code>f()</code> для обчислення.</span></span></p>
</div>

<div class="note notecard">
<p><strong>Заувага</strong>: Проміс називають <em>встановленим</em> (<em>settled)</em>, якщо він або виконаний, або відхилений, але не знаходиться у стані очікування. Ви також почуєте термін <em>вирішений</em> (<em>resolved</em>) щодо промісів - він означає, що проміс встановлений, або ж &quot;зафіксований&quot;, щоб відповідати стану іншого проміса. Стаття <a href="https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md">States and Fates</a> містить більше подробиць щодо термінології промісів.</p>
</div>

<h2 id="Конструктор">Конструктор</h2>

<dl>
 <dt><code><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/Promise">Promise()</a></code></dt>
 <dd>Конструктор переважно використовується для загортання функцій, які самі не підтримують проміси.</dd>
</dl>

<h2 id="Властивості">Властивості</h2>

<dl>
 <dt><code>Promise.length</code></dt>
 <dd><span id="result_box" lang="uk"><span>Значення довжини, завжди дорівнює 1 (кількість аргументів конструктора)</span></span>.</dd>
 <dt><code>Promise.prototype</code></dt>
 <dd>Прототип для конструктора <code>Promise</code>.</dd>
</dl>

<h2 id="Методи">Методи</h2>

<dl>
 <dt><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/all"><code>Promise.all(iterable)</code></a></dt>
 <dd>Чекає, доки усі проміси не будуть вирішені, або поки будь-який з промісів не буде відхилений.</dd>
 <dd><span id="result_box" lang="uk"><span>Якщо повернений проміс вирішується, він вирішується із сукупним масивом значень вирішених промісів, у тому ж порядку, в якому вони визначені в ітерабельному об&apos;єкті промісів.</span> </span></dd>
 <dd><span lang="uk"><span>В разі відхилення, він відхиляється з причиною з першого відхиленого проміса у ітерабельному об&apos;єкті.</span></span></dd>
 <dt><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/allSettled"><code>Promise.allSettled(iterable)</code></a></dt>
 <dd>Чекає, доки усі проміси не будуть встановлені (кожен має бути або вирішений, або відхилений).</dd>
 <dd>Повертає проміс, який вирішується після того, як усі надані проміси були або вирішені, або відхилені, з масивом об&apos;єктів, які описують результат кожного проміса.</dd>
 <dt><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/race"><code>Promise.race(iterable)</code></a></dt>
 <dd>Чекає, доки будь-який з промісів не буде або вирішений, або відхилений.</dd>
 <dd>Якщо повернений проміс вирішений, він вирішується зі значенням першого проміса з ітерабельного об&apos;єкта, який був вирішений.</dd>
 <dd><span id="result_box" lang="uk"><span>Якщо він відхилений, він відхиляється з причиною першого відхиленого проміса.</span></span></dd>
</dl>

<dl>
 <dt><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/відхилено"><code>Promise.reject(reason)</code></a></dt>
 <dd>Повертає новий об&apos;єкт <code>Promise</code>, відхилений з наданою причиною.</dd>
</dl>

<dl>
 <dt><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve"><code>Promise.resolve(value)</code></a></dt>
 <dd><span id="result_box" lang="uk"><span>Повертає новий об&apos;єкт <code>Promise</code>, який вирішується з наданим значенням.</span> <span>Якщо значенням є промісоподібний об&apos;єкт (такий, що має метод <code>then</code>), то повернений проміс буде його &quot;дотримуватись&quot;, приймаючи його кінцевий стан; у іншому випадку повернений проміс буде виконаний з наданим значенням</span><span>.</span></span></dd>
 <dd>Загалом, якщо ви не знаєте, є значення промісом чи ні, використайте <a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve"><code>Promise.resolve(value)</code></a> та працюйте з поверненим значенням як з промісом.</dd>
</dl>

<h2 id="Прототип_Promise">Прототип Promise</h2>

<h3 id="Властивості_2">Властивості</h3>

<dl>
 <dt><code>Promise.prototype.constructor</code></dt>
 <dd>Вертає функцію, яка створила прототип екземпляра. Це за замовчуванням функція <a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>.</dd>
</dl>

<h3 id="Методи_2">Методи</h3>

<dl>
 <dt><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/catch"><code>Promise.prototype.catch()</code></a></dt>
 <dd>Додає до проміса функцію зворотного виклику для обробки відхилення та вертає новий проміс, що вирішується з поверненим значенням цієї функції, коли вона викликається, або з початковим значенням виконання, якщо проміс, навпаки, виконається.</dd>
 <dt><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/then"><code>Promise.prototype.then()</code></a></dt>
 <dd>Додає до проміса обробники виконання та відхилення та вертає новий проміс, що вирішується з поверненим значенням обробника, який викликався, або з початковим встановленим значенням, якщо проміс не оброблявся (тобто, якщо відповідний обробник <code>onFulfilled</code> чи <code>onRejected</code> не є функцією).</dd>
 <dt><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally"><code>Promise.prototype.finally()</code></a></dt>
 <dd>Додає до проміса обробник та вертає новий проміс, який вирішується, коли вирішується початковий проміс. Обробник викликається, коли проміс встановлений, тобто, або виконаний, або відхилений.</dd>
</dl>

<h2 id="Приклади">Приклади</h2>

<h3 id="Базовий_приклад">Базовий приклад</h3>

<pre class="brush: js notranslate">let myFirstPromise = new Promise((resolve, reject) =&gt; {
  // Викликаємо resolve(...), коли те, що ми робили асинхронно, успішно виконалось, і reject(...), якщо неуспішно.
  // В цьому прикладі ми використовуємо setTimeout(...) для симуляції асинхронного коду.
  // В житті ви, ймовірно, використовуватиме щось на кшталт XHR або HTML5 API.
  setTimeout( function() {
    resolve(&quot;Успіх!&quot;)  // Є! Все пройшло добре!
  }, 250)
})

myFirstPromise.then((successMessage) =&gt; {
  // successMessage - це те, що ми передаємо у наведену вище функцію resolve(...).
  // Це не обов&apos;язково має бути рядок, але, якщо це повідомлення про успіх, то, мабуть, це буде він.
  console.log(&quot;Є! &quot; + successMessage)
});</pre>

<h3 id="Ускладнений_приклад">Ускладнений приклад</h3>

<div class="hidden">
<pre class="brush: html notranslate">&lt;button id=&quot;btn&quot;&gt;Зробити проміс!&lt;/button&gt;
&lt;div id=&quot;log&quot;&gt;&lt;/div&gt;</pre>
</div>

<p>Цей маленький приклад демонструє механізм об&apos;єкта <code>Promise</code>. Метод <code>testPromise()</code> викликається кожний раз, коли натискається кнопка <a href="/uk/docs/Web/HTML/Element/button" title="The HTML &lt;button&gt; element represents a clickable button, used to submit forms or anywhere in a document for accessible, standard button functionality."><code>&lt;button&gt;</code></a>. Він створює проміс, який буде виконаний з використанням <a href="/uk/docs/Web/API/Window/setTimeout" title="REDIRECT WindowTimers.setTimeout"><code>window.setTimeout()</code></a> з лічильником проміса (число, що стартує від 1) кожні 1-3 секунди, у випадковому порядку. Конструктор <code>Promise()</code> використовується для створення проміса.</p>

<p>Виконання проміса логується просто, виконанням зворотного виклику через <a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise/then"><code>p1.then()</code></a>. Кілька логів демонструють, як синхронна частина методу відокремлюється від асинхронного завершення проміса.</p>

<pre class="brush: js notranslate">&apos;use strict&apos;;
var promiseCount = 0;

function testPromise() {
    var thisPromiseCount = ++promiseCount;

    var log = document.getElementById(&apos;log&apos;);
    log.insertAdjacentHTML(&apos;beforeend&apos;, thisPromiseCount +
        &apos;) Запуск (&lt;small&gt;Синхронний код запущено&lt;/small&gt;)&lt;br/&gt;&apos;);

    // Створюємо новий проміс: ми передаємо лічильник цього проміса, починаючи з 1 (після очікування 3с)
    var p1 = new Promise(
        // Функція вирішення викликається з можливістю вирішити або
        // відхилити проміс
        function(resolve, reject) {
            log.insertAdjacentHTML(&apos;beforeend&apos;, thisPromiseCount +
                &apos;) Запуск проміса (&lt;small&gt;Асинхронний код запущено&lt;/small&gt;)&lt;br/&gt;&apos;);
            // Це лише приклад для створення асинхронності
            window.setTimeout(
                function() {
                    // Ми виконуємо проміс!
                    resolve(thisPromiseCount);
                }, Math.random() * 2000 + 1000);
        }
    );

    // Визначаємо, що робити, коли проміс вирішено/виконано, викликом then(),
    // а метод catch() визначає, що робити, якщо проміс відхилено.
    p1.then(
        // Залогувати значення виконання
        function(val) {
            log.insertAdjacentHTML(&apos;beforeend&apos;, val +
                &apos;) Проміс виконано (&lt;small&gt;Асинхронний код завершений&lt;/small&gt;)&lt;br/&gt;&apos;);
        })
    .catch(
        // Залогувати причину відхилення
        function(reason) {
            console.log(&apos;Обробити тут відхилений проміс (&apos;+reason+&apos;).&apos;);
        });

    log.insertAdjacentHTML(&apos;beforeend&apos;, thisPromiseCount +
        &apos;) Проміс створено (&lt;small&gt;Синхронний код завершений&lt;/small&gt;)&lt;br/&gt;&apos;);
}
</pre>

<div class="hidden">
<pre class="brush: js notranslate">if (&quot;Promise&quot; in window) {
  var btn = document.getElementById(&quot;btn&quot;);
  btn.addEventListener(&quot;click&quot;,testPromise);
} else {
  log = document.getElementById(&apos;log&apos;);
  log.innerHTML = &quot;Живий приклад недоступний, оскільки ваш переглядач не підтримує інтерфейс об&apos;єктів &lt;code&gt;Promise&lt;code&gt;.&quot;;
}</pre>
</div>

<p>Цей приклад починається натисканням кнопки. Вам потрібен переглядач, що підтримує об&apos;єкти <code>Promise</code>. Натиснувши кнопку кілька разів за короткий відрізок часу, ви навіть побачите, як різні проміси виконуються один після іншого.</p>

<p><iframe class="live-sample-frame sample-code-frame" frameborder="0" height="200" id="frame_Ускладнений_приклад" src="https://mdn.mozillademos.org/uk/docs/Web/JavaScript/Reference/Global_Objects/Promise$samples/%D0%A3%D1%81%D0%BA%D0%BB%D0%B0%D0%B4%D0%BD%D0%B5%D0%BD%D0%B8%D0%B9_%D0%BF%D1%80%D0%B8%D0%BA%D0%BB%D0%B0%D0%B4?revision=1605928" width="500"></iframe></p>

<h2 id="Завантаження_зображення_за_допомогою_XHR">Завантаження зображення за допомогою XHR</h2>

<p>Інший простий приклад використання об&apos;єктів <code>Promise</code> та <code><a href="/uk/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a></code> - для завантаження зображення - доступний у репозиторії <a href="https://github.com/mdn/js-examples/tree/master/promises-test">promise-test</a> на MDN GitHub. Ви також можете <a href="https://mdn.github.io/js-examples/promises-test/">побачити його в дії</a>. Кожний крок супроводжується коментарями та дозволяє відслідкувати архітектуру Promise та XHR.</p>

<h2 id="Специфікації">Специфікації</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Specification</th>
  </tr>
  <tr>
   <td><a class="external" href="https://tc39.es/ecma262/#sec-promise-objects" hreflang="en" lang="en">ECMAScript (ECMA-262)<br><small lang="uk">The definition of &apos;Promise&apos; in that specification.</small></a></td>
  </tr>
 </tbody>
</table>

<h2 id="Сумісність_з_веб-переглядачами">Сумісність з веб-переглядачами</h2>

<p class="hidden">To contribute to this compatibility data, please write a pull request against this file: <a href="https://github.com/mdn/browser-compat-data">https://github.com/mdn/browser-compat-data</a>.</p>

<div class="bc-data" id="bcd:javascript.builtins.Promise"></div>

<h2 id="Див._також">Див. також</h2>

<ul>
 <li><a href="/uk/docs/Web/JavaScript/Guide/Using_promises">Використання промісів</a></li>
 <li><a href="http://promisesaplus.com/">Promises/A+ specification</a></li>
 <li><a href="https://medium.com/@ramsunvtech/promises-of-promise-part-1-53f769245a53">Venkatraman.R - JS Promise (Part 1, Basics)</a></li>
 <li><a href="https://medium.com/@ramsunvtech/js-promise-part-2-q-js-when-js-and-rsvp-js-af596232525c#.dzlqh6ski">Venkatraman.R - JS Promise (Part 2 - Using Q.js, When.js and RSVP.js)</a></li>
 <li><a href="https://tech.io/playgrounds/11107/tools-for-promises-unittesting/introduction">Venkatraman.R - Tools for Promises Unit Testing</a></li>
 <li><a href="http://www.html5rocks.com/en/tutorials/es6/promises/">Jake Archibald: JavaScript Promises: There and Back Again</a></li>
 <li><a href="http://de.slideshare.net/domenicdenicola/callbacks-promises-and-coroutines-oh-my-the-evolution-of-asynchronicity-in-javascript">Domenic Denicola: Callbacks, Promises, and Coroutines – Asynchronous Programming Patterns in JavaScript</a></li>
 <li><a href="http://www.mattgreer.org/articles/promises-in-wicked-detail/">Matt Greer: JavaScript Promises ... In Wicked Detail</a></li>
 <li><a href="https://www.promisejs.org/">Forbes Lindesay: promisejs.org</a></li>
 <li><a href="https://github.com/anonyco/SPromiseMeSpeedJS/blob/master/README.md">Speed-polyfill to polyfill both promise availability and promise performance.</a></li>
 <li><a href="https://github.com/jakearchibald/es6-promise/">Promise polyfill</a></li>
 <li><a href="https://www.udacity.com/course/javascript-promises--ud898">Udacity: JavaScript Promises</a></li>
</ul>

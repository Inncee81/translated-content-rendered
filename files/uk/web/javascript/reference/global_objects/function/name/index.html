---
title: Function.name
slug: Web/JavaScript/Reference/Global_Objects/Function/name
tags:
  - ECMAScript 2015
  - Function
  - JavaScript
  - Властивість
translation_of: Web/JavaScript/Reference/Global_Objects/Function/name
---
<div><section class="Quick_links" id="Quick_Links"><ol><li><strong><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects">Standard built-in objects</a></strong></li><li><strong><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function"><code>Function</code></a></strong></li><li data-default-state="open"><a href="#"><strong>Properties</strong></a><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/arguments"><code>Function.arguments</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/caller"><code>Function.caller</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/displayName"><code>Function.displayName</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/length"><code>Function.length</code></a></li><li><em><code>Function.name</code></em></li></ol></li><li data-default-state="open"><a href="#"><strong>Methods</strong></a><ol><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"><code>Function.prototype.apply()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"><code>Function.prototype.bind()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/call"><code>Function.prototype.call()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="This is an obsolete API and is no longer guaranteed to work."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/toSource"><code>Function.prototype.toSource()</code></a></s></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/toString"><code>Function.prototype.toString()</code></a></li></ol></li><li><strong>Inheritance:</strong></li><li><strong><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object"><code>Object</code></a></strong></li><li><a href="#"><strong>Properties</strong></a><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/proto"><code>Object.prototype.__proto__</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor"><code>Object.prototype.constructor</code></a></li></ol></li><li><a href="#"><strong>Methods</strong></a><ol><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineGetter__"><code>Object.prototype.__defineGetter__()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/__defineSetter__"><code>Object.prototype.__defineSetter__()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupGetter__"><code>Object.prototype.__lookupGetter__()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This deprecated API should no longer be used, but will probably still work."><i class="icon-thumbs-down-alt"> </i></span></span><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/__lookupSetter__"><code>Object.prototype.__lookupSetter__()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty"><code>Object.prototype.hasOwnProperty()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/isPrototypeOf"><code>Object.prototype.isPrototypeOf()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/propertyIsEnumerable"><code>Object.prototype.propertyIsEnumerable()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/toLocaleString"><code>Object.prototype.toLocaleString()</code></a></li><li><span class="sidebar-icon"><span class="icon-only-inline" title="This API has not been standardized."><i class="icon-warning-sign"> </i></span></span><span class="sidebar-icon"><span class="icon-only-inline" title="This is an obsolete API and is no longer guaranteed to work."><i class="icon-trash"> </i></span></span><s class="obsoleteElement"><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/toSource"><code>Object.prototype.toSource()</code></a></s></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/toString"><code>Object.prototype.toString()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf"><code>Object.prototype.valueOf()</code></a></li><li><a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf"><code>Object.setPrototypeOf()</code></a></li></ol></li></ol></section></div>

<p>Властивість тільки для читання об&apos;єкта <a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function"><code>Function</code></a> <code><strong>name</strong></code> відображає ім&apos;я функції, яке було вказане при створенні, або <code>&quot;anonymous&quot;</code> для анонімних функцій.</p>

<p><iframe class="interactive interactive-js" frameborder="0" height="250" src="https://interactive-examples.mdn.mozilla.net/pages/js/function-name.html" title="MDN Web Docs Interactive Example" width="100%"></iframe></p>

<div class="hidden">
<p>The source for this interactive example is stored in a GitHub repository. If you&apos;d like to contribute to the interactive examples project, please clone <a href="https://github.com/mdn/interactive-examples">https://github.com/mdn/interactive-examples</a> and send us a pull request.</p>
</div>

<table class="standard-table">
  <thead>
    <tr>
      <th class="header" colspan="2">Атрибути поля <code>Function.name</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Доступний для запису</td>
      <td>ні</td>
    </tr>
    <tr>
      <td>Доступний для переліку</td>
      <td>ні</td>
    </tr>
    <tr>
      <td>Доступний для налаштування</td>
      <td>так</td>
    </tr>
  </tbody>
</table>

<div class="note notecard">
<p>Зауважте, що у нестандартних реалізаціях до ES2015 атрибут <code>configurable</code> (доступний для налаштування) також мав значення <code>false</code>.</p>
</div>

<h2 id="Приклади">Приклади</h2>

<h3 id="Імя_функції">Ім&apos;я функції</h3>

<p>Властивість <code>name</code> повертає ім&apos;я функції.</p>

<pre class="brush: js notranslate">function doSomething() {}
console.log(doSomething.name); // &quot;doSomething&quot;
</pre>

<h3 id="Імя_конструктора_функції">Ім&apos;я конструктора функції</h3>

<p>Функції, створені за допомогою <code>new Function(...)</code> або просто <code>Function(...)</code> створюють об&apos;єкти <a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function"><code>Function</code></a>, а їхнє ім&apos;я &quot;anonymous&quot;.</p>

<pre class="brush: js notranslate">(new Function).name; // &quot;anonymous&quot;</pre>

<h3 id="Виведені_імена_функцій">Виведені імена функцій</h3>

<p>Змінні та методи можуть вивести ім&apos;я анонімної функції з її синтаксичної позиції (нове у ECMAScript 2015).</p>

<pre class="brush: js notranslate">var f = function() {};
var object = {
  someMethod: function() {}
};

console.log(f.name); // &quot;f&quot;
console.log(object.someMethod.name); // &quot;someMethod&quot;
</pre>

<p>Ви можете оголосити функцію з ім&apos;ям у <a href="/uk/docs/Web/JavaScript/Reference/Operators/Function">функціональному виразі</a>:</p>

<pre class="brush: js notranslate">var object = {
  someMethod: function object_someMethod() {}
};
console.log(object.someMethod.name); // виведе &quot;object_someMethod&quot;

try { object_someMethod } catch(e) { console.log(e); }
// ReferenceError: object_someMethod is not defined
</pre>

<p>Ви не можете змінювати ім&apos;я функції, ця властивість доступна лише для читання:</p>

<div class="hidden">
<p>Наведений нижче приклад суперечить тому, що сказано на початку цього розділу і не працює як описано.</p>
</div>

<pre class="brush: js notranslate">var object = {
  // anonymous
  someMethod: function() {}
};

object.someMethod.name = &apos;otherMethod&apos;;
console.log(object.someMethod.name); // someMethod
</pre>

<p>Однак, щоб змінити її, ви можете скористатись <a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty"><code>Object.defineProperty()</code></a>.</p>

<h3 id="Імена_лаконічних_методів">Імена лаконічних методів</h3>

<pre class="brush: js notranslate">var o = {
  foo(){}
};
o.foo.name; // &quot;foo&quot;;</pre>

<h3 id="Імена_звязаних_функцій">Імена зв&apos;язаних функцій</h3>

<p>Метод <a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"><code>Function.bind()</code></a> створює функцію, чиїм ім&apos;ям буде &quot;bound&quot; плюс ім&apos;я функції.</p>

<pre class="brush: js notranslate">function foo() {};
foo.bind({}).name; // &quot;bound foo&quot;</pre>

<h3 id="Імена_функцій_для_гетерів_та_сетерів">Імена функцій для гетерів та сетерів</h3>

<p>При використанні властивостей-аксесорів <code><a href="/uk/docs/Web/JavaScript/Reference/Functions/get">get</a></code> та <code><a href="/uk/docs/Web/JavaScript/Reference/Functions/set">set</a></code> у імені функції з&apos;являється &quot;get&quot; або &quot;set&quot;.</p>

<pre class="brush: js notranslate">let o = {
  get foo(){},
  set foo(x){}
};

var descriptor = Object.getOwnPropertyDescriptor(o, &quot;foo&quot;);
descriptor.get.name; // &quot;get foo&quot;
descriptor.set.name; // &quot;set foo&quot;;</pre>

<h3 id="Імена_функцій_у_класах">Імена функцій у класах</h3>

<p>Ви можете скористатись <code>obj.constructor.name</code>, щоб перевірити &quot;клас&quot; об&apos;єкта (але обов&apos;язково прочитайте застереження нижче):</p>

<pre class="brush: js notranslate">function Foo() {}  // Синтаксис ES2015: class Foo {}

var fooInstance = new Foo();
console.log(fooInstance.constructor.name); // виводить &quot;Foo&quot;</pre>

<div class="warning notecard">
<p><strong>Застереження:</strong> Інтерпретатор коду встановить значення вбудованої властивості <code>Function.name</code> тільки якщо функція не має своєї властивості з назвою <em>name</em> (дивіться розділ <a href="https://www.ecma-international.org/ecma-262/6.0/#sec-setfunctionname">9.2.11 ECMAScript2015 Language Specification</a>). Однак, ES2015 визначає ключове слово <em>static</em> таким чином, що статичні методі встановлюються як OwnProperty функції-конструктора класу (ECMAScript2015, <a href="https://www.ecma-international.org/ecma-262/6.0/#sec-runtime-semantics-classdefinitionevaluation">14.5.14.21.b</a>+ <a href="https://www.ecma-international.org/ecma-262/6.0/#sec-object-initializer-runtime-semantics-propertydefinitionevaluation">12.2.6.9</a>).</p>
</div>

<p>І тому ми не можемо отримати ім&apos;я класу фактично для жодного класу, що має статичний метод <code>name()</code>:</p>

<pre class="brush: js notranslate">class Foo {
  constructor() {}
  static name() {}
}</pre>

<p>З методом <code>static name()</code>, <code>Foo.name</code> тепер містить не ім&apos;я класу, а посилання на функцію <code>name()</code>. Наведене вище оголошення класу у синтаксисі ES2015 буде поводитись у Chrome чи Firefox схоже на наступний фрагмент коду у синтаксисі ES5:</p>

<pre class="brush: js notranslate">function Foo() {}
Object.defineProperty(Foo, &apos;name&apos;, { writable: true });
Foo.name = function() {};</pre>

<p>Спроба отримати клас <code>fooInstance</code> через <code>fooInstance.constructor.name</code> поверне нам зовсім не ім&apos;я класу, а посилання на статичний метод класу. Приклад:</p>

<pre class="brush: js notranslate">let fooInstance = new Foo();
console.log(fooInstance.constructor.name); // виводить function name()</pre>

<p>Ви могли також побачити у прикладі з синтаксисом ES5, що у Chrome чи Firefox наше статичне оголошення <code>Foo.name</code> стає <em>доступним для запису</em>. Вбудоване оголошення за відсутності користувацького статичного методу є <em>доступним лише для читання</em>:</p>

<pre class="brush: js notranslate">Foo.name = &apos;Привіт&apos;;
console.log(Foo.name);
// виведе &quot;Привіт&quot;, якщо клас має статичну властивість name(), інакше виведе &quot;Foo&quot;.</pre>

<p>Таким чином, не можна розраховувати, що вбудована властивість <code>Function.name</code> завжди міститиме ім&apos;я класу.</p>

<h3 id="Символи_в_якості_імен_функцій">Символи в якості імен функцій</h3>

<p>Якщо <a href="/uk/docs/Web/JavaScript/Reference/Global_Objects/Symbol"><code>Symbol</code></a> використовується в якості імені функції і має опис, ім&apos;ям метода буде опис у квадратних дужках.</p>

<pre class="brush: js notranslate">let sym1 = Symbol(&quot;foo&quot;);
let sym2 = Symbol();
let o = {
  [sym1]: function(){},
  [sym2]: function(){}
};

o[sym1].name; // &quot;[foo]&quot;
o[sym2].name; // &quot;&quot;</pre>

<h2 id="Компресори_та_мініфікатори_JavaScript">Компресори та мініфікатори JavaScript</h2>

<div class="warning notecard">
<p><strong>Застереження:</strong> Будьте обережні, використовуючи <code>Function.name</code> та перетворення коду, які здійснюють компресори (мініфікатори) або обфускатори JavaScript. Ці інструменти часто використовуються як частина конвеєра збірки JavaScript, щоб зменшити розмір програми перед розгортанням  у виробничому середовищі. Такі перетворення часто змінюють ім&apos;я функції під час збірки.</p>
</div>

<p>Подібний першокод:</p>

<pre class="brush: js notranslate">function Foo() {};
let foo = new Foo();

if (foo.constructor.name === &apos;Foo&apos;) {
  console.log(&quot;&apos;foo&apos; є екземпляром &apos;Foo&apos;&quot;);
} else {
  console.log(&apos;Ой-ой!&apos;);
}</pre>

<p>може бути стиснутий до:</p>

<pre class="brush: js notranslate">function a() {};
let b = new a();
if (b.constructor.name === &apos;Foo&apos;) {
  console.log(&quot;&apos;foo&apos; є екземпляром &apos;Foo&apos;&quot;);
} else {
  console.log(&apos;Ой-ой!&apos;);
}</pre>

<p>У нестиснутій версії, програма виконує правдиву гілку і виводить <code>&quot;&apos;foo&apos; є екземпляром &apos;Foo&apos;&quot;</code>. В той час, як у стиснутій версії вона поводиться по-іншому і виконує гілку else. Якщо ви покладаєтесь на <code>Function.name</code>, як у наведеному вище прикладі, переконайтесь, що ваш конвеєр збірки не змінює імена функцій, або не припускайте, що функція матиме певне ім&apos;я.</p>

<h2 id="Специфікації">Специфікації</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Специфікація</th>
   <th scope="col">Статус</th>
   <th scope="col">Коментар</th>
  </tr>
  <tr>
   <td><a class="external" href="https://www.ecma-international.org/ecma-262/6.0/#sec-name" hreflang="en" lang="en">ECMAScript 2015 (6th Edition, ECMA-262)<br><small lang="uk">The definition of &apos;name&apos; in that specification.</small></a></td>
   <td><span class="spec-Standard">Standard</span></td>
   <td>Початкове визначення.</td>
  </tr>
  <tr>
   <td><a class="external" href="https://tc39.es/ecma262/#sec-name" hreflang="en" lang="en">ECMAScript (ECMA-262)<br><small lang="uk">The definition of &apos;name&apos; in that specification.</small></a></td>
   <td><span class="spec-Living">Living Standard</span></td>
   <td></td>
  </tr>
 </tbody>
</table>

<h2 id="Сумісність_з_веб-переглядачами">Сумісність з веб-переглядачами</h2>

<div class="hidden">
<p>The compatibility table on this page is generated from structured data. If you&apos;d like to contribute to the data, please check out <a href="https://github.com/mdn/browser-compat-data">https://github.com/mdn/browser-compat-data</a> and send us a pull request.</p>
</div>

<div class="bc-data" id="bcd:javascript.builtins.Function.name"></div>

<div id="compat-mobile"></div>

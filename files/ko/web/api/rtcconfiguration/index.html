---
title: RTCConfiguration
slug: Web/API/RTCConfiguration
tags:
  - API
  - Dictionary
  - Interface
  - RTCConfiguration
  - WebRTC
translation_of: Web/API/RTCConfiguration
---
<section class="Quick_links" id="Quick_Links"><ol><li><strong><a href="/ko/docs/Web/API/WebRTC_API">WebRTC API</a></strong></li><li><strong><a href="/ko/docs/Web/API/RTCConfiguration"><code>RTCConfiguration</code></a></strong></li><li class="toggle"><details open><summary>Properties</summary><ol><li><a href="/ko/docs/Web/API/RTCConfiguration/bundlePolicy"><code>bundlePolicy</code></a> <a href="/ko/docs/Web/API/RTCConfiguration/bundlePolicy$translate" style="opacity: 0.5;">[Translate]</a></li><li><a href="/ko/docs/Web/API/RTCConfiguration/certificates"><code>certificates</code></a> <a href="/ko/docs/Web/API/RTCConfiguration/certificates$translate" style="opacity: 0.5;">[Translate]</a></li><li><a href="/ko/docs/Web/API/RTCConfiguration/iceServers"><code>iceServers</code></a> <a href="/ko/docs/Web/API/RTCConfiguration/iceServers$translate" style="opacity: 0.5;">[Translate]</a></li><li><a href="/ko/docs/Web/API/RTCConfiguration/iceTransportPolicy"><code>iceTransportPolicy</code></a> <a href="/ko/docs/Web/API/RTCConfiguration/iceTransportPolicy$translate" style="opacity: 0.5;">[Translate]</a></li></ol></details></li><li class="toggle"><details open><summary>Related pages for WebRTC</summary><ol><li><a href="/ko/docs/Web/API/MediaDevices/getUserMedia"><code>MediaDevices.getUserMedia()</code></a></li><li><a href="/ko/docs/Web/API/Navigator/mediaDevices"><code>Navigator.mediaDevices</code></a></li><li><a href="/ko/docs/Web/API/RTCCertificate"><code>RTCCertificate</code></a></li><li><a href="/ko/docs/Web/API/RTCDTMFSender"><code>RTCDTMFSender</code></a></li><li><a href="/ko/docs/Web/API/RTCDTMFToneChangeEvent"><code>RTCDTMFToneChangeEvent</code></a></li><li><a href="/ko/docs/Web/API/RTCDataChannel"><code>RTCDataChannel</code></a></li><li><a href="/ko/docs/Web/API/RTCDataChannelEvent"><code>RTCDataChannelEvent</code></a></li><li><a href="/ko/docs/Web/API/RTCDtlsTransport"><code>RTCDtlsTransport</code></a></li><li><a href="/ko/docs/Web/API/RTCErrorEvent"><code>RTCErrorEvent</code></a></li><li><a href="/ko/docs/Web/API/RTCIceCandidate"><code>RTCIceCandidate</code></a></li><li><a href="/ko/docs/Web/API/RTCIceTransport"><code>RTCIceTransport</code></a></li><li><a href="/ko/docs/Web/API/RTCPeerConnection"><code>RTCPeerConnection</code></a></li><li><a href="/ko/docs/Web/API/RTCPeerConnectionIceErrorEvent"><code>RTCPeerConnectionIceErrorEvent</code></a></li><li><a href="/ko/docs/Web/API/RTCPeerConnectionIceEvent"><code>RTCPeerConnectionIceEvent</code></a></li><li><a href="/ko/docs/Web/API/RTCRtpReceiver"><code>RTCRtpReceiver</code></a></li><li><a href="/ko/docs/Web/API/RTCRtpSender"><code>RTCRtpSender</code></a></li><li><a href="/ko/docs/Web/API/RTCRtpTransceiver"><code>RTCRtpTransceiver</code></a></li><li><a href="/ko/docs/Web/API/RTCSctpTransport"><code>RTCSctpTransport</code></a></li><li><a href="/ko/docs/Web/API/RTCSessionDescription"><code>RTCSessionDescription</code></a></li><li><a href="/ko/docs/Web/API/RTCStatsReport"><code>RTCStatsReport</code></a></li><li><a href="/ko/docs/Web/API/RTCTrackEvent"><code>RTCTrackEvent</code></a></li></ol></details></li></ol></section><div class="draft notecard">
    <p><strong>초안</strong><br>
    이 문서는 작성중입니다.</p>

</div>

<p><strong><code>RTCConfiguration</code></strong>는 <a href="/ko/docs/Web/API/RTCPeerConnection"><code>RTCPeerConnection</code></a>의 설정에 대한 옵션들을 제공합니다. 연결이 처음으로 이루어질 때 <a href="/ko/docs/Web/API/RTCPeerConnection"><code>RTCPeerConnection</code></a> 생성자에 전달되거나, 연결이 확립된 동안 설정을 확인하고 변경이 가능한<a href="/ko/docs/Web/API/RTCPeerConnection/getConfiguration"><code>RTCPeerConnection.getConfiguration()</code></a> 및 <a href="/ko/docs/Web/API/RTCPeerConnection/setConfiguration"><code>RTCPeerConnection.setConfiguration()</code></a> 메소드와 같이 사용됩니다.</p>

<p>옵션은 ICE 서버, 전달 셋팅, 그리고 identity 정보를 포함합니다.</p>

<h2 id="속성">속성</h2>

<dl>
 <dt><a href="/ko/docs/Web/API/RTCConfiguration/bundlePolicy"><code>bundlePolicy</code></a> <span class="optional optionalInline notecard inline">Optional</span></dt>
 <dd>원격 피어가 <a href="https://webrtcstandards.info/sdp-bundle/">SDP BUNDLE standard</a>에 호환이 불가능할 때, 어떻게 candidate의 네고시에이션을 처리 할 것인지를 정의합니다. 이 옵션은 무조건 enum <code><a href="#RTCBundlePolicy_enum">RTCBundlePolicy</a></code>의 값들 중 하나여야만 합니다. 만약 이 값이 딕셔너리에 없으면, <code>&quot;balanced&quot;</code> 으로 지정됩니다.</dd>
 <dt><a href="/ko/docs/Web/API/RTCConfiguration/certificates"><code>certificates</code></a> <span class="optional optionalInline notecard inline">Optional</span></dt>
 <dd>인증을 위해 연결에서 사용되는 <a href="/ko/docs/Web/API/RTCCertificate"><code>RTCCertificate</code></a> 타입의 객체의 <a href="/ko/docs/Web/JavaScript/Reference/Global_Objects/Array"><code>Array</code></a> 입니다. 이 속성이 정의되어있지 않으면, 각 <a href="/ko/docs/Web/API/RTCPeerConnection"><code>RTCPeerConnection</code></a> 인스턴스별로 자동으로 인증서 모음이 생성됩니다. 하나의 연결에는 오직 한개의 인증서만 사용이 되지만, 여러 알고리즘들에 대해 다수의 인증서를 제공하는 방법으로 어떤 상황에서 우연치 않게 연결이 성공되는 경우를 줄일 수 있습니다. 아래는 <a href="#Using_certificates">Using certificates</a>에 대한 추가 정보입니다.
 <div class="note notecard">이 설정 옵션은 한 번 정의되면 변경이 불가능합니다. 한 번 인증서가 지정되면, 그 후 발생하는 <a href="/ko/docs/Web/API/RTCPeerConnection/setConfiguration"><code>RTCPeerConnection.setConfiguration()</code></a> 호출에서 이 속성이 무시됩니다.</div>
 </dd>
 <dt><a href="/ko/docs/Web/API/RTCConfiguration/iceCandidatePoolSize"><code>iceCandidatePoolSize</code></a> <span class="optional optionalInline notecard inline">Optional</span></dt>
 <dd>미리 가져와진 ICE candidate pool의 크기를 정의하는 서명되지 않은 16-bit 정수 값. 기본 값은 0으로 candidate를 미리 가져오는 것이 발생하지 않음을 뜻함. 연결 시도를 시작하기전에 ICE 에이전트가 ICE candidates를 미리 가져오게 허용하면, candidate들은  <a href="/ko/docs/Web/API/RTCPeerConnection/setLocalDescription"><code>RTCPeerConnection.setLocalDescription()</code></a> 호출로 이미 확인이 가능하게 되고, 이로 인해 몇몇 상황에서 연결이 더 빠르게 성립됩니다.
 <div class="note notecard">ICE candidate pool의 크기 변경은 ICE 수집을 시작하게 만들 수 있습니다.</div>
 </dd>
 <dt><a href="/ko/docs/Web/API/RTCConfiguration/iceServers"><code>iceServers</code></a> <span class="optional optionalInline notecard inline">Optional</span></dt>
 <dd>ICE 에이전트에 의해 이용될 수 있는 하나의 서버를 설명하는 <a href="/ko/docs/Web/API/RTCIceServer"><code>RTCIceServer</code></a> 객체의 배열. 일반적으로 STUN 혹은 TURN 서버들입니다. 이 옵션이 정의가 안되어있으면, ICE 에이전트는 자체 ICE 서버를 선택하여 사용 할 수 있습니다. 자체 서버가 없다면, 연결은 사용 가능한 STUN 혹은 TURN 서버 없이 진행되고, 이는 로컬 피어와의 연결을 제한합니다. </dd>
 <dt><a href="/ko/docs/Web/API/RTCConfiguration/iceTransportPolicy"><code>iceTransportPolicy</code></a> <span class="optional optionalInline notecard inline">Optional</span></dt>
 <dd>현재 ICE 전송 정책; 이는 <code><a href="#RTCIceTransportPolicy_enum">RTCIceTransportPolicy</a></code> enum에 존재하는 값입니다. 이 옵션이 정의가 안되어있으면, <code>&quot;all&quot;</code>로 설정됩니다.</dd>
 <dt><a href="/ko/docs/Web/API/RTCConfiguration/peerIdentity"><code>peerIdentity</code></a> <span class="optional optionalInline notecard inline">Optional</span></dt>
 <dd><a href="/ko/docs/Web/API/RTCPeerConnection"><code>RTCPeerConnection</code></a>에 대한 타겟 피어 identity를 명시하는 <a href="/ko/docs/Web/API/DOMString"><code>DOMString</code></a>. 이 값이 지정되어있으면, <code>RTCPeerConnection</code>은 주어진 이름으로 인증이 성공하지 않는 이상 원격 피어와 연결하지 않습니다. (기본 값은 <code>null</code> 입니다.) </dd>
 <dt><a href="/ko/docs/Web/API/RTCConfiguration/rtcpMuxPolicy"><code>rtcpMuxPolicy</code></a> <span class="optional optionalInline notecard inline">Optional</span></dt>
 <dd>non-multiplexed RTCP를 지원하기 위해, ICE candidate를 수집 할 때 사용되는 RTCP mux 정책. 이 값은 <a href="#RTCRtcpMuxPolicy_enum"><code>RTCRtcpMuxPolicy</code> enum</a>.에 존재하는 값입니다. 기본 값은 <code>&quot;require&quot;</code>입니다.</dd>
</dl>

<h2 id="상수">상수</h2>

<h3 id="RTCBundlePolicy_enum">RTCBundlePolicy enum</h3>

<p>The <code>RTCBundlePolicy</code> enum defines string constants which are used to request a specific policy for gathering ICE candidates if the remote peer isn&apos;t &quot;BUNDLE-aware&quot; (compatible with the <a href="https://webrtcstandards.info/sdp-bundle/">SDP BUNDLE standard</a> for bundling multiple media streams on a single transport link). All browser implementations are BUNDLE-aware.</p>

<p>If the remote endpoint is BUNDLE-aware, all media tracks and data channels are bundled onto a single transport at the completion of negotiation, regardless of policy used, and any superfluous transports that were created initially are closed at that point.</p>

<div class="note notecard">
<p><strong>Note:</strong> In technical terms, a BUNDLE lets all media flow between two peers flow across a single <strong>5-tuple</strong>; that is, from a single IP and port on one peer to a single IP and port on the other peer, using the same transport protocol.</p>
</div>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col">Constant</th>
   <th scope="col">Description</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>&quot;balanced&quot;</code></td>
   <td>The ICE agent initially creates one <a href="/en-US/docs/Web/API/RTCDtlsTransport"><code>RTCDtlsTransport</code></a> for each type of content added: audio, video, and data channels. If the remote endpoint is not BUNDLE-aware, then each of these DTLS transports then handles all the communication for one type of data.</td>
  </tr>
  <tr>
   <td><code>&quot;max-compat&quot;</code></td>
   <td>The ICE agent initially creates one <a href="/en-US/docs/Web/API/RTCDtlsTransport"><code>RTCDtlsTransport</code></a> per media track and a separate one for data channels. If the remote endpoint is not BUNDLE-aware, everything is negotiated on these separate DTLS transports.</td>
  </tr>
  <tr>
   <td><code>&quot;max-bundle&quot;</code></td>
   <td>The ICE agent initially creates only a single <a href="/en-US/docs/Web/API/RTCDtlsTransport"><code>RTCDtlsTransport</code></a> to carry all of the <code>RTCPeerConnection</code>&apos;s data. If the remote endpoint is not BUNDLE-aware, then only a single track will be negotiated and the rest ignored.</td>
  </tr>
 </tbody>
</table>

<h3 id="RTCIceTransportPolicy_enum">RTCIceTransportPolicy enum</h3>

<p>The <code>RTCIceTransportPolicy</code> enum defines string constants which can be used to limit the transport policies of the ICE candidates to be considered during the connection process.</p>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col">Constant</th>
   <th scope="col">Description</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>&quot;all&quot;</code></td>
   <td>All ICE candidates will be considered.</td>
  </tr>
  <tr>
   <td><code>&quot;public&quot; </code><span class="icon-only-inline" title="This is an obsolete API and is no longer guaranteed to work."><i class="icon-trash"> </i></span></td>
   <td>Only ICE candidates with public IP addresses will be considered. <em>Removed from the specification&apos;s May 13, 2016 working draft.</em></td>
  </tr>
  <tr>
   <td><code>&quot;relay&quot;</code></td>
   <td>Only ICE candidates whose IP addresses are being relayed, such as those being passed through a TURN server, will be considered.</td>
  </tr>
 </tbody>
</table>

<h3 id="RTCRtcpMuxPolicy_enum">RTCRtcpMuxPolicy enum</h3>

<p>The <code>RTCRtcpMuxPolicy</code> enum defines string constants which specify what ICE candidates are gathered to support non-multiplexed RTCP. <strong>&lt;&lt;&lt;add a link to info about multiplexed RTCP.</strong></p>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col">Constant</th>
   <th scope="col">Description</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td><code>&quot;negotiate&quot;</code></td>
   <td>Instructs the ICE agent to gather both <a href="/en-US/docs/Glossary/RTP">RTP</a> and <a href="/en-US/docs/Glossary/RTCP">RTCP</a> candidates. If the remote peer can multiplex RTCP, then RTCP candidates are multiplexed atop the corresponding RTP candidates. Otherwise, both the RTP and RTCP candidates are returned, separately.</td>
  </tr>
  <tr>
   <td><code>&quot;require&quot;</code></td>
   <td>Tells the ICE agent to gather ICE candidates for only RTP, and to multiplex RTCP atop them. If the remote peer doesn&apos;t support RTCP multiplexing, then session negotiation fails.</td>
  </tr>
 </tbody>
</table>

<h2 id="인증서_사용하기">인증서 사용하기</h2>

<p><code>RTCPeerConnection</code>가 자동으로 생성하는 인증서 대신에, 사용자가 직접 <a href="/ko/docs/Web/API/RTCPeerConnection"><code>RTCPeerConnection</code></a>을 위한 자체 인증서를 만들기를 원한다면 <a href="/ko/docs/Web/API/RTCPeerConnection/generateCertificate"><code>RTCPeerConnection.generateCertificate()</code></a> 호출 합니다. </p>

<p>이 속성은 다중 인증서 제공을 지원합니다. 이는 주어진 DTLS 연결이 오직 하나의 인증서를 사용한다해도, 다중 인증서는 여러개의 암호화 알고리즘 지원을 허용하기 때문입니다. <code>RTCPeerConnection</code>의 구현은 DTLS 합의 중 결정된 알고리즘 및 원격 피어에 근거해서 어떤 인증서를 사용 할지 선택합니다.</p>

<p>인증서를 제공하지 않으면, 신규 인증서가 자동으로 생성이 됩니다. 사용자 자체의 identity 키를 제공하는 것의 한 가지 명백한 장점은 연속성입니다. 동일한 인증서를 이후 호출에도 사용하게되면, 원격 피어는 사용자가 같은 caller인지 알 수 있습니다. 또한, 새로운 인증키를 발급하지 않아도 됩니다. </p>

<p>&lt;&lt;&lt;link to added info on identity&gt;&gt;&gt;</p>

<h2 id="예시">예시</h2>

<p>아래 설정은 두개의 ICE 서버를 구축합니다. 첫 번째 서버, <code>stun:stun.services.mozilla.com</code>는 인증을 요구하기 때문에 유저 이름과 비밀번호를 제공합니다. 두 번째 서버는 두 개의 URL 주소가 있습니다: <code>stun:stun.example.com</code>와 <code>stun:stun-1.example.com</code>입니다.</p>

<pre class="brush: js notranslate">var configuration = { iceServers: [{
                          urls: &quot;stun:stun.services.mozilla.com&quot;,
                          username: &quot;louis@mozilla.com&quot;,
                          credential: &quot;webrtcdemo&quot;
                      }, {
                          urls: [&quot;stun:stun.example.com&quot;, &quot;stun:stun-1.example.com&quot;]
                      }]
};

var pc = new RTCPeerConnection(configuration);</pre>

<h2 id="사양서">사양서</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th scope="col">Specification</th>
   <th scope="col">Status</th>
   <th scope="col">Comment</th>
  </tr>
  <tr>
   <td><a class="external" href="https://w3c.github.io/webrtc-pc/#dom-rtcconfiguration" hreflang="en" lang="en">WebRTC 1.0: Real-time Communication Between Browsers<br><small lang="ko">The definition of &apos;RTCConfiguration&apos; in that specification.</small></a></td>
   <td><span class="spec-CR">Candidate Recommendation</span></td>
   <td>Initial definition.</td>
  </tr>
 </tbody>
</table>

<h2 id="브라우저_호환성">브라우저 호환성</h2>

<div>
<div class="hidden">The compatibility table on this page is generated from structured data. If you&apos;d like to contribute to the data, please check out <a href="https://github.com/mdn/browser-compat-data">https://github.com/mdn/browser-compat-data</a> and send us a pull request.</div>

<div class="bc-data" id="bcd:api.RTCConfiguration"></div>
</div>

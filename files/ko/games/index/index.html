---
title: Index
slug: Games/Index
tags:
  - Meta
translation_of: Games/Index
---
<div><section class="Quick_links" id="Quick_Links">
  <ol>
    <li class="toggle">
        <details>
            <summary>웹 게임 개발 소개</summary>
            <ol>
              <li><a href="/ko/docs/Games/Introduction">웹 게임 개발 소개</a></li>
              <li><a href="/ko/docs/Games/Anatomy">비디오 게임 구조 파악하기</a></li>
              <li><a href="/ko/docs/Games/Examples">예제</a></li>
            </ol>
        </details>
    </li>
    <li class="toggle">
        <details>
            <summary>게임 개발에 필요한 API</summary>
            <ol>
              <li><a href="/ko/docs/Web/API/Canvas_API">Canvas</a></li>
              <li><a href="/ko/docs/Web/CSS">CSS</a></li>
              <li><a href="/ko/docs/Web/Apps/Fundamentals/User_notifications/Full_screen_api">Full screen</a></li>
              <li><a href="/ko/docs/Web/API/Gamepad_API">Gamepad</a></li>
              <li><a href="/ko/docs/Web/API/IndexedDB_API">IndexedDB</a></li>
              <li><a href="/ko/docs/Web/JavaScript">JavaScript</a></li>
              <li><a href="/ko/docs/Web/API/Pointer_Lock_API">Pointer Lock</a></li>
              <li><a href="/ko/docs/Web/SVG">SVG</a></li>
              <li><a href="/ko/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">Typed Arrays</a></li>
              <li><a href="/ko/docs/Web/API/Web_Audio_API">Web Audio</a></li>
              <li><a href="/ko/docs/Web/API/WebGL_API">WebGL</a></li>
              <li><a href="/ko/docs/Web/API/WebRTC_API">WebRTC</a></li>
              <li><a href="/ko/docs/Web/API/WebSockets_API">WebSockets</a></li>
              <li><a href="/ko/docs/Web/API/WebVR_API">WebVR</a></li>
              <li><a href="/ko/docs/Web/API/Web_Workers_API">Web Workers</a></li>
              <li><a href="/ko/docs/Web/API/XMLHttpRequest">XMLHttpRequest</a></li>
            </ol>
        </details>
    </li>
    <li class="toggle">
        <details>
            <summary>기술</summary>
            <ol>
              <li><a href="/ko/docs/Games/Techniques/Async_scripts">asm.js를 위해 async 스크립트 사용하기</a></li>
              <li><a href="/ko/docs/Web/Apps/Developing/Optimizing_startup_performance">시작 단계 성능 최적화 하기</a></li>
              <li><a href="/ko/docs/Games/Techniques/WebRTC_data_channels">피어-투-피어 데이터 채널을 위해 WebRTC 사용하기</a></li>
              <li><a href="/ko/docs/Games/Techniques/Efficient_animation_for_web_games">웹 게임을 위한 효율적인 애니메이션</a></li>
              <li><a href="/ko/docs/Games/Techniques/Audio_for_Web_Games">웹 게임을 위한 오디오</a></li>
              <li><a href="/ko/docs/Games/Techniques/2D_collision_detection">2D 충돌 감지</a></li>
              <li><a href="/ko/docs/Games/Techniques/Tilemaps">타일과 타일맵 개요</a></li>
            </ol>
        </details>
    </li>
    <li class="toggle">
        <details>
            <summary>웹 3D 게임</summary>
            <ol>
              <li><a href="/ko/docs/Games/Techniques/3D_on_the_web">웹 3D 게임</a></li>
              <li><a href="/ko/docs/Games/Techniques/3D_on_the_web/Basic_theory">기본적인 3D 이론</a></li>
              <li><a href="/ko/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_A-Frame">Building up a basic demo with A-Frame</a></li>
              <li><a href="/ko/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Babylon.js">Building up a basic demo with Babylon.js</a></li>
              <li><a href="/ko/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_PlayCanvas">PlayCanvas를 사용하여 데모 만들기</a></li>
              <li><a href="/ko/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Three.js">Three.js를 사용하여 데모 만들기</a></li>
              <li><a href="/ko/docs/Games/Techniques/3D_on_the_web/WebVR">WebVR</a></li>
              <li><a href="/ko/docs/Games/Techniques/3D_collision_detection">3D 충돌 감지</a></li>
              <li><a href="/ko/docs/Games/Techniques/3D_collision_detection/Bounding_volume_collision_detection_with_THREE.js">THREE.js를 사용한 충돌 용적 감지</a></li>
            </ol>
        </details>
    </li>
    <li class="toggle">
        <details>
            <summary>Implementing game control mechanisms</summary>
            <ol>
              <li><a href="/ko/docs/Games/Techniques/Control_mechanisms">Control mechanisms</a></li>
              <li><a href="/ko/docs/Games/Techniques/Control_mechanisms/Mobile_touch">Mobile touch</a></li>
              <li><a href="/ko/docs/Games/Techniques/Control_mechanisms/Desktop_with_mouse_and_keyboard">Desktop with mouse and keyboard</a></li>
              <li><a href="/ko/docs/Games/Techniques/Control_mechanisms/Desktop_with_gamepad">Desktop with gamepad</a></li>
              <li><a href="/ko/docs/Games/Techniques/Control_mechanisms/Other">Other</a></li>
            </ol>
        </details>
    </li>
    <li class="toggle">
        <details>
            <summary>튜토리얼</summary>
            <ol>
              <li><a href="/ko/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript">순수 자바스크립트를 사용한 2D 게임</a></li>
              <li><a href="/ko/docs/Games/Tutorials/2D_breakout_game_Phaser">Phaser를 사용한 2D 게임</a></li>
              <li><a href="/ko/docs/Games/Tutorials/HTML5_Gamedev_Phaser_Device_Orientation">기기 수평/수직 기능을 활용한 2D 주사위 게임</a></li>
              <li><a href="https://mozdevs.github.io/html5-games-workshop/en/guides/platformer/start-here/">2D platform game using Phaser</a></li>
            </ol>
        </details>
    </li>
    <li class="toggle">
        <details>
            <summary>게임 배포하기</summary>
            <ol>
              <li><a href="/ko/docs/Games/Publishing_games">게임 배포하기 개요</a></li>
              <li><a href="/ko/docs/Games/Publishing_games/Game_distribution">게임 배포하기</a></li>
              <li><a href="/ko/docs/Games/Publishing_games/Game_promotion">게임 홍보하기</a></li>
              <li><a href="/ko/docs/Games/Publishing_games/Game_monetization">게임 결제기능</a></li>
            </ol>
        </details>
    </li>
  </ol>
</section></div>

<p><strong>Found 73 pages:</strong></p>
<table class="fullwidth-table standard-table">
<thead>
    <tr><th>#</th>
    <th>Page</th>
    <th>Tags and summary</th>
</tr></thead>
<tbody>


<tr>
    <td rowspan="2">1</td>
    <td rowspan="2"><a href="/en-US/docs/Games">Game development</a></td>
    <td><strong>Apps, Game Development, Gamedev, Games, HTML5 Games, JavaScript Games, Web</strong></td>
</tr>
<tr>
    <td>Gaming is one of the most popular computer activities. New technologies are constantly arriving to make it possible to develop better and more powerful games that can be run in any standards-compliant web browser.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">2</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Anatomy">Anatomy of a video game</a></td>
    <td><strong>Games, JavaScript, Main Loop, requestAnimationFrame</strong></td>
</tr>
<tr>
    <td>I want to be clear that any of the above, or none of them, could be best for your game. The correct decision entirely depends on the trade-offs that you are willing (and unwilling) to make. The concern is mostly with switching to another option. Fortunately, I do not have any experience with this, but I have heard it is an excruciating game of Whack-a-Mole.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">3</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Examples">Examples</a></td>
    <td><strong>Demos, Example, Games, Web</strong></td>
</tr>
<tr>
    <td>This page lists a number of impressive web technology demos for you to get inspiration from, and generally have fun with. A testament to what can be done with JavaScript, WebGL, and related technologies.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">4</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Index">Index</a></td>
    <td><strong>Meta</strong></td>
</tr>
<tr>
    <td><strong>Found 73 pages:</strong></td>
</tr><tr>

</tr><tr>
    <td rowspan="2">5</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Introduction_to_HTML5_Game_Development_(summary)">Introduction to HTML5 Game Development (summary)</a></td>
    <td><strong>Firefox OS, Games, HTML5, Mobile</strong></td>
</tr>
<tr>
    <td>Games built with HTML5 work on smartphones, tablets, PCs and Smart TVs.Update your game whenever you want.Players can play the game anywhere, anytime.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">6</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Introduction">Introduction to game development for the Web</a></td>
    <td><strong>Firefox OS, Games, Guide, Mobile</strong></td>
</tr>
<tr>
    <td>The modern web has quickly become a viable platform not only for creating stunning, high quality games, but also for distributing those games.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">7</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Publishing_games">Publishing games</a></td>
    <td><strong>Games, HTML5, JavaScript, Monetization, Promotion, distribution, publishing</strong></td>
</tr>
<tr>
    <td>This series of articles looks at the options you have when you want to publish and distribute your game, and earn something out of it while you wait for it to become famous.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">8</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Publishing_games/Game_distribution">Game distribution</a></td>
    <td><strong>CocoonIO, Game, Game publishing, Games, Gaming, HTML5, JavaScript, Mobile Game Distribution, Phonegap, Web Stores, distribution</strong></td>
</tr>
<tr>
    <td>Distribution is the way to give the world access to your game. There are many options available and there's no single good answer as to which is the best. When you've published the game it's time to focus on <a href="https://developer.mozilla.org/en-US/docs/Games/Techniques/Publishing_games/Game_promotion/">promotion</a> — letting people know your game exists. Without promotion, they wouldn't even be able to learn about it and play it.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">9</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Publishing_games/Game_monetization">Game monetization</a></td>
    <td><strong>Games, HTML5, JavaScript, Monetization, advertisements, branding, iap, licensing</strong></td>
</tr>
<tr>
    <td>There are many ways to earn money — everything that applies to the "normal" AAA gaming world can be, more or less, applied to casual HTML5 games. You might however also focus on selling licenses, doing branding, or earning on a revenue share basis from the advertisements. It's totally up to you which path you're going to follow.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">10</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Publishing_games/Game_promotion">Game promotion</a></td>
    <td><strong>Community, Games, JavaScript, Online Games, Promotion, blog, competitions</strong></td>
</tr>
<tr>
    <td>Any way of promoting your game is good. You have a whole lot of options to chose from with most of them being free, so it's only about your enthusiasm and available time. Sometimes you have to spend more time promoting a game than actually developing it. Remember that it's no use to have the best game in the world if no one knows it exists.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">11</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques">Techniques for game development</a></td>
    <td><strong>Games, Guide</strong></td>
</tr>
<tr>
    <td>This page lists essential core techniques for anyone wanting to develop games using open web technologies.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">12</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/2D_collision_detection">2D collision detection</a></td>
    <td><strong>2D, Games, JavaScript, collision detection</strong></td>
</tr>
<tr>
    <td>One of the simpler forms of collision detection is between two rectangles that are axis aligned — meaning no rotation. The algorithm works by ensuring there is no gap between any of the 4 sides of the rectangles. Any gap means a collision does not exist.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">13</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/3D_collision_detection">3D collision detection</a></td>
    <td><strong>3D, Games, JavaScript, bounding boxes, collision detection</strong></td>
</tr>
<tr>
    <td>This article provides an introduction to the different bounding volume techniques used to implement collision detection in 3D environments. Followup articles will cover implementations in specific 3D libraries.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">14</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/3D_collision_detection/Bounding_volume_collision_detection_with_THREE.js">Bounding volume collision detection with THREE.js</a></td>
    <td><strong>3D, Games, JavaScript, WebGL, bounding boxes, collision detection, three.js</strong></td>
</tr>
<tr>
    <td>This article shows how to implement <strong>collision detection between bounding boxes and spheres using the Three.js</strong> library. It is assumed that before reading this you have read our <a href="/en-US/docs/Games/Techniques/3D_collision_detection">3D collision detection</a> introductory article first, and have basic knowledge about Three.js.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">15</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/3D_on_the_web">3D games on the Web</a></td>
    <td><strong>Games, Graphics, NeedsContent, NeedsExample, WebGL, WebVR, three.js</strong></td>
</tr>
<tr>
    <td>For rich gaming experiences on the web, the weapon of choice is WebGL, which is rendered on HTML <a href="/en-US/docs/Web/HTML/Element/canvas" title="Use the HTML &lt;canvas> element with either the canvas scripting API or the WebGL API to draw graphics and animations."><code>&lt;canvas&gt;</code></a>. WebGL is basically an OpenGL ES 2.0 for the Web — it's a JavaScript API providing tools to build rich interactive animations and of course, also games. You can generate and render dynamic 3D graphics with JavaScript that is hardware accelerated.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">16</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_A-Frame">Building up a basic demo with A-Frame</a></td>
    <td><strong>3D, A-Frame, VR, Virtual Reality, Web, WebGL</strong></td>
</tr>
<tr>
    <td>The <a href="https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_on_the_web/WebVR">WebVR</a> and <a href="/en-US/docs/Web/API/WebGL_API">WebGL</a> APIs already enable us to start creating virtual reality (VR) experiences inside web browsers, but the community is still waiting for tools and libraries to appear, to make this easier. Mozilla's <a href="https://aframe.io/">A-Frame</a> framework provides a markup language allowing us to build 3D VR landscapes using a system familiar to web developers, which follows game development coding principles; this is useful for quickly and successfully building prototypes and demos, without having to write a lot of JavaScript or GLSL. This article explains how to get up and running with A-Frame, and how to use it to build up a simple demo.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">17</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Babylon.js">Building up a basic demo with Babylon.js</a></td>
    <td><strong>3D game engines, Babylon.js, Beginner, WebGL</strong></td>
</tr>
<tr>
    <td><span class="seosummary"><a href="http://babylonjs.com/">Babylon.js</a> is one of the most popular 3D game engines used by developers. As with any other 3D library it provides built-in functions to help you implement common 3D functionality more quickly. In this article we'll take you through the real basics of using Babylon.js, including setting up a development environment, structuring the necessary HTML, and writing the JavaScript code.</span></td>
</tr><tr>

</tr><tr>
    <td rowspan="2">18</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_PlayCanvas">Building up a basic demo with PlayCanvas</a></td>
    <td><strong>3D, Animation, Beginner, Canvas, Games, PlayCanvas, Tutorial, WebGL, camera, lighting, rendering</strong></td>
</tr>
<tr>
    <td>Of course, it depends on your approach — designers may favor the online editor while programmers will prefer having the full control over the coding environment and will probably use the engine's source files. The good thing is that you have a choice and can pick whatever tools suit you best.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">19</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_PlayCanvas/editor">Building up a basic demo with PlayCanvas editor</a></td>
    <td><strong>3D, Animation, Beginner, Canvas, Games, Lightning, Online, PlayCanvas, Tutorial, WebGL, camera, editor, rendering</strong></td>
</tr>
<tr>
    <td>Now you can check the <a href="https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_PlayCanvas/engine">PlayCanvas engine</a> article if you haven't seen it yet, go back to the <a href="https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_PlayCanvas">Building up a basic demo with PlayCanvas</a> page, or go back a level higher to the main <a href="https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_on_the_web">3D Games on the Web</a> page.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">20</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_PlayCanvas/engine">Building up a basic demo with the PlayCanvas engine</a></td>
    <td><strong>3D, Animation, Beginner, Canvas, Games, PlayCanvas, Tutorial, WebGL, camera, engine, lighting, rendering</strong></td>
</tr>
<tr>
    <td>Now you can continue reading the <a href="https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_PlayCanvas/editor">PlayCanvas editor</a> article, go back to the <a href="https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_PlayCanvas">Building up a basic demo with PlayCanvas</a> page, or go back a level higher to the main <a href="https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_on_the_web">3D Games on the Web</a> page.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">21</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/3D_on_the_web/Building_up_a_basic_demo_with_Three.js">Building up a basic demo with Three.js</a></td>
    <td><strong>3D, Animation, Beginner, Canvas, Games, Tutorial, WebGL, camera, lighting, rendering, three.js</strong></td>
</tr>
<tr>
    <td>In this article we'll take you through the real basics of using Three, including setting up a development environment, structuring the necessary HTML, the fundamental objects of Three, and how to build up a basic demo.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">22</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/3D_on_the_web/Basic_theory">Explaining basic 3D theory</a></td>
    <td><strong>3D, Coordinates, Textures, basics, fragment, lighting, primitives, rendering, theory, vertex, vertices</strong></td>
</tr>
<tr>
    <td>This article explains all of the basic theory that's useful to know when you are getting started working with 3D.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">23</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/3D_on_the_web/GLSL_Shaders">GLSL Shaders</a></td>
    <td><strong>Beginner, GLSL, OpenGL, Shader, texture shader, three.js, vertex shader</strong></td>
</tr>
<tr>
    <td><span class="seosummary">Shaders use GLSL (</span><span class="ILfuVd">OpenGL Shading Language</span>)<span class="seosummary">, a special OpenGL Shading Language with syntax similar to C. GLSL is executed directly by the graphics pipeline. There are two types of shaders: Vertex Shaders and Fragment (Pixel) Shaders. Vertex Shaders transform shape positions into 3D drawing coordinates. Fragment Shaders compute the renderings of a shape's colors and other attributes.</span></td>
</tr><tr>

</tr><tr>
    <td rowspan="2">24</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/3D_on_the_web/WebVR">WebVR — Virtual Reality for the Web</a></td>
    <td><strong>3D, Games, WebGL, WebVR</strong></td>
</tr>
<tr>
    <td>The concept of virtual reality in itself isn't new, but now we have the technology to have it working as it should be, and a JavaScript API to make use of it in web applications. This article introduced WebVR from the perspective of its use in games.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">25</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/Async_scripts">Async scripts for asm.js</a></td>
    <td><strong>Games, JavaScript, asm.js, async</strong></td>
</tr>
<tr>
    <td>Every medium or large game should compile <a href="/en-US/docs/Games/Tools/asm.js">asm.js</a> code as part of an async script to give the browser the maximum flexibility to optimize the compilation process. In Gecko, async compilation allows the JavaScript engine to compile the asm.js off the main thread when the game is loading and cache the generated machine code so that the game doesn't need to be compiled on subsequent loads (starting in Firefox 28). To see the difference, toggle <code>javascript.options.parallel_parsing</code> in <code>about:config</code>.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">26</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/Audio_for_Web_Games">Audio for Web games</a></td>
    <td><strong>Audio, Games, Web Audio API, audio sprites, spatialization, syncing tracks</strong></td>
</tr>
<tr>
    <td>Audio is an important part of any game; it adds feedback and atmosphere. Web-based audio is maturing fast, but there are still many browser differences to navigate. We often need to decide which audio parts are essential to our games' experience and which are nice to have but not essential, and devise a strategy accordingly. This article provides a detailed guide to implementing audio for web games, looking at what works currently across as wide a range of platforms as possible.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">27</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/Crisp_pixel_art_look">Crisp pixel art look with image-rendering</a></td>
    <td><strong>2D, 3D, CSS, Canvas, Games, JavaScript, WebGL, image-rendering, pixel</strong></td>
</tr>
<tr>
    <td>This article discusses a useful technique for giving your canvas/WebGL games a crisp pixel art look, even on high definition monitors.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">28</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/Efficient_animation_for_web_games">Efficient animation for web games</a></td>
    <td><strong>Animation, Games, JavaScript</strong></td>
</tr>
<tr>
    <td>This article covers techniques and advice for creating efficient animation for web games, with a slant towards supporting lower end devices such as mobile phones. We touch on <a href="/en-US/docs/Web/Guide/CSS/Using_CSS_transitions">CSS transitions</a> and <a href="/en-US/docs/Web/Guide/CSS/Using_CSS_animations">CSS animations</a>, and JavaScript loops involving <a href="/en-US/docs/Web/API/Window/requestAnimationFrame"><code>window.requestAnimationFrame</code></a>.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">29</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/Controls_Gamepad_API">Implementing controls using the Gamepad API</a></td>
    <td><strong>Controls, Gamepad API, Gamepads, Games, JavaScript, controllers</strong></td>
</tr>
<tr>
    <td>The Gamepad API is very easy to develop with. Now it's easier than ever to deliver a console-like experience to the browser without the need for any plugins. You can play the full version of the <a href="http://enclavegames.com/games/hungry-fridge/">Hungry Fridge</a> game directly in your browser, install it from the <a href="https://marketplace.firefox.com/app/hungry-fridge">Firefox Marketplace</a> or check the source code of the demo along with all the other resources on the <a href="http://end3r.github.io/Gamepad-API-Content-Kit/">Gamepad API Content Kit</a><a href="https://github.com/EnclaveGames/Hungry-Fridge">.</a></td>
</tr><tr>

</tr><tr>
    <td rowspan="2">30</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/Control_mechanisms">Implementing game control mechanisms</a></td>
    <td><strong>Controls, Desktop, Gamepad, Games, JavaScript, Laptop, Mobile, keyboard, mouse, touch</strong></td>
</tr>
<tr>
    <td>One of HTML5's main advantages as a game development platform is the ability to run on various platforms and devices. Streamlining cross device differences creates multiple challenges, not least when providing appropriate controls for different contexts. In this series of articles we will show you how you can approach building a game that can be played using touchscreen smartphones, mouse and keyboard, and also less common mechanisms such as gamepads.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">31</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/Control_mechanisms/Desktop_with_gamepad">Desktop gamepad controls</a></td>
    <td><strong>Controls, Desktop, Gamepad API, Gamepads, Games, JavaScript, controllers</strong></td>
</tr>
<tr>
    <td>That's it! We have successfully implemented gamepad controls in our game — try connecting any popular controller like the XBox 360 one and see for yourself how fun it is to avoid the asteroids and shoot the aliens with a gamepad.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">32</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/Control_mechanisms/Desktop_with_mouse_and_keyboard">Desktop mouse and keyboard controls</a></td>
    <td><strong>Controls, Desktop, Games, JavaScript, keyboard, mouse</strong></td>
</tr>
<tr>
    <td>Ok, we've dealt with touch, keyboard, and mouse controls. Now let's move on to look at how to set up the game to be controlled using a console gamepad, using the <a href="/en-US/docs/Web/API/Gamepad_API">Gamepad API</a>.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">33</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/Control_mechanisms/Mobile_touch">Mobile touch controls</a></td>
    <td><strong>Controls, Games, JavaScript, Mobile, pointer, touch</strong></td>
</tr>
<tr>
    <td>That covers adding touch controls for mobile; in the next article we'll see how to add keyboard and mouse support.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">34</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/Control_mechanisms/Other">Unconventional controls</a></td>
    <td><strong>Controls, Doppler, Games, JavaScript, Makey Makey, Proximity, TV Leap Motion, Voice</strong></td>
</tr>
<tr>
    <td>I hope you liked the experiments — if you have any others that you think might interest other people, feel free to add details of them here.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">35</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/Tilemaps">Tiles and tilemaps overview</a></td>
    <td><strong>2D, Canvas, Games, JavaScript, Static, WebGL, tilemap, tiles</strong></td>
</tr>
<tr>
    <td>Tilemaps are a very popular technique in 2D game development, consisting of building the game world or level map out of small, regular-shaped images called <strong>tiles</strong>. This results in performance and memory usage gains — big image files containing entire level maps are not needed, as they are constructed by small images or image fragments multiple times. This set of articles covers the basics of creating tile maps using <a href="/en-US/docs/Web/JavaScript">JavaScript</a> and <a href="/en-US/docs/Web/API/Canvas_API">Canvas</a> (although the same high level techniques could be used in any programming language.)</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">36</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/Tilemaps/Square_tilemaps_implementation:_Scrolling_maps">Square tilemaps implementation: Scrolling maps</a></td>
    <td><strong>Canvas, Games, JavaScript, atlas, scrolling, spritesheet, tilemap, tiles</strong></td>
</tr>
<tr>
    <td>This article covers how to implement scrolling square tilemaps using the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">Canvas API</a>.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">37</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/Tilemaps/Square_tilemaps_implementation:_Static_maps">Square tilemaps implementation: Static maps</a></td>
    <td><strong>Canvas, Games, JavaScript, Static, atlas, spritesheet, tilemap, tilemaps, tiles</strong></td>
</tr>
<tr>
    <td>This article covers how to implement static square tilemaps using the <a href="/en-US/docs/Web/API/Canvas_API">Canvas API</a>.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">38</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Techniques/WebRTC_data_channels">WebRTC data channels</a></td>
    <td><strong>API, Games, NeedsContent, Network, P2P, WebRTC, data channels</strong></td>
</tr>
<tr>
    <td>The <a href="/en-US/docs/WebRTC" title="/en-US/docs/WebRTC">WebRTC</a> (Web Real-Time Communications) API is primarily known for its support for audio and video communications; however, it also offers peer-to-peer data channels. This article explains more about this, and shows you how to use libraries to implement data channels in your game.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">39</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tools">Tools for game development</a></td>
    <td><strong>Games, Gecko, Guide, JavaScript</strong></td>
</tr>
<tr>
    <td>On this page you can find links to our game development tools articles, which eventually aims to cover frameworks, compilers, and debugging tools.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">40</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tools/asm.js">asm.js</a></td>
    <td><strong>Deprecated, JavaScript, asm.js</strong></td>
</tr>
<tr>
    <td><a href="http://asmjs.org/">Asm.js</a> is a specification defining a subset of JavaScript that is highly optimizable. This article looks at exactly what is permitted in the asm.js subset, what improvements it confers, where and how you can make use of it, and further resources and examples.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">41</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials">Tutorials</a></td>
    <td><strong>Canvas, Games, JavaScript, Web, Workflows</strong></td>
</tr>
<tr>
    <td>This page contains multiple tutorial series that highlight different workflows for effectively creating different types of web games.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">42</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_breakout_game_Phaser">2D breakout game using Phaser</a></td>
    <td><strong>2D, Beginner, Canvas, Games, JavaScript, Phaser, Tutorial</strong></td>
</tr>
<tr>
    <td>In this step-by-step tutorial, we create a simple mobile <strong>MDN Breakout</strong> game written in JavaScript, using the <a href="http://phaser.io/">Phaser</a> framework.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">43</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_breakout_game_Phaser/Animations_and_tweens">Animations and tweens</a></td>
    <td><strong>2D, Animation, Beginner, Canvas, Games, JavaScript, Phaser, Tutorial, tween</strong></td>
</tr>
<tr>
    <td>To make the game look more juicy and alive we can use animations and tweens. This will result in a better, more entertaining experience. Let's explore how to implement Phaser animations and tweens in our game.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">44</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_breakout_game_Phaser/Bounce_off_the_walls">Bounce off the walls</a></td>
    <td><strong>2D, Beginner, Canvas, Games, JavaScript, Phaser, Tutorial, bouncing</strong></td>
</tr>
<tr>
    <td>Now that physics have been introduced, we can start implementing collision detection into the game — first we'll look at the walls.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">45</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_breakout_game_Phaser/Build_the_brick_field">Build the brick field</a></td>
    <td><strong>2D, Beginner, Canvas, Games, JavaScript, Phaser, Tutorial</strong></td>
</tr>
<tr>
    <td>Building the brick field is a little bit more complicated than adding a single object to the screen, although It's still easier with Phaser than in pure JavaScript. Let's explore how to create a group of bricks and print them on screen using a loop.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">46</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_breakout_game_Phaser/Buttons">Buttons</a></td>
    <td><strong>2D, Beginner, Buttons, Canvas, Games, JavaScript, Phaser, Tutorial</strong></td>
</tr>
<tr>
    <td>Instead of starting the game right away we can leave that decision to the player by adding a Start button they can press. Let's investigate how to do that.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">47</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_breakout_game_Phaser/Collision_detection">Collision detection</a></td>
    <td><strong>2D, Beginner, Canvas, Games, JavaScript, Phaser, Tutorial, collision detection</strong></td>
</tr>
<tr>
    <td>Now onto the next challenge — the collision detection between the ball and the bricks. Luckily enough we can use the physics engine to check collisions not only between single objects (like the ball and the paddle), but also between an object and the group.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">48</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_breakout_game_Phaser/Extra_lives">Extra lives</a></td>
    <td><strong>2D, Beginner, Canvas, Games, JavaScript, Phaser, Tutorial, lives</strong></td>
</tr>
<tr>
    <td>We can make the game enjoyable for longer by adding lives. In this article we'll implement a lives system, so that the player can continue playing until they have lost three lives, not just one.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">49</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_breakout_game_Phaser/Game_over">Game over</a></td>
    <td><strong>2D, Beginner, Canvas, Games, JavaScript, Phaser, Tutorial, game over</strong></td>
</tr>
<tr>
    <td>To make the game more interesting we can introduce the ability to lose — if you don't hit the ball before it reaches the bottom edge of the screen it will be game over.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">50</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_breakout_game_Phaser/Initialize_the_framework">Initialize the framework</a></td>
    <td><strong>2D, Beginner, Canvas, Games, HTML, JavaScript, Phaser, Tutorial</strong></td>
</tr>
<tr>
    <td>Before we can start writing the game's functionality, we need to create a basic structure to render the game inside. This can be done using HTML — the Phaser framework will generate the required <a href="/en-US/docs/Web/HTML/Element/canvas" title="Use the HTML &lt;canvas> element with either the canvas scripting API or the WebGL API to draw graphics and animations."><code>&lt;canvas&gt;</code></a> element.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">51</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_breakout_game_Phaser/Load_the_assets_and_print_them_on_screen">Load the assets and print them on screen</a></td>
    <td><strong>2D, Beginner, Canvas, Games, JavaScript, Phaser, Sprites, Tutorial</strong></td>
</tr>
<tr>
    <td>Our game will feature a ball rolling around the screen, bouncing off a paddle, and destroying bricks to earn points — familiar, huh? In this article we'll look at how to add sprites into our gameworld.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">52</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_breakout_game_Phaser/Move_the_ball">Move the ball</a></td>
    <td><strong>2D, Beginner, Canvas, Games, JavaScript, Phaser, Tutorial, moving</strong></td>
</tr>
<tr>
    <td>We have our blue ball printed on screen, but it's doing nothing — It would be cool to make it move somehow. This article covers how to do just that.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">53</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_breakout_game_Phaser/Physics">Physics</a></td>
    <td><strong>2D, Beginner, Canvas, Games, JavaScript, Phaser, Tutorial, physics</strong></td>
</tr>
<tr>
    <td>For proper collision detection between objects in our game we will need to have physics; this article introduces you to what's available in Phaser, as well as demonstrating a typical simple setup.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">54</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_breakout_game_Phaser/Player_paddle_and_controls">Player paddle and controls</a></td>
    <td><strong>2D, Beginner, Canvas, Games, JavaScript, Phaser, Tutorial</strong></td>
</tr>
<tr>
    <td>We have the ball moving and bouncing off the walls, but it quickly gets boring — there's no interactivity! We need a way to introduce gameplay, so in this article we'll create a paddle to move around and hit the ball with.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">55</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_breakout_game_Phaser/Randomizing_gameplay">Randomizing gameplay</a></td>
    <td><strong>2D, Beginner, Canvas, Games, JavaScript, Phaser, Tutorial</strong></td>
</tr>
<tr>
    <td>You've finished all the lessons — congratulations! By this point you would have learnt the basics of Phaser and the logic behind simple 2D games.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">56</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_breakout_game_Phaser/Scaling">Scaling</a></td>
    <td><strong>2D, Beginner, Canvas, Games, JavaScript, Phaser, Tutorial</strong></td>
</tr>
<tr>
    <td>Scaling refers to how the game canvas will scale on different screen sizes. We can make the game scale to fit on any screen size automatically during the preload stage, so we don't have to worry about it later.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">57</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_breakout_game_Phaser/The_score">The score</a></td>
    <td><strong>2D, Beginner, Canvas, Games, JavaScript, Phaser, Tutorial, scoring</strong></td>
</tr>
<tr>
    <td>Having a score can also make the game more interesting — you can try to beat your own highscore, or your friend's. In this article we'll add a scoring system to our game.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">58</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_breakout_game_Phaser/Win_the_game">Win the game</a></td>
    <td><strong>2D, Beginner, Canvas, Games, JavaScript, Phaser, Tutorial, winning</strong></td>
</tr>
<tr>
    <td>Implementing winning in our game is quite easy: if you happen to destroy all the bricks, then you win.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">59</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript">2D breakout game using pure JavaScript</a></td>
    <td><strong>2D, Beginner, Canvas, Games, JavaScript, Tutorial</strong></td>
</tr>
<tr>
    <td>In this step-by-step tutorial we create a simple <strong>MDN Breakout</strong> game written entirely in pure JavaScript and rendered on HTML5 <a href="/en-US/docs/Web/HTML/Element/canvas" title="Use the HTML &lt;canvas> element with either the canvas scripting API or the WebGL API to draw graphics and animations."><code>&lt;canvas&gt;</code></a>.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">60</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript/Bounce_off_the_walls">Bounce off the walls</a></td>
    <td><strong>Animation, Beginner, Canvas, Example, Games, Graphics, Tutorial, collision, detection</strong></td>
</tr>
<tr>
    <td>It is nice to see our ball moving, but it quickly disappears from the screen, limiting the fun we can have with it! To overcome that we will implement some very simple collision detection (which will be explained <a href="https://developer.mozilla.org/en-US/docs/Games/Workflows/Breakout_game_from_scratch/Collision_detection">later</a> in more detail) to make the ball bounce off the four edges of the Canvas.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">61</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript/Build_the_brick_field">Build the brick field</a></td>
    <td><strong>Beginner, Canvas, Games, Graphics, JavaScript, Tutorial</strong></td>
</tr>
<tr>
    <td>After modifying the gameplay mechanics, we are now able to lose — this is great as it means the game is finally feeling more like a game. However, it will quickly get boring if all you do is bounce the ball off the walls and the paddle. What a breakout game really needs is some bricks to destroy with the ball, and this is what we'll create now!</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">62</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript/Collision_detection">Collision detection</a></td>
    <td><strong>Beginner, Canvas, Games, JavaScript, Tutorial, collision, detection</strong></td>
</tr>
<tr>
    <td>We have the bricks appearing on the screen already, but the game still isn't <em>that</em> interesting as the ball goes through them. We need to think about adding collision detection so it can bounce off the bricks and break them.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">63</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript/Create_the_Canvas_and_draw_on_it">Create the Canvas and draw on it</a></td>
    <td><strong>2D, Beginner, Canvas, Games, HTML, JavaScript, Tutorial</strong></td>
</tr>
<tr>
    <td>Before we can start writing the game's functionality, we need to create a basic structure to render the game inside. This can be done using HTML and the <a href="/en-US/docs/Web/HTML/Element/canvas" title="Use the HTML &lt;canvas> element with either the canvas scripting API or the WebGL API to draw graphics and animations."><code>&lt;canvas&gt;</code></a> element.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">64</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript/Finishing_up">Finishing up</a></td>
    <td><strong>Beginner, Canvas, Games, JavaScript, Tutorial, lives, requestAnimationFrame</strong></td>
</tr>
<tr>
    <td>There's always room for improvements in any game we write. For example, we can offer more than one life to the player. They could make a mistake or two and still be able to finish the game. We could also improve our code rendering.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">65</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript/Game_over">Game over</a></td>
    <td><strong>Beginner, Canvas, Games, Graphics, JavaScript, Tutorial, game over</strong></td>
</tr>
<tr>
    <td>It's fun to watch the ball bouncing off the walls and be able to move the paddle around, but other than that the game does nothing and doesn't have any progression or end goal. It would be good from the gameplay point of view to be able to lose. The logic behind losing in breakout is simple. If you miss the ball with the paddle and let it reach the bottom edge of the screen, then it's game over.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">66</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript/Mouse_controls">Mouse controls</a></td>
    <td><strong>Beginner, Canvas, Controls, Games, JavaScript, Tutorial, mouse</strong></td>
</tr>
<tr>
    <td>The game itself is actually finished, so let's work on polishing it up. We have already added keyboard controls, but we could easily add mouse controls too.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">67</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript/Move_the_ball">Move the ball</a></td>
    <td><strong>2D, Beginner, Canvas, Games, JavaScript, Loop, Tutorial, movement</strong></td>
</tr>
<tr>
    <td>You already know how to draw a ball from working through the previous article, so now let's make it move. Technically, we will be painting the ball on the screen, clearing it and then painting it again in a slightly different position every frame to make the impression of movement — just like how movement works with the movies.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">68</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript/Paddle_and_keyboard_controls">Paddle and keyboard controls</a></td>
    <td><strong>Beginner, Canvas, Controls, Games, Graphics, JavaScript, Tutorial, keyboard</strong></td>
</tr>
<tr>
    <td>The ball is bouncing off the walls freely and you can watch it indefinitely, but currently there's no interactivity. It's not a game if you cannot control it! So let's add some user interaction: a controllable paddle.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">69</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/2D_Breakout_game_pure_JavaScript/Track_the_score_and_win">Track the score and win</a></td>
    <td><strong>Beginner, Canvas, Games, JavaScript, Tutorial, scoring, winning</strong></td>
</tr>
<tr>
    <td>Destroying the bricks is really cool, but to be even more awesome the game could award points for every brick a user hits, and keep count of the total score.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">70</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/HTML5_Gamedev_Phaser_Device_Orientation">2D maze game with device orientation</a></td>
    <td><strong>Canvas, Device Orientation API, Game Development, HTML5, Phaser, Vibration API</strong></td>
</tr>
<tr>
    <td>I hope this tutorial will help you dive into 2D game development and inspire you to create awesome games on your own. You can play the demo game <a href="https://orb.enclavegames.com/">Cyber Orb</a> and check out its <a href="https://github.com/EnclaveGames/Cyber-Orb">source code on GitHub</a>.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">71</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Tutorials/Touch_Event_Horizon">Touch Event Horizon</a></td>
    <td><strong>NeedsContent, NeedsExample</strong></td>
</tr>
<tr>
    <td>This tutorial shows how to use Touch Events to create a game on a &lt;canvas&gt;. This is a multi-player game relying on the Tap and Drag gestures.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">72</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Visual_JS_GE">Visual JS GE</a></td>
    <td><strong>Canvas, JavaScript, Server, game engine</strong></td>
</tr>
<tr>
    <td><strong>Visual-js </strong>GameEngine is a small but comprehensive canvas/websocket-based game engine with GUI source editor only for Windows. The server is based on Node.js vs MySql, the client made in four variant on a JavaScript frameworks for 2d canvas JS , three.js , webGL2 vs glmatrix and 2d canvas with matter.js in typescript to complete the stack.</td>
</tr><tr>

</tr><tr>
    <td rowspan="2">73</td>
    <td rowspan="2"><a href="/en-US/docs/Games/Visual-js_game_engine">Visual-js game engine</a></td>
    <td><strong>HTML5, JavaScript, Tools, game engine, visual-js</strong></td>
</tr>
<tr>
    <td>creator : Nikola Lukic 2017</td>
</tr><tr>


</tr></tbody>
</table>
